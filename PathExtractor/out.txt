[["EventHandler eventHandler , Options options , ConfigFile configFile", "Environment env =  createEnvironment (  eventHandler   ,  Environment.SKYLARK   ,  ImmutableMap (  )    )   ", "for ( Class module :  modules   )", " logger.log (  Level.INFO   ,  STR_   +  module.getName (  )    )   ", " Runtime.registerModuleGlobals (  env   ,  module   )   ", " if (  OptionsAwareModule  isAssignableFrom (  module   )     . isAssignableFrom (  module   )    ) ", " if (  LabelsAwareModule  isAssignableFrom (  module   )     . isAssignableFrom (  module   )    ) ", " env.mutability (  )   . close (  )   ", " return  env.getGlobals (  )   "], ["EventHandler eventHandler , Options options , ConfigFile configFile", "Environment env =  createEnvironment (  eventHandler   ,  Environment.SKYLARK   ,  ImmutableMap (  )    )   ", "for ( Class module :  modules   )", " logger.log (  Level.INFO   ,  STR_   +  module.getName (  )    )   ", " Runtime.registerModuleGlobals (  env   ,  module   )   ", " if (  OptionsAwareModule  isAssignableFrom (  module   )     . isAssignableFrom (  module   )    ) ", " if (  LabelsAwareModule  isAssignableFrom (  module   )     . isAssignableFrom (  module   )    ) "]]
[["int x , int y", " if (  y   <  NUM_   ||  y   >=  height   ||  x   <  NUM_   ||  x   >=  width   ) ", " return  BOOL_  "], ["int x , int y", " if (  y   <  NUM_   ||  y   >=  height   ||  x   <  NUM_   ||  x   >=  width   ) ", " return  BOOL_  "]]
[["Context context , Request request , String resourceId , String revision , List patchOperations", " idRequired (  request.getResourcePath (  )    )   ", " noSubObjects (  request.getResourcePath (  )    )   ", "ResourceResponse resource =  readResource (  context   ,  repoId (  resourceId   )    )   ", " return  patchResource (  context   ,  request   ,  resource   ,  revision   ,  patchOperations   )   "]]
[[" chartView.zoomOut (  )   ", " zoomControls.setIsZoomInEnabled (  chartView.canZoomIn (  )    )   ", " zoomControls.setIsZoomOutEnabled (  chartView.canZoomOut (  )    )   "]]
[["ValueAxis rangeAxis", "   ", "  subplots    . subplots   =  new java.util.ArrayList (  )   "]]
[["Item helmet , Item chestplate , Item leggings , Item boots , String res1 , String res2", " addGhoulArmorTextures (  helmet   ,  chestplate   ,  leggings   ,  boots   ,  new ResourceLocation (  res1   )    ,  new ResourceLocation (  res2   )    )   "]]
[["   "]]
[["String key", " return   optInt (  key   ,  NUM_   )     . optInt (  key   ,  NUM_   )   "]]
[["Connector connector", "RaptorWindowItem items =  Raptor.getInstance (  )   . getWindow (  )   . getWindowItems (  BugButtonsWindowItem    )   ", "boolean openNewWindow =  BOOL_  ", "for ( RaptorWindowItem item :  items   )", "BugButtonsWindowItem bugButtonsItem", " if (  bugButtonsItem.getConnector (  )    ==  connector   ) ", " if (  openNewWindow   ) ", " Raptor.getInstance (  )   . getWindow (  )   . addRaptorWindowItem (  new BugButtonsWindowItem (  connector   )    )   "], ["Connector connector", "RaptorWindowItem items =  Raptor.getInstance (  )   . getWindow (  )   . getWindowItems (  BugButtonsWindowItem    )   ", "boolean openNewWindow =  BOOL_  ", "for ( RaptorWindowItem item :  items   )", "BugButtonsWindowItem bugButtonsItem", " if (  bugButtonsItem.getConnector (  )    ==  connector   ) ", " Raptor.getInstance (  )   . getWindow (  )   . forceFocus (  item   )   ", " openNewWindow   =  BOOL_  ", " if (  openNewWindow   ) ", " Raptor.getInstance (  )   . getWindow (  )   . addRaptorWindowItem (  new BugButtonsWindowItem (  connector   )    )   "], ["Connector connector", "RaptorWindowItem items =  Raptor.getInstance (  )   . getWindow (  )   . getWindowItems (  BugButtonsWindowItem    )   ", "boolean openNewWindow =  BOOL_  ", "for ( RaptorWindowItem item :  items   )", "BugButtonsWindowItem bugButtonsItem", " if (  bugButtonsItem.getConnector (  )    ==  connector   ) ", " Raptor.getInstance (  )   . getWindow (  )   . forceFocus (  item   )   ", " openNewWindow   =  BOOL_  "], ["Connector connector", "RaptorWindowItem items =  Raptor.getInstance (  )   . getWindow (  )   . getWindowItems (  BugButtonsWindowItem    )   ", "boolean openNewWindow =  BOOL_  ", "for ( RaptorWindowItem item :  items   )", "BugButtonsWindowItem bugButtonsItem", " if (  bugButtonsItem.getConnector (  )    ==  connector   ) "]]
[["JavaParameterSpec spec , Document document , Element parentElement", "Element parameter =  document.createElement (  STR_   )   ", " parentElement.appendChild (  parameter   )   ", " parameter.setAttribute (  STR_   ,  spec.getPackageName (  )    )   ", " parameter.setAttribute (  STR_   ,  spec.getClassName (  )    )   ", " parameter.setAttribute (  STR_   ,  spec.getHalfSignature (  )    )   ", " parameter.setAttribute (  STR_   ,  Integer.toString (  spec.getParamIdx (  )    )    )   "]]
[["Vector newVector =  new Vector (  NUM_   )   ", " newVector.addElement (  new Option (  STR_   +  STR_   +  STR_   +  STR_   ,  STR_   ,  NUM_   ,  STR_   )    )   ", " newVector.addElement (  new Option (  STR_   +  STR_   ,  STR_   ,  NUM_   ,  STR_   )    )   ", " return  newVector.elements (  )   "]]
[["String tokenExpiry", "Date expiryDate =  DateUtils.stringToDate (  tokenExpiry   )   ", "long now =  currentTimeMillis (  )   ", " if (  expiryDate.getTime (  )    <=  now   ) ", " return  BOOL_  "], ["String tokenExpiry", "Date expiryDate =  DateUtils.stringToDate (  tokenExpiry   )   ", "long now =  currentTimeMillis (  )   ", " if (  expiryDate.getTime (  )    <=  now   ) ", " return  BOOL_  "]]
[["boolean nodeRemoved =   removeConvertedNodes (  root   )     . removeConvertedNodes (  root   )   ", " if ( ! nodeRemoved   &&  root.hasChildren (  )    ) ", " logger.debug (  STR_   ,  blockingQueue.size (  )    )   ", "  blockingQueue   ,  take (  )     . blockingQueue  . take (  )   ", "  blockingQueue   ,  offer (  NUM_   )     . blockingQueue  . offer (  NUM_   )   ", " logger.debug (  STR_   ,  blockingQueue.size (  )    )   "]]
[]
[["PointLayer point", "Image pointIcon =  point.getIcon (  )   ", " if (  pointIcon   ==  null   ) ", " if ( ! point.isProjected (  )    ) ", " points.addElement (  point   )   "], ["PointLayer point", "Image pointIcon =  point.getIcon (  )   ", " if (  pointIcon   ==  null   ) ", " if ( ! point.isProjected (  )    ) ", "Coord c =  getProjection (  )   . fromWGS84 (  point   )   ", " point.setLatitude (  c.getLatitude (  )    )   ", " point.setLongitude (  c.getLongitude (  )    )   ", " point.setProjected (  BOOL_   )   ", " points.addElement (  point   )   "], ["PointLayer point", "Image pointIcon =  point.getIcon (  )   ", " if (  pointIcon   ==  null   ) ", " point.setIcon (  icon   )   ", " if ( ! point.isProjected (  )    ) ", " points.addElement (  point   )   "], ["PointLayer point", "Image pointIcon =  point.getIcon (  )   ", " if (  pointIcon   ==  null   ) ", " point.setIcon (  icon   )   ", " if ( ! point.isProjected (  )    ) ", "Coord c =  getProjection (  )   . fromWGS84 (  point   )   ", " point.setLatitude (  c.getLatitude (  )    )   ", " point.setLongitude (  c.getLongitude (  )    )   ", " point.setProjected (  BOOL_   )   ", " points.addElement (  point   )   "]]
[["GreaterOp_ object", " return  null  "]]
[["FontFactory factory =  FontFactory.getInstance (  )   ", "byte data =  readToByteArray (  TestFont.TestFontNames.ROBOTO.getFile (  )    )   ", "Font byteFont =  factory.loadFonts (  data   )    [  NUM_   ]", "InputStream is =  new FileInputStream (  TestFont.TestFontNames.ROBOTO.getFile (  )    )   ", "Font streamFont", " streamFont   =  factory.loadFonts (  is   )    [  NUM_   ]", "boolean thrown =  BOOL_  ", "Glyph byteGlyph =  getLastGlyph (  byteFont   )   ", "int byteXMin =  byteGlyph.xMin (  )   ", " assertTrue (  STR_   ,  thrown   )   ", "boolean thrown =  BOOL_  ", "Glyph streamGlyph =  getLastGlyph (  streamFont   )   ", "int streamXMin =  streamGlyph.xMin (  )   ", " assertTrue (  STR_   ,  thrown   )   "]]
[["AnnotatedPrimitiveType type , Tree tree", " return  BOOL_  "]]
[[" if (  jpegBuffer   ==  null   ||  jpegBuffer.isNull (  )    ) ", " if (  currentVideoFrameCount   <=  lastVideoFrameCount   ) ", " if (  log.isDebugEnabled (  )    ) ", " return  SceKernelErrors.ERROR_USBCAM_NO_VIDEO_FRAME_AVAILABLE  "], [" if (  jpegBuffer   ==  null   ||  jpegBuffer.isNull (  )    ) ", " if (  currentVideoFrameCount   <=  lastVideoFrameCount   ) ", " if (  log.isDebugEnabled (  )    ) ", " log.debug (  String.format (  STR_   ,  currentVideoFrameCount   ,  lastVideoFrameCount   )    )   ", " return  SceKernelErrors.ERROR_USBCAM_NO_VIDEO_FRAME_AVAILABLE  "], [" if (  jpegBuffer   ==  null   ||  jpegBuffer.isNull (  )    ) ", " if (  currentVideoFrameCount   <=  lastVideoFrameCount   ) ", " return  writeCurrentVideoImage (  jpegBuffer   ,  jpegBufferSize   )   "], [" if (  jpegBuffer   ==  null   ||  jpegBuffer.isNull (  )    ) ", " return  SceKernelErrors.ERROR_USBCAM_NO_READ_ON_VIDEO_FRAME  "]]
[["long x", " x   ^=  x   >>>  NUM_  ", " x   *=  NUM_  ", " x   ^=  x   >>>  NUM_  ", " x   *=  NUM_  ", " x   ^=  x   >>>  NUM_  ", " return  x  "]]
[[" return  STR_   +  STR_   +  sharedSizeBytes   +  STR_   +  STR_   +  constSizeBytes   +  STR_   +  STR_   +  localSizeBytes   +  STR_   +  STR_   +  maxThreadsPerBlock   +  STR_   +  STR_   +  numRegs   +  STR_   +  STR_   +  ptxVersion   +  STR_   +  STR_   +  binaryVersion   +  STR_  "]]
[[" if (  destroyed   ||  jammed   ||  missing   ||  useless   ||  fired   ) ", " if (  type   instanceof AmmoWeapon ||  type   instanceof AmmoBayWeapon ) ", " if (  getLinked (  )    ==  null   ||  entity.getTotalAmmoOfType (  getLinked (  )   . getType (  )    )    <  NUM_   ) ", " return  BOOL_  "], [" if (  destroyed   ||  jammed   ||  missing   ||  useless   ||  fired   ) ", " if (  type   instanceof AmmoWeapon ||  type   instanceof AmmoBayWeapon ) ", " if (  getLinked (  )    ==  null   ||  entity.getTotalAmmoOfType (  getLinked (  )   . getType (  )    )    <  NUM_   ) ", " if (  isDWPMounted   &&  getLinkedBy (  )    !=  null   ) ", " return  BOOL_  "], [" if (  destroyed   ||  jammed   ||  missing   ||  useless   ||  fired   ) ", " if (  type   instanceof AmmoWeapon ||  type   instanceof AmmoBayWeapon ) ", " if (  getLinked (  )    ==  null   ||  entity.getTotalAmmoOfType (  getLinked (  )   . getType (  )    )    <  NUM_   ) ", " if (  isDWPMounted   &&  getLinkedBy (  )    !=  null   ) ", " return  BOOL_  "], [" if (  destroyed   ||  jammed   ||  missing   ||  useless   ||  fired   ) ", " if (  type   instanceof AmmoWeapon ||  type   instanceof AmmoBayWeapon ) ", " if (  isDWPMounted   &&  getLinkedBy (  )    !=  null   ) ", " return  BOOL_  "], [" if (  destroyed   ||  jammed   ||  missing   ||  useless   ||  fired   ) ", " if (  type   instanceof AmmoWeapon ||  type   instanceof AmmoBayWeapon ) ", " if (  isDWPMounted   &&  getLinkedBy (  )    !=  null   ) ", " return  BOOL_  "], [" if (  destroyed   ||  jammed   ||  missing   ||  useless   ||  fired   ) ", " return  BOOL_  "]]
[["int count", " if (  count   <  NUM_   ) ", " return  simpleSchedule (  )   . withIntervalInSeconds (  NUM_   )   . withRepeatCount (  count   -  NUM_   )   "], ["int count", " if (  count   <  NUM_   ) ", " new IllegalArgumentException (  STR_   +  count   )   ", " return  simpleSchedule (  )   . withIntervalInSeconds (  NUM_   )   . withRepeatCount (  count   -  NUM_   )   "]]
[["StringBuilder buf , String pattern , int index , boolean oldInside", "char firstChar =  pattern.charAt (  index   )   ", "boolean newInside =  oldInside  ", " if (  firstChar   ==  STR_   ||  firstChar   ==  STR_   ) ", " if (  index   +  NUM_   <  pattern.length (  )    ) ", " buf.append (  quote (  STR_   +  firstChar   ,  oldInside   )    )   ", " return  newInside  "], ["StringBuilder buf , String pattern , int index , boolean oldInside", "char firstChar =  pattern.charAt (  index   )   ", "boolean newInside =  oldInside  ", " if (  firstChar   ==  STR_   ||  firstChar   ==  STR_   ) ", " if (  index   +  NUM_   <  pattern.length (  )    ) ", " newInside   =  translateCommand (  buf   ,  pattern   ,  index   +  NUM_   ,  oldInside   )   ", " return  newInside  "], ["StringBuilder buf , String pattern , int index , boolean oldInside", "char firstChar =  pattern.charAt (  index   )   ", "boolean newInside =  oldInside  ", " if (  firstChar   ==  STR_   ||  firstChar   ==  STR_   ) ", "String command =  translate.getProperty (  String.valueOf (  firstChar   )    )   ", " if (  command   ==  null   ) ", " buf.append (  quote (  STR_   +  firstChar   ,  oldInside   )    )   ", " return  newInside  "], ["StringBuilder buf , String pattern , int index , boolean oldInside", "char firstChar =  pattern.charAt (  index   )   ", "boolean newInside =  oldInside  ", " if (  firstChar   ==  STR_   ||  firstChar   ==  STR_   ) ", "String command =  translate.getProperty (  String.valueOf (  firstChar   )    )   ", " if (  command   ==  null   ) ", " if (  oldInside   ) ", " buf.append (  command   )   ", " newInside   =  BOOL_  ", " return  newInside  "], ["StringBuilder buf , String pattern , int index , boolean oldInside", "char firstChar =  pattern.charAt (  index   )   ", "boolean newInside =  oldInside  ", " if (  firstChar   ==  STR_   ||  firstChar   ==  STR_   ) ", "String command =  translate.getProperty (  String.valueOf (  firstChar   )    )   ", " if (  command   ==  null   ) ", " if (  oldInside   ) ", " buf.append (  STR_   )   ", " buf.append (  command   )   ", " newInside   =  BOOL_  ", " return  newInside  "]]
[["String namespace , String name , Attributes attributes", " if (  digester.getLogger (  )   . isDebugEnabled (  )    ) ", " digester.getLogger (  )   . debug (  STR_   +  digester.getMatch (  )    +  STR_   +  CLASS_NAME   )   ", "Class clazz =  digester.getClassLoader (  )   . loadClass (  CLASS_NAME   )   ", "ManagedPropertyBean mpb", " digester.push (  mpb   )   "], ["String namespace , String name , Attributes attributes", " if (  digester.getLogger (  )   . isDebugEnabled (  )    ) ", "Class clazz =  digester.getClassLoader (  )   . loadClass (  CLASS_NAME   )   ", "ManagedPropertyBean mpb", " digester.push (  mpb   )   "]]
[["StructuredGraph graph", "LoopBeginNode loopBegin =  findFirstLoop (  graph   )   ", " loopBegin.disableSafepoint (  )   "]]
[["long ms", "long start =  threadMXBean.getCurrentThreadCpuTime (  )   ", "long durationMS =  threadMXBean.getCurrentThreadCpuTime (  )    -  start   /  NUM_  ", " if (  durationMS   >=  ms   ) ", " while (  BOOL_   ) "], ["long ms", "long start =  threadMXBean.getCurrentThreadCpuTime (  )   ", "long durationMS =  threadMXBean.getCurrentThreadCpuTime (  )    -  start   /  NUM_  ", " if (  durationMS   >=  ms   ) ", " return  durationMS  "]]
[["int errorCode", "String message", " message   =  ZZ_ERROR_MSG   [  errorCode   ]", " new Error (  message   )   "]]
[[" running   =  BOOL_  ", "while (  running   )", "Socket s =  ss.accept (  )   ", " acceptedConnections ++ ", " if (  acceptedConnections   >=  acceptLimit   ) ", " running   =  BOOL_  ", " new Thread (  new Worker (  s   )    ,  STR_   )   . start (  )   "], [" running   =  BOOL_  ", "while (  running   )", "Socket s =  ss.accept (  )   ", " acceptedConnections ++ ", " if (  acceptedConnections   >=  acceptLimit   ) ", " running   =  BOOL_  ", " new Thread (  new Worker (  s   )    ,  STR_   )   . start (  )   ", " log (  STR_   +     )   "], [" running   =  BOOL_  ", "while (  running   )", "Socket s =  ss.accept (  )   ", " acceptedConnections ++ ", " if (  acceptedConnections   >=  acceptLimit   ) ", " new Thread (  new Worker (  s   )    ,  STR_   )   . start (  )   "], [" running   =  BOOL_  ", "while (  running   )", "Socket s =  ss.accept (  )   ", " acceptedConnections ++ ", " if (  acceptedConnections   >=  acceptLimit   ) ", " new Thread (  new Worker (  s   )    ,  STR_   )   . start (  )   ", " log (  STR_   +     )   "]]
[[" return  new KeyIterator (  )   "]]
[["ActionMap map =    ", " map.put (  STR_   ,  new EditorActions.SaveAction (  BOOL_   )    )   ", " map.put (  STR_   ,  new EditorActions.SaveAction (  BOOL_   )    )   ", " map.put (  STR_   ,  new EditorActions.NewAction (  )    )   ", " map.put (  STR_   ,  new EditorActions.OpenAction (  )    )   ", " map.put (  STR_   ,  new EditorActions.HistoryAction (  BOOL_   )    )   ", " map.put (  STR_   ,  new EditorActions.HistoryAction (  BOOL_   )    )   ", " map.put (  STR_   ,  mxGraphActions.getSelectVerticesAction (  )    )   ", " map.put (  STR_   ,  mxGraphActions.getSelectEdgesAction (  )    )   ", " return  map  "]]
[["Iterator iter =  keyMap.entrySet (  )   . iterator (  )   ", "StringBuffer buff =  new StringBuffer (  STR_   )   ", "while (  iter.hasNext (  )    )", "Map.Entry entry", " buff.append (  STR_   )   . append (  entry.getKey (  )    )   . append (  STR_   )   . append (  entry.getValue (  )    )   "], ["Iterator iter =  keyMap.entrySet (  )   . iterator (  )   ", "StringBuffer buff =  new StringBuffer (  STR_   )   ", "while (  iter.hasNext (  )    )", "Map.Entry entry", " buff.append (  STR_   )   . append (  entry.getKey (  )    )   . append (  STR_   )   . append (  entry.getValue (  )    )   ", " return  buff.toString (  )   "]]
[["Object ret", " if (  myHost   !=  null   ) ", " myHost.returnData (  ret   )   "]]
[["String value", " return  value.length (  )    ==  NUM_  "]]
[["String pattern , String str , Map uriTemplateVariables", "AntPathStringMatcher matcher =  new AntPathStringMatcher (  pattern   ,  str   ,  uriTemplateVariables   )   ", " return  matcher.matchStrings (  )   "]]
[["Class voType , Object inputParam , User currentUser", "T po =  findByIdParam (  inputParam   )   ", " BeanUtils.copyPropertiesIgnoreNull (  inputParam   ,  po   )   ", " return  updateByPO (  voType   ,  po   ,  currentUser   )   "]]
[["String address", " if (  address   ==  null   ) ", " new IllegalArgumentException (  STR_   )   ", "  address    . address   =  address.toLowerCase (  )   ", " matchBareJID   =  STR_.equals (  StringUtils.parseResource (  address   )    )   "], ["String address", " if (  address   ==  null   ) ", "  address    . address   =  address.toLowerCase (  )   ", " matchBareJID   =  STR_.equals (  StringUtils.parseResource (  address   )    )   "]]
[["ByteString rawBindDN , String saslMechanism , ByteString saslCredentials , List controls", "BindOperationBasis bindOperation =  new BindOperationBasis (     ,  nextOperationID (  )    ,  nextMessageID (  )    ,  controls   ,  PROTOCOL_VERSION   ,  rawBindDN   ,  saslMechanism   ,  saslCredentials   )   ", " bindOperation.setInternalOperation (  BOOL_   )   ", " bindOperation.run (  )   ", " return  bindOperation  "]]
[["String parameterName , Object parameterValue", " if (  parameterValue   ==  null   ) ", " new IllegalArgumentException (  parameterName   +  STR_   )   "]]
[["KeyEvent e", " if (  e.getKeyCode (  )    ==  KeyEvent.VK_ESCAPE   ) ", " setText (  m_initialText   )   "]]
[["String charsetName =  systemVariables.getVariable (  STR_   )   ", " if (  charsetName   ==  null   ||  STR_.equalsIgnoreCase (  charsetName   )    ) ", " return  charsetName  "], ["String charsetName =  systemVariables.getVariable (  STR_   )   ", " if (  charsetName   ==  null   ||  STR_.equalsIgnoreCase (  charsetName   )    ) ", " charsetName   =  systemVariables.getVariable (  SERVER_CHARSET_NAME   )   ", " return  charsetName  "]]
[["int delay", " System.exit (  NUM_   )   "]]
[["Closeable closeable", " if (  closeable   !=  null   ) ", " closeable.close (  )   "]]
[["FilterChain filterChain , String key , String value", "ReplaceTokens replaceToken =  new ReplaceTokens (  )   ", "ReplaceTokens.Token token =  new ReplaceTokens.Token (  )   ", " token.setKey (  key   )   ", " token.setValue (  value   )   ", " replaceToken.addConfiguredToken (  token   )   ", " filterChain.addReplaceTokens (  replaceToken   )   "]]
[[" if (  relative   ==  null   ) ", " return  BOOL_  "], [" if (  relative   ==  null   ) ", " return  relative  "]]
[["Attribute attribute , Class interfaceName", " if (  interfaceName   ==  null   ) ", " new NullPointerException (  STR_   )   ", " myInterface   =  interfaceName  ", " add (  attribute   )   "], ["Attribute attribute , Class interfaceName", " if (  interfaceName   ==  null   ) ", " myInterface   =  interfaceName  ", " add (  attribute   )   "]]
[["OMPoly omPoly", "double points =  omPoly.getLatLonArray (  )   ", "int i =  points.length  ", "boolean isPolygon =  BOOL_  ", " if (  points   !=  null   &&  i   >  NUM_   ) ", " isPolygon   =  points   [  NUM_   ] ==  points   [  i   -  NUM_   ] &&  points   [  NUM_   ] ==  points   [  i   -  NUM_   ]", " isPolygon   =  isPolygon   &&  omPoly.isPolygon (  )   ", " return  isPolygon  "], ["OMPoly omPoly", "double points =  omPoly.getLatLonArray (  )   ", "int i =  points.length  ", "boolean isPolygon =  BOOL_  ", " if (  points   !=  null   &&  i   >  NUM_   ) ", " return  isPolygon  "]]
[[" return  WrappedByteBuffer.wrap (  _buf.slice (  )    )   "]]
[["ColumnTable tabIn", "ColumnTable tab", "SaveState extra =  tab.getExtraState (  )   ", "  columnList    . columnList   =  new ArrayList (  )   ", "for ( ColumnDesc col :  extra.columns   )", "ColumnDesc copy", " copy.column   =  null  ", "  columnList   ,  add (  copy   )     . columnList  . add (  copy   )   ", "  table    . table   =  tab.copy (  )   ", "  heap    . heap   =  extra.heap.copy (  )   ", "  nRow    . nRow   =  tab.getNRows (  )   ", " saveExtraState (  )   "], ["ColumnTable tabIn", "ColumnTable tab", "SaveState extra =  tab.getExtraState (  )   ", "  columnList    . columnList   =  new ArrayList (  )   ", "for ( ColumnDesc col :  extra.columns   )", "ColumnDesc copy", " copy.column   =  null  ", "  columnList   ,  add (  copy   )     . columnList  . add (  copy   )   "]]
[["Logger logger , Throwable e , ErrorType errorType , String msg", " LogUtils.traceError (  logger   ,  e   ,  errorType.description (  )    )   ", " return  new ResultVO (  errorType.name (  )    ,  OperationStatus.FAILURE   ,  msg   )   "]]
[["byte array", " sort (  NUM_   ,  array.length   ,  array   )   "]]
[["String text"]]
[["float xpoints , float ypoints , boolean geometryClosed", " return  calc (  xpoints   ,  ypoints   ,  geometryClosed   ,  NUM_   )   "]]
[[" return  STR_   +  digest.toString (  )   "]]
[["InfoDisplayListener aInfoDisplayListener", " IDListeners.remove (  aInfoDisplayListener   )   "]]
[[" doSlice (  Character.MAX_VALUE   )   ", " report (  STR_   )   ", " doSlice (  Character.MAX_CODE_POINT   )   ", " report (  STR_   )   "]]
[["String XMLFile", " loadConfig (  XMLFile   )   "]]
[["Object value", " list.add (  value   )   ", " return    "]]
[["BiosCommandResult result =  new BiosCommandResult (  )   ", " result.pending (  )   ", " return  result  "]]
[["TripRouter routingHandler , ActivityFacilities facilities", "  routingHandler    . routingHandler   =  routingHandler  ", "  facilities    . facilities   =  facilities  "]]
[["String name", " return  name.replace (  STR_   ,  STR_   )   . trim (  )   "]]
[["String uniqueName , boolean replicatedRegion", "Host host =  Host.getHost (  NUM_   )   ", "VM vm0 =  host.getVM (  NUM_   )   ", "VM vm1 =  host.getVM (  NUM_   )   ", "VM vm2 =  host.getVM (  NUM_   )   ", "VM vm3 =  host.getVM (  NUM_   )   ", "String name =  uniqueName   +  STR_  ", " createServerRegion (  vm0   ,  name   ,  replicatedRegion   )   ", "int port =  createServerRegion (  vm1   ,  name   ,  replicatedRegion   )   ", " createClientRegion (  vm2   ,  name   ,  port   ,  BOOL_   ,  ClientRegionShortcut.CACHING_PROXY   )   ", " createClientRegion (  vm3   ,  name   ,  port   ,  BOOL_   ,  ClientRegionShortcut.CACHING_PROXY   )   ", " createEntries (  vm2   )   ", " destroyEntries (  vm3   )   ", " unregisterInterest (  vm3   )   ", " forceGC (  vm0   )   ", " if ( ! replicatedRegion   ) ", " forceGC (  vm1   )   ", " checkClientReceivedGC (  vm2   )   ", " checkClientDoesNotReceiveGC (  vm3   )   "], ["String uniqueName , boolean replicatedRegion", "Host host =  Host.getHost (  NUM_   )   ", "VM vm0 =  host.getVM (  NUM_   )   ", "VM vm1 =  host.getVM (  NUM_   )   ", "VM vm2 =  host.getVM (  NUM_   )   ", "VM vm3 =  host.getVM (  NUM_   )   ", "String name =  uniqueName   +  STR_  ", " createServerRegion (  vm0   ,  name   ,  replicatedRegion   )   ", "int port =  createServerRegion (  vm1   ,  name   ,  replicatedRegion   )   ", " createClientRegion (  vm2   ,  name   ,  port   ,  BOOL_   ,  ClientRegionShortcut.CACHING_PROXY   )   ", " createClientRegion (  vm3   ,  name   ,  port   ,  BOOL_   ,  ClientRegionShortcut.CACHING_PROXY   )   ", " createEntries (  vm2   )   ", " destroyEntries (  vm3   )   ", " unregisterInterest (  vm3   )   ", " forceGC (  vm0   )   ", " if ( ! replicatedRegion   ) ", " checkClientReceivedGC (  vm2   )   ", " checkClientDoesNotReceiveGC (  vm3   )   "]]
[[" if ( ! EMClient.getInstance (  )   . isConnected (  )    ) ", " Toast.makeText (  getActivity (  )    ,  R.string.not_connect_to_server   ,  Toast.LENGTH_SHORT   )   . show (  )   "], [" if ( ! EMClient.getInstance (  )   . isConnected (  )    ) ", " startActivity (  new Intent (  getActivity (  )    ,  VoiceCallActivity    )   . putExtra (  STR_   ,  toChatUsername   )   . putExtra (  STR_   ,  BOOL_   )    )   ", " inputMenu.hideExtendMenuContainer (  )   "]]
[["Ed25519GroupElement g1 , Ed25519FieldElement f1 , Ed25519GroupElement g2 , Ed25519FieldElement f2", "Ed25519GroupElement h1 =  scalarMultiplyGroupElement (  g1   ,  f1   )   ", "Ed25519GroupElement h2 =  scalarMultiplyGroupElement (  g2   ,  f2   )   ", " return  addGroupElements (  h1   ,  h2.negate (  )    )   "]]
[["String content", "String result", "int i", " result   =  content  ", "for (  i   =  NUM_   ;  i   <  m_Javadocs.size (  )    ;  i ++  ) ", " result   =  m_Javadocs.get (  i   )   . updateJavadoc (  result   )   "], ["String content", "String result", "int i", " result   =  content  ", "for (  i   =  NUM_   ;  i   <  m_Javadocs.size (  )    ;  i ++  ) ", " result   =  m_Javadocs.get (  i   )   . updateJavadoc (  result   )   ", " return  result  "]]
[["TermNode context , TermNode innerContext", " if ( ! context.getValue (  )   . equals (  innerContext.getValue (  )    )    ) ", " new InvalidGraphContextException (  STR_   +  context   +  STR_   +  innerContext.getValue (  )    )   "]]
[["double value", "long bits =  Double.doubleToLongBits (  value   )   ", " if (  bits   ==  NUM_   ||  bits   ==  NUM_   ) ", " mv.visitInsn (  Opcodes.DCONST_0   +  )   "], ["double value", "long bits =  Double.doubleToLongBits (  value   )   ", " if (  bits   ==  NUM_   ||  bits   ==  NUM_   ) ", " mv.visitLdcInsn (  value   )   "]]
[[" return  getResult.isSourceEmpty (  )   "]]
[["int secondsBetweenLaunchOnLockedRetries", "  secondsBetweenLaunchOnLockedRetries    . secondsBetweenLaunchOnLockedRetries   =  secondsBetweenLaunchOnLockedRetries  ", " return    "]]
[["AbstractCli cli , String args", "ByteArrayOutputStream out =  new ByteArrayOutputStream (  )   ", "MemoryPrintStream err =  new MemoryPrintStream (  )   ", " GlobalFlags.resetAccessedStatus (  )   ", " CommandLine.setCommandArgs (  Utils.append (  new String [  ]    ,  args   )    )   ", "int rc =  cli.mainInit (  args   ,  out   ,  err.printStream (  )    )   ", " CommandLine.clearCommandArgs (  )   ", " return  new MainResult (  rc   ,  out.toString (  )    ,  err.toString (  )    )   "]]
[["JSONObject jo =  new JSONObject (  )   ", " toJSONObject (  jo   )   ", " jo.put (  STR_   ,  pConditionName   )   ", " if (  eCondition   !=  null   ) ", " return  jo  "], ["JSONObject jo =  new JSONObject (  )   ", " toJSONObject (  jo   )   ", " jo.put (  STR_   ,  pConditionName   )   ", " if (  eCondition   !=  null   ) ", "JSONObject subjo =  new JSONObject (  )   ", " subjo.put (  STR_   ,  eCondition.getClass (  )   . getName (  )    )   ", " subjo.put (  STR_   ,  eCondition.getState (  )    )   ", " jo.put (  STR_   ,  subjo   )   ", " return  jo  "]]
[["double cleanPrice , DayCounter dc , Compounding comp , Frequency freq , Date settlementDate , double accuracy , int maxEvaluations", " if (  settlementDate.isNull (  )    ) ", "Brent solver =  new Brent (  )   ", " solver.setMaxEvaluations (  maxEvaluations   )   ", "double dirtyPrice =  cleanPrice   +  accruedAmount (  settlementDate   )   ", "YieldFinder objective =  new YieldFinder (  notional (  settlementDate   )    ,   cashflows_    . cashflows_   ,  dirtyPrice   ,  dc   ,  comp   ,  freq   ,  settlementDate   )   ", " return  solver.solve (  objective   ,  accuracy   ,  NUM_   ,  NUM_   ,  NUM_   )   "], ["double cleanPrice , DayCounter dc , Compounding comp , Frequency freq , Date settlementDate , double accuracy , int maxEvaluations", " if (  settlementDate.isNull (  )    ) ", " settlementDate   =  settlementDate (  )   ", "Brent solver =  new Brent (  )   ", " solver.setMaxEvaluations (  maxEvaluations   )   ", "double dirtyPrice =  cleanPrice   +  accruedAmount (  settlementDate   )   ", "YieldFinder objective =  new YieldFinder (  notional (  settlementDate   )    ,   cashflows_    . cashflows_   ,  dirtyPrice   ,  dc   ,  comp   ,  freq   ,  settlementDate   )   ", " return  solver.solve (  objective   ,  accuracy   ,  NUM_   ,  NUM_   ,  NUM_   )   "]]
[[" return  new DefaultToken (  )   "]]
[["ProcessEngine processEngine", " processEngines.remove (  processEngine.getName (  )    )   "]]
[["Exception e , String msg", "   ", "  exception    . exception   =  e  "]]
[["double num", " return  num   *  num  "]]
[["TvShowEpisode episode", " if (  episodes.contains (  episode   )    ) ", "int oldValue =  episodes.size (  )   ", " episode.deleteFilesSafely (  )   ", " episodes.remove (  episode   )   ", " episode.removePropertyChangeListener (  propertyChangeListener   )   ", " removeFromSeason (  episode   )   ", " TvShowList.getInstance (  )   . removeEpisodeFromDb (  episode   )   ", " saveToDb (  )   ", " firePropertyChange (  REMOVED_EPISODE   ,  null   ,  episode   )   ", " firePropertyChange (  EPISODE_COUNT   ,  oldValue   ,  episodes.size (  )    )   "]]
[["SynthContext context , Graphics g , int x , int y , int w , int h", " if (  context.getComponent (  )   . getComponentOrientation (  )   . isLeftToRight (  )    ) ", " paintBackground (  context   ,  g   ,  x   ,  y   ,  w   ,  h   ,  null   )   "], ["SynthContext context , Graphics g , int x , int y , int w , int h", " if (  context.getComponent (  )   . getComponentOrientation (  )   . isLeftToRight (  )    ) ", "AffineTransform transform =  new AffineTransform (  )   ", " transform.translate (  x   ,  y   )   ", " transform.scale ( - NUM_   ,  NUM_   )   ", " transform.translate ( - w   ,  NUM_   )   ", " paintBackground (  context   ,  g   ,  NUM_   ,  NUM_   ,  w   ,  h   ,  transform   )   "]]
[[" return  new com.sun.identity.liberty.ws.meta.jaxb.impl.OrganizationNameTypeImpl (  )   "]]
[[" Main.triggerMenuInvalidationStatic (  )   "]]
[["PrintStream out", "PrintWriter pw =  new PrintWriter (  out   ,  BOOL_   )   ", " printStackTrace (  pw   )   ", " pw.flush (  )   "]]
[["int x", "int a , b , c , d", " d   =  x   &  NUM_  ", " x   >>=  NUM_  ", " c   =  x   &  NUM_  ", " x   >>=  NUM_  ", " b   =  x   &  NUM_  ", " x   >>=  NUM_  ", " a   =  x   &  NUM_  ", "int y =  sBoxes   [  NUM_   ] [  a   ] +  sBoxes   [  NUM_   ] [  b   ]", " y   ^=  sBoxes   [  NUM_   ] [  c   ]", " y   +=  sBoxes   [  NUM_   ] [  d   ]", " return  y  "]]
[["UpdateInventoryOutput ok =  new UpdateInventoryOutput (  )   ", " ok.setCode (  STR_   )   ", " return  ok  "]]
[["TextView widget , Spannable buffer", " return  BOOL_  "]]
[["int len", "  len    . len   =  len  ", " vect   =  new double [  len   ]   "]]
[["String message", " if (  myHost   !=  null   ) ", " myHost.showFeedback (  message   )   "], ["String message", " if (  myHost   !=  null   ) ", " System.out.println (  message   )   "]]
[["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " new IllegalArgumentException (  )   ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", " new IllegalArgumentException (  )   ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", " new IllegalArgumentException (  STR_   +  key   +  STR_   +  txState   )   ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " new IllegalArgumentException (  )   ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", " new IllegalArgumentException (  )   ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " new IllegalArgumentException (  )   ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", " new IllegalArgumentException (  STR_   +  key   +  STR_   +  txState   )   ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " new IllegalArgumentException (  )   ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", " new IllegalArgumentException (  )   ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", " new IllegalArgumentException (  STR_   +  key   +  STR_   +  txState   )   ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", " new IllegalArgumentException (  )   ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", " new IllegalArgumentException (  STR_   +  key   +  STR_   +  txState   )   ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " new IllegalArgumentException (  )   ", " if (  txState.tx   ==  NUM_   ) ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " if (  txState.tx   ==  NUM_   ) ", " new IllegalArgumentException (  )   ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", " new IllegalArgumentException (  )   ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", " new IllegalArgumentException (  STR_   +  key   +  STR_   +  txState   )   ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "], ["TxState txState", " if (  txState   ==  null   ) ", " if (  txState.tx   ==  NUM_   ) ", " new IllegalArgumentException (  )   ", " if (  txState.getReadsOnCommitTime (  )    <  NUM_   ) ", " new IllegalArgumentException (  )   ", "TupleSerializer tupleSer", "byte key =  tupleSer.serializeKey (  txState   )   ", " if (     ) ", "byte val =  tupleSer.serializeVal (  txState   )   ", "   "]]
[["int i", "TextBuilder tb =  new TextBuilder (  )   ", " return  tb.append (  i   )   . toText (  )   "]]
[["String project , String description , String comment , Map arguments , int flags", "   "]]
[]
[[" log.error (  STR_   )   ", " return  null  "]]
[["Body b1 , Body b2 , Vec2 ga1 , Vec2 ga2 , Vec2 anchor1 , Vec2 anchor2 , float r", " bodyA   =  b1  ", " bodyB   =  b2  ", " groundAnchorA   =  ga1  ", " groundAnchorB   =  ga2  ", " localAnchorA   =  bodyA.getLocalPoint (  anchor1   )   ", " localAnchorB   =  bodyB.getLocalPoint (  anchor2   )   ", "Vec2 d1 =  anchor1.sub (  ga1   )   ", " lengthA   =  d1.length (  )   ", "Vec2 d2 =  anchor2.sub (  ga2   )   ", " lengthB   =  d2.length (  )   ", " ratio   =  r  "]]
[[" return  tiling (  BOOL_   )   "]]
[["String lookupLocatorURLs", "String locatorURL =  null  ", "ArrayList locatorList =  new ArrayList (  )   ", " if (  lookupLocatorURLs   !=  null   &&  lookupLocatorURLs.length (  )    >  NUM_   ) ", " return  locatorList.toArray (  new LookupLocator [  locatorList.size (  )    ]    )   "], ["String lookupLocatorURLs", "String locatorURL =  null  ", "ArrayList locatorList =  new ArrayList (  )   ", " if (  lookupLocatorURLs   !=  null   &&  lookupLocatorURLs.length (  )    >  NUM_   ) ", "StringTokenizer st =  new StringTokenizer (  lookupLocatorURLs   ,  STR_   )   ", "while (  st.hasMoreTokens (  )    )", " locatorURL   =  st.nextToken (  )   . trim (  )   ", " if (  locatorURL.isEmpty (  )    ||  locatorURL.equals (  STR_   )    ) ", " if ( ! locatorURL.startsWith (  STR_   )    ) ", " locatorURL   =  STR_   +  locatorURL  ", "LookupLocator lookupLocator =  new LookupLocator (  locatorURL   )   ", " locatorList.add (  lookupLocator   )   "], ["String lookupLocatorURLs", "String locatorURL =  null  ", "ArrayList locatorList =  new ArrayList (  )   ", " if (  lookupLocatorURLs   !=  null   &&  lookupLocatorURLs.length (  )    >  NUM_   ) ", "StringTokenizer st =  new StringTokenizer (  lookupLocatorURLs   ,  STR_   )   ", "while (  st.hasMoreTokens (  )    )", " locatorURL   =  st.nextToken (  )   . trim (  )   ", " if (  locatorURL.isEmpty (  )    ||  locatorURL.equals (  STR_   )    ) ", " if ( ! locatorURL.startsWith (  STR_   )    ) ", " locatorURL   =  STR_   +  locatorURL  ", "LookupLocator lookupLocator =  new LookupLocator (  locatorURL   )   ", " locatorList.add (  lookupLocator   )   ", " return  locatorList.toArray (  new LookupLocator [  locatorList.size (  )    ]    )   "], ["String lookupLocatorURLs", "String locatorURL =  null  ", "ArrayList locatorList =  new ArrayList (  )   ", " if (  lookupLocatorURLs   !=  null   &&  lookupLocatorURLs.length (  )    >  NUM_   ) ", "StringTokenizer st =  new StringTokenizer (  lookupLocatorURLs   ,  STR_   )   ", "while (  st.hasMoreTokens (  )    )", " locatorURL   =  st.nextToken (  )   . trim (  )   ", " if (  locatorURL.isEmpty (  )    ||  locatorURL.equals (  STR_   )    ) ", " if ( ! locatorURL.startsWith (  STR_   )    ) ", "LookupLocator lookupLocator =  new LookupLocator (  locatorURL   )   ", " locatorList.add (  lookupLocator   )   "], ["String lookupLocatorURLs", "String locatorURL =  null  ", "ArrayList locatorList =  new ArrayList (  )   ", " if (  lookupLocatorURLs   !=  null   &&  lookupLocatorURLs.length (  )    >  NUM_   ) ", "StringTokenizer st =  new StringTokenizer (  lookupLocatorURLs   ,  STR_   )   ", "while (  st.hasMoreTokens (  )    )", " locatorURL   =  st.nextToken (  )   . trim (  )   ", " if (  locatorURL.isEmpty (  )    ||  locatorURL.equals (  STR_   )    ) ", " if ( ! locatorURL.startsWith (  STR_   )    ) ", "LookupLocator lookupLocator =  new LookupLocator (  locatorURL   )   ", " locatorList.add (  lookupLocator   )   ", " return  locatorList.toArray (  new LookupLocator [  locatorList.size (  )    ]    )   "]]
[["T array , int newLength", "T copy =  createWithSameComponentType (  newLength   ,  array   )   ", " System.arraycopy (  array   ,  NUM_   ,  copy   ,  NUM_   ,  Math.min (  array.length   ,  newLength   )    )   ", " return  copy  "]]
[]
[[" return  new TObjectHashIterator (     )   "]]
[["OFMessage m", "String msg =  getSwitchStateMessage (  m   ,  STR_   )   ", " new SwitchStateException (  msg   )   "]]
[["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", " new IllegalArgumentException (  STR_   )   ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", " new IllegalArgumentException (  STR_   )   ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", " new IllegalArgumentException (  STR_   )   ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "], ["CharArrayBuffer buffer", "   ", " if (  buffer   ==  null   ) ", " new IllegalArgumentException (  STR_   )   ", "int colon =  buffer.indexOf (  STR_   )   ", " if (  colon   == - NUM_   ) ", "String s =  buffer.substringTrimmed (  NUM_   ,  colon   )   ", " if (  s.length (  )    ==  NUM_   ) ", " new ParseException (  STR_   +  buffer.toString (  )    )   ", "  buffer    . buffer   =  buffer  ", "  name    . name   =  s  ", "  valuePos    . valuePos   =  colon   +  NUM_  "]]
[["String name", " return  byName.get (  name   )   "]]
[["String accountName , String remotePath", " return  accountName   +  remotePath  "]]
[["String args", " testFailLoadAndGc (  )   "]]
[["Object o", " return  map.remove (  o   )    ==  PRESENT  "]]
[["String key , int defaultValue", " return  getInt (  key   )   "]]
[["RandomEngine randomGenerator", " shared.setRandomGenerator (  randomGenerator   )   "]]
[["String eventShard , String shardService", " if (  logger.isDebugEnabled (  )    ) ", "ShardManager manager =  new ShardManager (  service   ,  url   ,  user   ,  password   ,  schemaName   ,  tableType   ,  context   )   ", "List params =  new ArrayList (  )   ", "Map newShard =  new HashMap (  )   ", " newShard.put (  ShardTable.SHARD_ID_COL   ,  eventShard   )   ", " newShard.put (  ShardTable.SHARD_MASTER_COL   ,  shardService   )   ", " params.add (  newShard   )   ", " manager.insert (  params   )   ", " shards.put (  eventShard   ,  new Shard (  newShard   )    )   ", " return  shards.get (  eventShard   )   "], ["String eventShard , String shardService", " if (  logger.isDebugEnabled (  )    ) ", " logger.debug (  STR_   +  eventShard   +  STR_   +  shardService   )   ", "ShardManager manager =  new ShardManager (  service   ,  url   ,  user   ,  password   ,  schemaName   ,  tableType   ,  context   )   ", "List params =  new ArrayList (  )   ", "Map newShard =  new HashMap (  )   ", " newShard.put (  ShardTable.SHARD_ID_COL   ,  eventShard   )   ", " newShard.put (  ShardTable.SHARD_MASTER_COL   ,  shardService   )   ", " params.add (  newShard   )   ", " manager.insert (  params   )   ", " shards.put (  eventShard   ,  new Shard (  newShard   )    )   ", " return  shards.get (  eventShard   )   "]]
[[" return   data   ,  length    . data  . length  "]]
[["InputStream stream , String charset", "   "]]
[["Font font", "CmapTable cmap =  font.getCmapTable (  )   ", " if (  cmap   !=  null   ) ", " if (  forceAscii   ) ", " cmapFmt   =  cmap.getCmapFormat (  Table.platformMicrosoft   ,  Table.encodingUGL   )   ", " if (  cmapFmt   ==  null   ) ", " cmapFmt   =  cmap.getCmapFormat (  Table.platformMicrosoft   ,  Table.encodingUndefined   )   ", " platformID   =  PLATFORM_MICROSOFT  ", " encodingID   =  ENCODING_UNDEFINED  ", " if (  cmapFmt   ==  null   ) ", " new RuntimeException (  STR_   )   "], ["Font font", "CmapTable cmap =  font.getCmapTable (  )   ", " if (  cmap   !=  null   ) ", " if (  forceAscii   ) ", " cmapFmt   =  cmap.getCmapFormat (  Table.platformMicrosoft   ,  Table.encodingUGL   )   ", " if (  cmapFmt   ==  null   ) ", " platformID   =  PLATFORM_MICROSOFT  ", " encodingID   =  ENCODING_UGL  ", " if (  cmapFmt   ==  null   ) ", " new RuntimeException (  STR_   )   "], ["Font font", "CmapTable cmap =  font.getCmapTable (  )   ", " if (  cmap   !=  null   ) ", " if (  forceAscii   ) ", " cmapFmt   =  cmap.getCmapFormat (  Table.platformMacintosh   ,  Table.encodingRoman   )   ", " platformID   =  PLATFORM_MACINTOSH  ", " encodingID   =  ENCODING_ROMAN  ", " if (  cmapFmt   ==  null   ) ", " new RuntimeException (  STR_   )   "], ["Font font", "CmapTable cmap =  font.getCmapTable (  )   ", " if (  cmap   !=  null   ) ", " if (  cmapFmt   ==  null   ) ", " new RuntimeException (  STR_   )   "]]
[["String genreId", "short genreVal =  Short.parseShort (  genreId   )   ", " if (  genreVal   -  NUM_   <=  GenreTypes.getMaxStandardGenreId (  )    ) ", " return  BOOL_  "], ["String genreId", "short genreVal =  Short.parseShort (  genreId   )   ", " if (  genreVal   -  NUM_   <=  GenreTypes.getMaxStandardGenreId (  )    ) ", "Integer id3GenreId =  GenreTypes.getInstanceOf (  )   . getIdForValue (  genreId   )   ", " if (  id3GenreId   !=  null   ) ", " return  BOOL_  "], ["String genreId", "short genreVal =  Short.parseShort (  genreId   )   ", " if (  genreVal   -  NUM_   <=  GenreTypes.getMaxStandardGenreId (  )    ) ", "Integer id3GenreId =  GenreTypes.getInstanceOf (  )   . getIdForValue (  genreId   )   ", " if (  id3GenreId   !=  null   ) ", " if (  id3GenreId   <=  GenreTypes.getMaxStandardGenreId (  )    ) ", " return  BOOL_  "], ["String genreId", "short genreVal =  Short.parseShort (  genreId   )   ", " if (  genreVal   -  NUM_   <=  GenreTypes.getMaxStandardGenreId (  )    ) ", "Integer id3GenreId =  GenreTypes.getInstanceOf (  )   . getIdForValue (  genreId   )   ", " if (  id3GenreId   !=  null   ) ", " if (  id3GenreId   <=  GenreTypes.getMaxStandardGenreId (  )    ) ", " return  BOOL_  "]]
[["scala.collection.Seq inputs", "List list =  JavaConversions.seqAsJavaList (  inputs   )   ", "for ( Object obj :  list   )", " if (  obj   instanceof Tuple3 ) ", "Tuple3 t3", " in (  t3._1 (  )    ,  t3._2 (  )    ,  t3._3 (  )    )   "], ["scala.collection.Seq inputs", "List list =  JavaConversions.seqAsJavaList (  inputs   )   ", "for ( Object obj :  list   )", " if (  obj   instanceof Tuple3 ) ", "Tuple3 t3", " in (  t3._1 (  )    ,  t3._2 (  )    ,  t3._3 (  )    )   ", " return    "], ["scala.collection.Seq inputs", "List list =  JavaConversions.seqAsJavaList (  inputs   )   ", "for ( Object obj :  list   )", " if (  obj   instanceof Tuple3 ) ", " if (  obj   instanceof Tuple2 ) ", "Tuple2 t2", " in (  t2._1 (  )    ,  t2._2 (  )    )   "], ["scala.collection.Seq inputs", "List list =  JavaConversions.seqAsJavaList (  inputs   )   ", "for ( Object obj :  list   )", " if (  obj   instanceof Tuple3 ) ", " if (  obj   instanceof Tuple2 ) ", "Tuple2 t2", " in (  t2._1 (  )    ,  t2._2 (  )    )   ", " return    "], ["scala.collection.Seq inputs", "List list =  JavaConversions.seqAsJavaList (  inputs   )   ", "for ( Object obj :  list   )", " if (  obj   instanceof Tuple3 ) ", " if (  obj   instanceof Tuple2 ) ", " new MLContextException (  STR_   )   "], ["scala.collection.Seq inputs", "List list =  JavaConversions.seqAsJavaList (  inputs   )   ", "for ( Object obj :  list   )", " if (  obj   instanceof Tuple3 ) ", " if (  obj   instanceof Tuple2 ) ", " new MLContextException (  STR_   )   ", " return    "]]
[[" System.setProperty (  SystemProperties.DATABASE_PROPERTIES   ,  STR_   )   ", " prepareDB (  BOOL_   )   "]]
[["InputStream inputStream", " return  new ObjectInputStream (  inputStream   )   "]]
[["String variable", "Node node =  dataSet.getVariable (  variable   )   ", " if (  node   ==  target   ) ", " if (  continuousIntervals.containsKey (  node   )    ||  discreteValues.containsKey (  node   )    ) ", " continuousIntervals.remove (  node   )   ", " discreteValues.remove (  node   )   "], ["String variable", "Node node =  dataSet.getVariable (  variable   )   ", " if (  node   ==  target   ) ", " if (  continuousIntervals.containsKey (  node   )    ||  discreteValues.containsKey (  node   )    ) ", " new IllegalArgumentException (  STR_   +  variable   )   ", " continuousIntervals.remove (  node   )   ", " discreteValues.remove (  node   )   "], ["String variable", "Node node =  dataSet.getVariable (  variable   )   ", " if (  node   ==  target   ) ", " new IllegalArgumentException (  STR_   )   ", " if (  continuousIntervals.containsKey (  node   )    ||  discreteValues.containsKey (  node   )    ) ", " continuousIntervals.remove (  node   )   ", " discreteValues.remove (  node   )   "], ["String variable", "Node node =  dataSet.getVariable (  variable   )   ", " if (  node   ==  target   ) ", " new IllegalArgumentException (  STR_   )   ", " if (  continuousIntervals.containsKey (  node   )    ||  discreteValues.containsKey (  node   )    ) ", " new IllegalArgumentException (  STR_   +  variable   )   ", " continuousIntervals.remove (  node   )   ", " discreteValues.remove (  node   )   "]]
[[" if (  fDeferredDocumentEvent   !=  null   ) ", "DocumentEvent event =  fDeferredDocumentEvent  ", " fDeferredDocumentEvent   =  null  ", " doFireDocumentChanged (  event   )   "]]
[["Message o", "  flags    . flags   =  o.flags   & ~ FLAGS_TO_CLEAR_ON_COPY_FROM  ", "  what    . what   =  o.what  ", "  arg1    . arg1   =  o.arg1  ", "  arg2    . arg2   =  o.arg2  ", "  obj    . obj   =  o.obj  ", "  replyTo    . replyTo   =  o.replyTo  ", " if (  o.data   !=  null   ) ", "  data    . data   =  null  "], ["Message o", "  flags    . flags   =  o.flags   & ~ FLAGS_TO_CLEAR_ON_COPY_FROM  ", "  what    . what   =  o.what  ", "  arg1    . arg1   =  o.arg1  ", "  arg2    . arg2   =  o.arg2  ", "  obj    . obj   =  o.obj  ", "  replyTo    . replyTo   =  o.replyTo  ", " if (  o.data   !=  null   ) ", "  data    . data   = "]]
[["Object key", " if (  arrayTable   !=  null   ) ", " arrayTable.remove (  key   )   "]]
[[" return  mFillPoints  "]]
[["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " log.warn (  STR_   )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " log.warn (  STR_   )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " _comment   =  a.getValue (  )   ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " log.warn (  STR_   )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " _name   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " log.warn (  STR_   )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " _name   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " _comment   =  a.getValue (  )   ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " _id   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " _id   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " _comment   =  a.getValue (  )   ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " _id   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " _name   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "], ["Element e", "org.jdom2.Attribute a", " if (  a   =  e.getAttribute (  Xml.ID   )    !=  null   ) ", " _id   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.NAME   )    !=  null   ) ", " _name   =  a.getValue (  )   ", " if (  a   =  e.getAttribute (  Xml.COMMENT   )    !=  null   ) ", " _comment   =  a.getValue (  )   ", " if (  e.getChildren (  Xml.ITEM   )    !=  null   ) ", "List eScheduleItems =  e.getChildren (  Xml.ITEM   )   ", " log.debug (  STR_   ,  getName (  )    ,  eScheduleItems.size (  )    )   ", "for ( Element eScheduleItem :  eScheduleItems   )", " register (  new ScheduleItem (  eScheduleItem   )    )   "]]
[["BasicTicket t , int columns", " basict   =  t  ", " desktophints   = ", "  columns    . columns   =  columns  ", "  linewidth    . linewidth   =  columns   *  NUM_  ", " initComponents (  )   "]]
[["TypeDecl type =  getExpr (  )   . type (  )   ", " if ( ! type.isIntegralType (  )    ||  type.isLong (  )    && ! type.isEnumDecl (  )    && ! type.isString (  )    ) ", " error (  STR_   +  STR_   )   "]]
[["K k1 , V v1 , K k2 , V v2", " return  ofEntries (  entryOf (  k1   ,  v1   )    ,  entryOf (  k2   ,  v2   )    )   "]]
[[" return ! mDecoderList.isSelectionEmpty (  )   "]]
[["byte afm , byte pfb , boolean cached", " return  createType1Font (  null   ,  null   ,  afm   ,  pfb   ,  cached   )   "]]
[["String value , boolean stopAtNonOption", " if (  stopAtNonOption   &&  currentOption   ==  null   || ! currentOption.hasArg (  )    ) ", " eatTheRest   =  BOOL_  ", " tokens.add (  STR_   )   ", " tokens.add (  value   )   ", " currentOption   =  null  "], ["String value , boolean stopAtNonOption", " if (  stopAtNonOption   &&  currentOption   ==  null   || ! currentOption.hasArg (  )    ) ", " tokens.add (  value   )   ", " currentOption   =  null  "]]
[["Object value , String defaultValue", "double res =  toDoubleValue (  value   ,  BOOL_   ,  Double.NaN   )   ", " if (  Double.isNaN (  res   )    ) ", " return  defaultValue  "], ["Object value , String defaultValue", "double res =  toDoubleValue (  value   ,  BOOL_   ,  Double.NaN   )   ", " if (  Double.isNaN (  res   )    ) ", " return  toDecimal (  res   )   "]]
[["String qlName", "for ( QueryLanguage ql :  QUERY_LANGUAGES   )", " if (  ql.getName (  )   . equalsIgnoreCase (  qlName   )    ) ", " return  null  "], ["String qlName", "for ( QueryLanguage ql :  QUERY_LANGUAGES   )", " if (  ql.getName (  )   . equalsIgnoreCase (  qlName   )    ) "], ["String qlName", "for ( QueryLanguage ql :  QUERY_LANGUAGES   )", " if (  ql.getName (  )   . equalsIgnoreCase (  qlName   )    ) ", " return  ql  "]]
[["Object o", " if (     ==  o   ) ", " if (  o   ==  null   ) ", " return  BOOL_  "], ["Object o", " if (     ==  o   ) ", " if (  o   ==  null   ) ", " if (  o   instanceof Entry ) ", "Entry e", " return  dn.equals (  e.dn   )    &&  objectClasses.keySet (  )   . equals (  e.objectClasses.keySet (  )    )    &&  equals (  userAttributes   ,  e.userAttributes   )    &&  equals (  operationalAttributes   ,  e.operationalAttributes   )   "], ["Object o", " if (     ==  o   ) ", " if (  o   ==  null   ) ", " if (  o   instanceof Entry ) ", " return  BOOL_  "], ["Object o", " if (     ==  o   ) ", " return  BOOL_  "]]
[["int id , double balance", "   "]]
[["int goalNT", " return  delegate.rule (  goalNT   )   "]]
[["long bucketOrd , int inc", " docCounts   =  bigArrays.grow (  docCounts   ,  bucketOrd   +  NUM_   )   ", " docCounts.increment (  bucketOrd   ,  inc   )   "]]
[[" if (  applicationContext   !=  null   ) ", " if (  logger.isDebugEnabled (  )    ) ", " applicationContext.setParent (  null   )   ", " applicationContext.close (  )   "], [" if (  applicationContext   !=  null   ) ", " if (  logger.isDebugEnabled (  )    ) ", " logger.debug (  STR_   +  location   +  STR_   )   ", " applicationContext.setParent (  null   )   ", " applicationContext.close (  )   "]]
[["int index", " internal.deleteCharAt (  index   )   ", " return    "]]
[[" return  STR_   +  STR_   +  getTechnicalInformation (  )   . toString (  )   "]]
[["MemoryCommitResult mcr , Runnable postWriteRunnable"]]
[[" if (  mFindToolbar   ==  null   ) ", " return "], [" if (  mFindToolbar   ==  null   ) ", " mFindToolbar.deactivate (  )   "]]
[["StepMetaInterface smi , StepDataInterface sdi", " meta   = ", " data   = ", "   "]]
[[" oredCriteria.clear (  )   ", " orderByClause   =  null  ", " distinct   =  BOOL_  "]]
[["ImageSharingListener listener", " if (  mApi   ==  null   ) ", " new RcsServiceNotAvailableException (  )   ", "WeakReference weakRef =  mImageSharingListeners.remove (  listener   )   ", " if (  weakRef   ==  null   ) ", " return "], ["ImageSharingListener listener", " if (  mApi   ==  null   ) ", " new RcsServiceNotAvailableException (  )   ", "WeakReference weakRef =  mImageSharingListeners.remove (  listener   )   ", " if (  weakRef   ==  null   ) ", "IImageSharingListener rcsListener =  weakRef.get (  )   ", " if (  rcsListener   !=  null   ) ", " mApi.removeEventListener2 (  rcsListener   )   "], ["ImageSharingListener listener", " if (  mApi   ==  null   ) ", "WeakReference weakRef =  mImageSharingListeners.remove (  listener   )   ", " if (  weakRef   ==  null   ) ", " return "], ["ImageSharingListener listener", " if (  mApi   ==  null   ) ", "WeakReference weakRef =  mImageSharingListeners.remove (  listener   )   ", " if (  weakRef   ==  null   ) ", "IImageSharingListener rcsListener =  weakRef.get (  )   ", " if (  rcsListener   !=  null   ) ", " mApi.removeEventListener2 (  rcsListener   )   "]]
[["DoubleMatrix2D A , double s", " return  A.assign (  F.div (  s   )    )   "]]
[["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  curlyOpen ++  ==  NUM_   ) ", " leftmost   =  i  ", " return - NUM_  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  curlyOpen ++  ==  NUM_   ) ", " leftmost   =  i  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  curlyOpen ++  ==  NUM_   ) ", " return - NUM_  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  curlyOpen ++  ==  NUM_   ) "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " if ( -- curlyOpen   ==  NUM_   &&  leftmost   != - NUM_   &&  seenSlash   ) ", " return  leftmost  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " if ( -- curlyOpen   ==  NUM_   &&  leftmost   != - NUM_   &&  seenSlash   ) ", " return - NUM_  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " if ( -- curlyOpen   ==  NUM_   &&  leftmost   != - NUM_   &&  seenSlash   ) "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " return - NUM_  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " seenSlash   =  BOOL_  ", " return - NUM_  "], ["String filePattern , int offset", "int curlyOpen =  NUM_  ", "int leftmost = - NUM_  ", "boolean seenSlash =  BOOL_  ", "for (  ;  i   <  filePattern.length (  )    ;  i ++  ) ", "char c =  filePattern.charAt (  i   )   ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " if (  c   ==  STR_   &&  curlyOpen   >  NUM_   ) ", " seenSlash   =  BOOL_  "]]
[["cn.nukkit.command.PluginCommand nukkitCommand", "Plugin bukkitPlugin =  PokkitPlugin.toBukkit (  nukkitCommand.getPlugin (  )    )   ", "Constructor constructor =  PluginCommand  getDeclaredConstructor (  String    ,  Plugin    )     . getDeclaredConstructor (  String    ,  Plugin    )   ", " constructor.setAccessible (  BOOL_   )   ", "PluginCommand bukkitCommand =  constructor.newInstance (  nukkitCommand.getName (  )    ,  bukkitPlugin   )   ", " bukkitCommand.setAliases (  Arrays.asList (  nukkitCommand.getAliases (  )    )    )   ", " bukkitCommand.setDescription (  nukkitCommand.getDescription (  )    )   ", " bukkitCommand.setLabel (  nukkitCommand.getLabel (  )    )   ", " bukkitCommand.setPermission (  nukkitCommand.getPermission (  )    )   ", " bukkitCommand.setPermissionMessage (  nukkitCommand.getPermissionMessage (  )    )   ", " bukkitCommand.setUsage (  nukkitCommand.getUsage (  )    )   ", " return  bukkitCommand  "]]
[["ImmutableList.Builder resultBuilder =  ImmutableList.builder (  )   ", "String line", "boolean wasLastLineEmpty =  BOOL_  ", "while (  BOOL_   )", " line   =  bufferedReader.readLine (  )   ", " if (  Strings.isNullOrEmpty (  line   )    ) ", " if (  wasLastLineEmpty   ) ", " wasLastLineEmpty   =  BOOL_  ", "StringBuilder stringBuilder =  new StringBuilder (  )   ", "while ( ! Strings.isNullOrEmpty (  line   )    )", " stringBuilder.append (  line   )   ", " line   =  bufferedReader.readLine (  )   ", " wasLastLineEmpty   =  BOOL_  ", "DynamicMessage.Builder nextMessage =  DynamicMessage.newBuilder (  descriptor   )   ", " jsonParser.merge (  stringBuilder.toString (  )    ,  nextMessage   )   ", " resultBuilder.add (  nextMessage.build (  )    )   "], ["ImmutableList.Builder resultBuilder =  ImmutableList.builder (  )   ", "String line", "boolean wasLastLineEmpty =  BOOL_  ", "while (  BOOL_   )", " line   =  bufferedReader.readLine (  )   ", " if (  Strings.isNullOrEmpty (  line   )    ) ", " if (  wasLastLineEmpty   ) ", " wasLastLineEmpty   =  BOOL_  ", "StringBuilder stringBuilder =  new StringBuilder (  )   ", "while ( ! Strings.isNullOrEmpty (  line   )    )", " stringBuilder.append (  line   )   ", " line   =  bufferedReader.readLine (  )   "], ["ImmutableList.Builder resultBuilder =  ImmutableList.builder (  )   ", "String line", "boolean wasLastLineEmpty =  BOOL_  ", "while (  BOOL_   )", " line   =  bufferedReader.readLine (  )   ", " if (  Strings.isNullOrEmpty (  line   )    ) ", " if (  wasLastLineEmpty   ) ", " return  resultBuilder.build (  )   "], ["ImmutableList.Builder resultBuilder =  ImmutableList.builder (  )   ", "String line", "boolean wasLastLineEmpty =  BOOL_  ", "while (  BOOL_   )", " line   =  bufferedReader.readLine (  )   ", " if (  Strings.isNullOrEmpty (  line   )    ) ", " wasLastLineEmpty   =  BOOL_  ", "StringBuilder stringBuilder =  new StringBuilder (  )   ", "while ( ! Strings.isNullOrEmpty (  line   )    )", " stringBuilder.append (  line   )   ", " line   =  bufferedReader.readLine (  )   ", " wasLastLineEmpty   =  BOOL_  ", "DynamicMessage.Builder nextMessage =  DynamicMessage.newBuilder (  descriptor   )   ", " jsonParser.merge (  stringBuilder.toString (  )    ,  nextMessage   )   ", " resultBuilder.add (  nextMessage.build (  )    )   "], ["ImmutableList.Builder resultBuilder =  ImmutableList.builder (  )   ", "String line", "boolean wasLastLineEmpty =  BOOL_  ", "while (  BOOL_   )", " line   =  bufferedReader.readLine (  )   ", " if (  Strings.isNullOrEmpty (  line   )    ) ", " wasLastLineEmpty   =  BOOL_  ", "StringBuilder stringBuilder =  new StringBuilder (  )   ", "while ( ! Strings.isNullOrEmpty (  line   )    )", " stringBuilder.append (  line   )   ", " line   =  bufferedReader.readLine (  )   "]]
[["long ulong =   readULong (  )     . readULong (  )   ", " if (  ulong   &  NUM_   ==  NUM_   ) ", " return  & ~ NUM_  "], ["long ulong =   readULong (  )     . readULong (  )   ", " if (  ulong   &  NUM_   ==  NUM_   ) ", " new ArithmeticException (  STR_   )   ", " return  & ~ NUM_  "]]
[["Graphics a , JComponent b", "for (  ;  i   <  uis.size (  )    ;  i ++  ) "]]
[]
[["File file , long length", " if (  file   ==  null   ||  length   <=  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " fChannel.write (  ByteBuffer.allocate (  NUM_   )    ,  length   -  NUM_   )   "], ["File file , long length", " if (  file   ==  null   ||  length   <=  NUM_   ) ", " fChannel.write (  ByteBuffer.allocate (  NUM_   )    ,  length   -  NUM_   )   "]]
[["ISVNRemoteFolder parent , String folderName , String message , IProgressMonitor monitor", " parent.createRemoteFolder (  folderName   ,  message   ,  monitor   )   "]]
[["String supportedSuites", "for ( String suites :  supportedSuites   )", " if (  KERBEROS_CIPHER_SUITES.contains (  suites   )    ) "], ["String supportedSuites", "for ( String suites :  supportedSuites   )", " if (  KERBEROS_CIPHER_SUITES.contains (  suites   )    ) ", " new RuntimeException (  STR_   +  STR_   )   "]]
[["   ", " dotRect   =  new Rectangle2D.Float (  NUM_   ,  NUM_   ,  NUM_   ,  NUM_   )   "]]
[["String message", " if (  myHost   !=  null   ) ", " System.out.println (  message   )   "], ["String message", " if (  myHost   !=  null   ) ", " myHost.showFeedback (  message   )   "]]
[["Context context , Writer out , String logTag , String instring", " return  evaluate (  context   ,  out   ,  logTag   ,  new BufferedReader (  new StringReader (  instring   )    )    )   "]]
[["Warrant w", "String msg =  null  ", " if (  w.getRunMode (  )    !=  Warrant.MODE_NONE   ) ", " msg   =  w.getRunModeMessage (  )   ", " setStatusText (  msg   ,  Color.red   ,  BOOL_   )   ", " return  msg  "], ["Warrant w", "String msg =  null  ", " if (  w.getRunMode (  )    !=  Warrant.MODE_NONE   ) ", " msg   =  w.setRoute (  NUM_   ,  null   )   ", " setStatusText (  msg   ,  WarrantTableModel.myGold   ,  BOOL_   )   ", " if (  msg   !=  null   ) ", " msg   =  w.setRunMode (  Warrant.MODE_RUN   ,  null   ,  null   ,  null   ,  w.getRunBlind (  )    )   ", " if (  msg   !=  null   ) ", " msg   =  w.checkStartBlock (  Warrant.MODE_RUN   )   ", " setStatusText (  msg   ,  WarrantTableModel.myGold   ,  BOOL_   )   ", " msg   =  w.checkRoute (  )   ", " if (  msg   !=  null   ) ", " setStatusText (  msg   ,  WarrantTableModel.myGreen   ,  BOOL_   )   ", " return  null  "], ["Warrant w", "String msg =  null  ", " if (  w.getRunMode (  )    !=  Warrant.MODE_NONE   ) ", " msg   =  w.setRoute (  NUM_   ,  null   )   ", " setStatusText (  msg   ,  WarrantTableModel.myGold   ,  BOOL_   )   ", " if (  msg   !=  null   ) ", " msg   =  w.setRunMode (  Warrant.MODE_RUN   ,  null   ,  null   ,  null   ,  w.getRunBlind (  )    )   ", " if (  msg   !=  null   ) ", " msg   =  w.checkStartBlock (  Warrant.MODE_RUN   )   ", " setStatusText (  msg   ,  WarrantTableModel.myGold   ,  BOOL_   )   ", " msg   =  w.checkRoute (  )   ", " if (  msg   !=  null   ) ", " return  null  "], ["Warrant w", "String msg =  null  ", " if (  w.getRunMode (  )    !=  Warrant.MODE_NONE   ) ", " msg   =  w.setRoute (  NUM_   ,  null   )   ", " setStatusText (  msg   ,  WarrantTableModel.myGold   ,  BOOL_   )   ", " if (  msg   !=  null   ) ", " msg   =  w.setRunMode (  Warrant.MODE_RUN   ,  null   ,  null   ,  null   ,  w.getRunBlind (  )    )   ", " if (  msg   !=  null   ) ", " setStatusText (  msg   ,  Color.red   ,  BOOL_   )   ", " return  msg  "], ["Warrant w", "String msg =  null  ", " if (  w.getRunMode (  )    !=  Warrant.MODE_NONE   ) ", " msg   =  w.setRoute (  NUM_   ,  null   )   ", " setStatusText (  msg   ,  WarrantTableModel.myGold   ,  BOOL_   )   ", " if (  msg   !=  null   ) ", " setStatusText (  msg   ,  Color.red   ,  BOOL_   )   ", " return  msg  "]]
[["ColorStateList tint , PorterDuff.Mode tintMode , int drawableState", " if (  tint   ==  null   ||  tintMode   ==  null   ) ", "int color =  tint.getColorForState (  drawableState   ,  Color.TRANSPARENT   )   ", "PorterDuffColorFilter filter =  COLOR_FILTER_CACHE.get (  color   ,  tintMode   )   ", " if (  filter   ==  null   ) ", " filter   =  new PorterDuffColorFilter (  color   ,  tintMode   )   ", " COLOR_FILTER_CACHE.put (  color   ,  tintMode   ,  filter   )   ", " return  filter  "], ["ColorStateList tint , PorterDuff.Mode tintMode , int drawableState", " if (  tint   ==  null   ||  tintMode   ==  null   ) ", "int color =  tint.getColorForState (  drawableState   ,  Color.TRANSPARENT   )   ", "PorterDuffColorFilter filter =  COLOR_FILTER_CACHE.get (  color   ,  tintMode   )   ", " if (  filter   ==  null   ) ", " return  filter  "], ["ColorStateList tint , PorterDuff.Mode tintMode , int drawableState", " if (  tint   ==  null   ||  tintMode   ==  null   ) ", " return  null  "]]
[["boolean done", " close (  )   ", " if (  thematicIndex   !=  null   ) ", " return  BOOL_  "], ["boolean done", " close (  )   ", " if (  thematicIndex   !=  null   ) ", " thematicIndex.close (  )   ", " return  BOOL_  "]]
[["for (  ;  i   >=  NUM_   ;  i --  ) ", "CdmaConnection cn", " if (  cn.getState (  )    ==  State.DISCONNECTED   ) "], ["for (  ;  i   >=  NUM_   ;  i --  ) ", "CdmaConnection cn", " if (  cn.getState (  )    ==  State.DISCONNECTED   ) ", " if (  connections.size (  )    ==  NUM_   ) ", " state   =  State.IDLE  "], ["for (  ;  i   >=  NUM_   ;  i --  ) ", "CdmaConnection cn", " if (  cn.getState (  )    ==  State.DISCONNECTED   ) ", " connections.remove (  i   )   "], ["for (  ;  i   >=  NUM_   ;  i --  ) ", "CdmaConnection cn", " if (  cn.getState (  )    ==  State.DISCONNECTED   ) ", " connections.remove (  i   )   ", " if (  connections.size (  )    ==  NUM_   ) ", " state   =  State.IDLE  "]]
[["String localName , String value", " if (  _currentEle.getState (  )    !=  ELEMENT_STARTTAG_OPEN   ) ", " new XMLStreamException (  STR_   )   ", " _writer.write (  SPACE   )   ", " _writer.write (  localName   )   ", " _writer.write (  STR_   )   ", " writeXMLContent (  value   ,  BOOL_   ,  BOOL_   )   ", " _writer.write (  DOUBLEQUOT   )   "], ["String localName , String value", " if (  _currentEle.getState (  )    !=  ELEMENT_STARTTAG_OPEN   ) ", " _writer.write (  SPACE   )   ", " _writer.write (  localName   )   ", " _writer.write (  STR_   )   ", " writeXMLContent (  value   ,  BOOL_   ,  BOOL_   )   ", " _writer.write (  DOUBLEQUOT   )   "]]
[[" return  fetch (  SortOrder.UNSPECIFIED   )   "]]
[["int reason , EObject obj , int featureId , String detail", " issues.add (  new TransformationIssue (  reason   ,  obj   ,  featureId   ,  detail   )    )   "]]
[["View view", "DomainConfig instance =  new DomainConfig (  )   ", " saveProperties (  instance   )   ", "Spinner spin", " instance.creationMode   = ", "HttpAction action =  new HttpCreateAction (     ,  instance   )   ", " action.execute (  )   "]]
[["Which state", "   ", "  ctx    . ctx   =  new PaintContext (  CacheMode.FIXED_SIZES   )   ", " switch (  state   ) ", " case BACKGROUND_SELECTED_FOCUSED , BACKGROUND_PRESSED_SELECTED_FOCUSED", " focused   =  BOOL_  ", " type   =  getButtonType (  state   )   "], ["Which state", "   ", "  ctx    . ctx   =  new PaintContext (  CacheMode.FIXED_SIZES   )   ", " switch (  state   ) ", " case ", " focused   =  BOOL_  ", " type   =  getButtonType (  state   )   "]]
[["int measureSpec", "int result", "int specMode =  MeasureSpec.getMode (  measureSpec   )   ", "int specSize =  MeasureSpec.getSize (  measureSpec   )   ", " if (  specMode   ==  MeasureSpec.EXACTLY   ) ", " result   = ", " if (  specMode   ==  MeasureSpec.AT_MOST   ) ", " return  result  "], ["int measureSpec", "int result", "int specMode =  MeasureSpec.getMode (  measureSpec   )   ", "int specSize =  MeasureSpec.getSize (  measureSpec   )   ", " if (  specMode   ==  MeasureSpec.EXACTLY   ) ", " result   = ", " if (  specMode   ==  MeasureSpec.AT_MOST   ) ", " result   =  Math.min (  result   ,  specSize   )   ", " return  result  "], ["int measureSpec", "int result", "int specMode =  MeasureSpec.getMode (  measureSpec   )   ", "int specSize =  MeasureSpec.getSize (  measureSpec   )   ", " if (  specMode   ==  MeasureSpec.EXACTLY   ) ", " result   =  specSize  ", " return  result  "]]
[["   "]]
[["int length =  features.get (  NUM_   )   . length  ", "Cluster cluster", "double mean", "for (  ;  i   <  clusters.length   ;  i ++  ) ", " cluster   =  clusters   [  i   ]", " if (  cluster.getSize (  )    ==  NUM_   ) ", " System.err.println (  STR_   +  i   )   ", " cluster.move (  )   "], ["int length =  features.get (  NUM_   )   . length  ", "Cluster cluster", "double mean", "for (  ;  i   <  clusters.length   ;  i ++  ) ", " cluster   =  clusters   [  i   ]", " if (  cluster.getSize (  )    ==  NUM_   ) ", " if (  cluster.getSize (  )    <  NUM_   ) ", " cluster.move (  )   "], ["int length =  features.get (  NUM_   )   . length  ", "Cluster cluster", "double mean", "for (  ;  i   <  clusters.length   ;  i ++  ) ", " cluster   =  clusters   [  i   ]", " if (  cluster.getSize (  )    ==  NUM_   ) ", " if (  cluster.getSize (  )    <  NUM_   ) ", " System.err.println (  STR_   +  i   )   ", "int index", " clusters   [  i   ]. assignMember (  features.get (  index   )    )   ", " cluster.move (  )   "]]
[["short flags", " return  isCompactFooter (  flags   )   ? NUM_  : FIELD_ID_LEN  "]]
[[" if (  caretBlinks   ) ", " blink   = ! blink  ", " painter.invalidateSelectedLines (  )   "], [" if (  caretBlinks   ) ", " blink   =  BOOL_  "]]
[[" if (  server   ==  null   ) ", " IoUtil.delete (   logsDir    . logsDir   )   "]]
[[" commandManager.setEnableCritical (  BOOL_   )   ", " locked   =  BOOL_  "]]
[["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_NO_SUCH_BACKUP.get (  backupID   ,  path   )    )   ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_NO_SUCH_BACKUP.get (  backupID   ,  path   )    )   ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_UNRESOLVED_DEPENDENCY.get (  backupID   ,  path   ,  backup.getBackupID (  )    )    )   ", " backups.remove (  backupID   )   "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_NO_SUCH_BACKUP.get (  backupID   ,  path   )    )   ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_UNRESOLVED_DEPENDENCY.get (  backupID   ,  path   ,  backup.getBackupID (  )    )    )   "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_NO_SUCH_BACKUP.get (  backupID   ,  path   )    )   ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) ", " backups.remove (  backupID   )   "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_UNRESOLVED_DEPENDENCY.get (  backupID   ,  path   ,  backup.getBackupID (  )    )    )   ", " backups.remove (  backupID   )   "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) ", " new ConfigException (  ERR_BACKUPDIRECTORY_UNRESOLVED_DEPENDENCY.get (  backupID   ,  path   ,  backup.getBackupID (  )    )    )   "], ["String backupID", " if ( ! backups.containsKey (  backupID   )    ) ", "for ( BackupInfo backup :  backups.values (  )    )", " if (  backup.dependsOn (  backupID   )    ) ", " backups.remove (  backupID   )   "]]
[["Sensor s , int i", " if (  i   <  NUM_   ||  i   >=  mNumInputBits   ) ", " log.error (  STR_   +  Integer.toString (  i   +  NUM_   )    )   ", " return "], ["Sensor s , int i", " if (  i   <  NUM_   ||  i   >=  mNumInputBits   ) ", " if (  sensorArray   [  i   ] ==  null   ) ", " log.warn (  STR_   +  Integer.toString (  i   +  NUM_   )    )   "], ["Sensor s , int i", " if (  i   <  NUM_   ||  i   >=  mNumInputBits   ) ", " if (  sensorArray   [  i   ] ==  null   ) ", " sensorArray   [  i   ] =  s  ", " if (  lastUsedSensor   <  i   ) ", " sensorLastSetting   [  i   ] =  Sensor.UNKNOWN  ", " sensorTempSetting   [  i   ] =  Sensor.UNKNOWN  ", " sensorORedSetting   [  i   ] =  BOOL_  "], ["Sensor s , int i", " if (  i   <  NUM_   ||  i   >=  mNumInputBits   ) ", " if (  sensorArray   [  i   ] ==  null   ) ", " sensorArray   [  i   ] =  s  ", " if (  lastUsedSensor   <  i   ) ", " lastUsedSensor   =  i  ", " sensorLastSetting   [  i   ] =  Sensor.UNKNOWN  ", " sensorTempSetting   [  i   ] =  Sensor.UNKNOWN  ", " sensorORedSetting   [  i   ] =  BOOL_  "]]
[["int dataType , int w , int h , int pixelStride , int scanlineStride , int bandOffsets", "   ", "int minBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "int maxBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "for (  ;  i   <   bandOffsets   ,  length    . bandOffsets  . length   ;  i ++  ) ", " minBandOff   =  Math.min (  minBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   =  Math.max (  maxBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   -=  minBandOff  ", " if (  maxBandOff   >  scanlineStride   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   )   ", " if (  pixelStride   *  w   >  scanlineStride   ) ", " if (  pixelStride   <  maxBandOff   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   )   "], ["int dataType , int w , int h , int pixelStride , int scanlineStride , int bandOffsets", "   ", "int minBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "int maxBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "for (  ;  i   <   bandOffsets   ,  length    . bandOffsets  . length   ;  i ++  ) ", " minBandOff   =  Math.min (  minBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   =  Math.max (  maxBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   -=  minBandOff  ", " if (  maxBandOff   >  scanlineStride   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   )   ", " if (  pixelStride   *  w   >  scanlineStride   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   +  STR_   )   ", " if (  pixelStride   <  maxBandOff   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   )   "], ["int dataType , int w , int h , int pixelStride , int scanlineStride , int bandOffsets", "   ", "int minBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "int maxBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "for (  ;  i   <   bandOffsets   ,  length    . bandOffsets  . length   ;  i ++  ) ", " minBandOff   =  Math.min (  minBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   =  Math.max (  maxBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   -=  minBandOff  ", " if (  maxBandOff   >  scanlineStride   ) ", " if (  pixelStride   *  w   >  scanlineStride   ) ", " if (  pixelStride   <  maxBandOff   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   )   "], ["int dataType , int w , int h , int pixelStride , int scanlineStride , int bandOffsets", "   ", "int minBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "int maxBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "for (  ;  i   <   bandOffsets   ,  length    . bandOffsets  . length   ;  i ++  ) ", " minBandOff   =  Math.min (  minBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   =  Math.max (  maxBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   -=  minBandOff  ", " if (  maxBandOff   >  scanlineStride   ) ", " if (  pixelStride   *  w   >  scanlineStride   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   +  STR_   )   ", " if (  pixelStride   <  maxBandOff   ) ", " new IllegalArgumentException (  STR_   +  STR_   +  STR_   )   "], ["int dataType , int w , int h , int pixelStride , int scanlineStride , int bandOffsets", "   ", "int minBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "int maxBandOff =   bandOffsets   , [  NUM_   ]  . bandOffsets   [  NUM_   ]", "for (  ;  i   <   bandOffsets   ,  length    . bandOffsets  . length   ;  i ++  ) ", " minBandOff   =  Math.min (  minBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   ", " maxBandOff   =  Math.max (  maxBandOff   ,   bandOffsets   , [  i   ]  . bandOffsets   [  i   ] )   "]]
[["List list , OutputStream out", "Writer writer =  makeWriter (  out   )   ", " output (  list   ,  writer   )   "]]
[["   ", " H0   =  NUM_  ", " H1   =  NUM_  ", " H2   =  NUM_  ", " H3   =  NUM_  ", " H4   =  NUM_  ", " H5   =  NUM_  ", " H6   =  NUM_  ", " H7   =  NUM_  ", " xOff   =  NUM_  ", "for (  ;  i   !=  X.length   ;  i ++  ) ", " X   [  i   ] =  NUM_  "]]
[[" return  new com.sun.identity.liberty.ws.common.jaxb.secext.impl.UsernameTokenElementImpl (  )   "]]
[]
[["String columnName , TimeZone timeZone", " return  addColumnTime (  columnName   ,  DateTimeZone.forTimeZone (  timeZone   )    )   "]]
[["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " search   =  BOOL_  "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " search   =  BOOL_  ", " if ( ! search   ) ", " remVars.add (  node1   )   ", "  variables   ,  removeAll (  remVars   )     . variables  . removeAll (  remVars   )   "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " search   =  BOOL_  ", " if ( ! search   ) ", " remVars.add (  node1   )   "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " search   =  BOOL_  ", " if ( ! search   ) "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " search   =  BOOL_  ", " if ( ! search   ) ", "  variables   ,  removeAll (  remVars   )     . variables  . removeAll (  remVars   )   "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " if ( ! search   ) ", " remVars.add (  node1   )   ", "  variables   ,  removeAll (  remVars   )     . variables  . removeAll (  remVars   )   "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " if ( ! search   ) ", " remVars.add (  node1   )   "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " if ( ! search   ) "], ["IndependenceTest independenceTest , List searchVars", " if (  independenceTest   ==  null   ||  knowledge   ==  null   ) ", " new NullPointerException (  )   ", "  independenceTest    . independenceTest   =  independenceTest  ", "  variables   ,  addAll (  independenceTest.getVariables (  )    )     . variables  . addAll (  independenceTest.getVariables (  )    )   ", "Set remVars =  new HashSet (  )   ", "for ( Node node1 :   variables    . variables   )", "boolean search =  BOOL_  ", "for ( Node node2 :  searchVars   )", " if (  node1.getName (  )   . equals (  node2.getName (  )    )    ) ", " if ( ! search   ) ", "  variables   ,  removeAll (  remVars   )     . variables  . removeAll (  remVars   )   "]]
[["byte utf8 , int offset , int len , CharArr out", " out.reserve (  len   )   ", "int n =  UTF8toUTF16 (  utf8   ,  offset   ,  len   ,  out.getArray (  )    ,  out.getEnd (  )    )   ", " out.setEnd (  out.getEnd (  )    +  n   )   "]]
[["String hashcode , Element element", " addElementToRegistry (  hashcode   ,  element   )   ", " return    "]]
[["String name", " System.setProperty (  getKey (  )    ,  name   )   "]]
[["List initiatorURIs , ExportGroup exportGroup , Workflow workflow , Map volumeMap , StorageSystem storage , String token , String previousStep", "List newSteps =  new ArrayList (  )   ", " if ( ! initiatorURIs.isEmpty (  )    ) ", "Map computeResourceToInitiators =  mapInitiatorsToComputeResource (  exportGroup   ,  initiatorURIs   )   ", "for ( Map.Entry resourceEntry :  computeResourceToInitiators.entrySet (  )    )", "String computeKey =  resourceEntry.getKey (  )   ", "List computeInitiatorURIs =  resourceEntry.getValue (  )   ", " _log.info (  String.format (  STR_   ,  computeKey   )    )   ", "GenExportMaskCreateWorkflowResult result =  generateDeviceSpecificExportMaskCreateWorkFlow (  workflow   ,  previousStep   ,  storage   ,  exportGroup   ,  computeInitiatorURIs   ,  volumeMap   ,  token   )   ", " previousStep   =  result.getStepId (  )   ", " newSteps.add (  previousStep   )   ", " return  newSteps  "], ["List initiatorURIs , ExportGroup exportGroup , Workflow workflow , Map volumeMap , StorageSystem storage , String token , String previousStep", "List newSteps =  new ArrayList (  )   ", " if ( ! initiatorURIs.isEmpty (  )    ) ", "Map computeResourceToInitiators =  mapInitiatorsToComputeResource (  exportGroup   ,  initiatorURIs   )   ", "for ( Map.Entry resourceEntry :  computeResourceToInitiators.entrySet (  )    )", "String computeKey =  resourceEntry.getKey (  )   ", "List computeInitiatorURIs =  resourceEntry.getValue (  )   ", " _log.info (  String.format (  STR_   ,  computeKey   )    )   ", "GenExportMaskCreateWorkflowResult result =  generateDeviceSpecificExportMaskCreateWorkFlow (  workflow   ,  previousStep   ,  storage   ,  exportGroup   ,  computeInitiatorURIs   ,  volumeMap   ,  token   )   ", " previousStep   =  result.getStepId (  )   "], ["List initiatorURIs , ExportGroup exportGroup , Workflow workflow , Map volumeMap , StorageSystem storage , String token , String previousStep", "List newSteps =  new ArrayList (  )   ", " if ( ! initiatorURIs.isEmpty (  )    ) ", " newSteps.add (  previousStep   )   ", " return  newSteps  "]]
[["OsmElement mergeInto , OsmElement mergeFrom", "ArrayList fromRelations =  mergeFrom.getParentRelations (  )    !=  null  ? new ArrayList (  mergeFrom.getParentRelations (  )    )   : new ArrayList (  )   ", "ArrayList toRelations =  mergeInto.getParentRelations (  )    !=  null  ? mergeInto.getParentRelations (  )   : new ArrayList (  )   ", "for ( Relation r :  fromRelations   )", " if ( ! toRelations.contains (  r   )    ) "], ["OsmElement mergeInto , OsmElement mergeFrom", "ArrayList fromRelations =  mergeFrom.getParentRelations (  )    !=  null  ? new ArrayList (  mergeFrom.getParentRelations (  )    )   : new ArrayList (  )   ", "ArrayList toRelations =  mergeInto.getParentRelations (  )    !=  null  ? mergeInto.getParentRelations (  )   : new ArrayList (  )   ", "for ( Relation r :  fromRelations   )", " if ( ! toRelations.contains (  r   )    ) ", " recordImagery (  )   "], ["OsmElement mergeInto , OsmElement mergeFrom", "ArrayList fromRelations =  mergeFrom.getParentRelations (  )    !=  null  ? new ArrayList (  mergeFrom.getParentRelations (  )    )   : new ArrayList (  )   ", "ArrayList toRelations =  mergeInto.getParentRelations (  )    !=  null  ? mergeInto.getParentRelations (  )   : new ArrayList (  )   ", "for ( Relation r :  fromRelations   )", " if ( ! toRelations.contains (  r   )    ) ", " dirty   =  BOOL_  ", " undo.save (  r   )   ", "RelationMember rm =  r.getMember (  mergeFrom   )   ", "RelationMember newRm =  new RelationMember (  rm.getRole (  )    ,  mergeInto   )   ", " r.replaceMember (  rm   ,  newRm   )   ", " r.updateState (  OsmElement.STATE_MODIFIED   )   ", " apiStorage.insertElementSafe (  r   )   ", " mergeInto.addParentRelation (  r   )   ", " mergeInto.updateState (  OsmElement.STATE_MODIFIED   )   ", " apiStorage.insertElementSafe (  mergeInto   )   "], ["OsmElement mergeInto , OsmElement mergeFrom", "ArrayList fromRelations =  mergeFrom.getParentRelations (  )    !=  null  ? new ArrayList (  mergeFrom.getParentRelations (  )    )   : new ArrayList (  )   ", "ArrayList toRelations =  mergeInto.getParentRelations (  )    !=  null  ? mergeInto.getParentRelations (  )   : new ArrayList (  )   ", "for ( Relation r :  fromRelations   )", " if ( ! toRelations.contains (  r   )    ) ", " dirty   =  BOOL_  ", " undo.save (  r   )   ", "RelationMember rm =  r.getMember (  mergeFrom   )   ", "RelationMember newRm =  new RelationMember (  rm.getRole (  )    ,  mergeInto   )   ", " r.replaceMember (  rm   ,  newRm   )   ", " r.updateState (  OsmElement.STATE_MODIFIED   )   ", " apiStorage.insertElementSafe (  r   )   ", " mergeInto.addParentRelation (  r   )   ", " mergeInto.updateState (  OsmElement.STATE_MODIFIED   )   ", " apiStorage.insertElementSafe (  mergeInto   )   ", " recordImagery (  )   "]]
[["PropertyChangeListener listener", "   "]]
[["HGSearchResult result", "List outputList =  new ArrayList (  )   ", "while (  result.hasNext (  )    )", "T currentValue =  result.next (  )   ", " outputList.add (  currentValue   )   ", " return  outputList  "], ["HGSearchResult result", "List outputList =  new ArrayList (  )   ", "while (  result.hasNext (  )    )", "T currentValue =  result.next (  )   ", " outputList.add (  currentValue   )   "]]
[["FieldODEStateInterpolator interpolator", " forward   =  interpolator.isForward (  )   ", "FieldODEStateAndDerivative s0 =  interpolator.getPreviousState (  )   ", " t0   =  s0.getTime (  )   ", " g0   =  handler.g (  s0   )   ", "while (  g0.getReal (  )    ==  NUM_   )", "T epsilon =  max (  solver.getAbsoluteAccuracy (  )    ,  solver.getRelativeAccuracy (  )   . multiply (  t0   )   . abs (  )    )   ", "T tStart =  t0.add (  epsilon.multiply (  forward  ? NUM_  :- NUM_   )    )   ", " if (  tStart.equals (  t0   )    ) ", " tStart   =  nextAfter (  t0   )   ", " t0   =  tStart  ", " g0   =  handler.g (  interpolator.getInterpolatedState (  tStart   )    )   "], ["FieldODEStateInterpolator interpolator", " forward   =  interpolator.isForward (  )   ", "FieldODEStateAndDerivative s0 =  interpolator.getPreviousState (  )   ", " t0   =  s0.getTime (  )   ", " g0   =  handler.g (  s0   )   ", "while (  g0.getReal (  )    ==  NUM_   )", "T epsilon =  max (  solver.getAbsoluteAccuracy (  )    ,  solver.getRelativeAccuracy (  )   . multiply (  t0   )   . abs (  )    )   ", "T tStart =  t0.add (  epsilon.multiply (  forward  ? NUM_  :- NUM_   )    )   ", " if (  tStart.equals (  t0   )    ) ", " tStart   =  nextAfter (  t0   )   ", " t0   =  tStart  ", " g0   =  handler.g (  interpolator.getInterpolatedState (  tStart   )    )   ", " g0Positive   =  g0.getReal (  )    >  NUM_  ", " increasing   =  g0Positive  "], ["FieldODEStateInterpolator interpolator", " forward   =  interpolator.isForward (  )   ", "FieldODEStateAndDerivative s0 =  interpolator.getPreviousState (  )   ", " t0   =  s0.getTime (  )   ", " g0   =  handler.g (  s0   )   ", "while (  g0.getReal (  )    ==  NUM_   )", "T epsilon =  max (  solver.getAbsoluteAccuracy (  )    ,  solver.getRelativeAccuracy (  )   . multiply (  t0   )   . abs (  )    )   ", "T tStart =  t0.add (  epsilon.multiply (  forward  ? NUM_  :- NUM_   )    )   ", " if (  tStart.equals (  t0   )    ) ", " t0   =  tStart  ", " g0   =  handler.g (  interpolator.getInterpolatedState (  tStart   )    )   "], ["FieldODEStateInterpolator interpolator", " forward   =  interpolator.isForward (  )   ", "FieldODEStateAndDerivative s0 =  interpolator.getPreviousState (  )   ", " t0   =  s0.getTime (  )   ", " g0   =  handler.g (  s0   )   ", "while (  g0.getReal (  )    ==  NUM_   )", "T epsilon =  max (  solver.getAbsoluteAccuracy (  )    ,  solver.getRelativeAccuracy (  )   . multiply (  t0   )   . abs (  )    )   ", "T tStart =  t0.add (  epsilon.multiply (  forward  ? NUM_  :- NUM_   )    )   ", " if (  tStart.equals (  t0   )    ) ", " t0   =  tStart  ", " g0   =  handler.g (  interpolator.getInterpolatedState (  tStart   )    )   ", " g0Positive   =  g0.getReal (  )    >  NUM_  ", " increasing   =  g0Positive  "]]
[]
[["String message", "   "]]
[["JComponent comp", " comp.addMouseListener (     )   ", " comp.addMouseMotionListener (     )   ", " refcount ++ "]]
[["ProjectReference projectReference", "Invocation request =  getWebTarget (  )   . path (  projectReference.workspaceId (  )    )   . path (  STR_   )   . queryParam (  STR_   ,  projectReference.name (  )    )   . request (  )   . accept (  APPLICATION_JSON   )   . buildGet (  )   ", "Type collectionType =  new TypeToken (  )   . getType (  )   ", " return  new SimpleRequest (  request   ,  new GenericType (  collectionType   )    ,  getAuthenticationManager (  )    )   "]]
[["double x , double y", "int N =  x.length  ", "GeneralPath path =  new GeneralPath (  )   ", " path.moveTo (  ,  )   ", "for (  ;  i   <  N   ;  i ++  ) ", " path.lineTo (  ,  )   "], ["double x , double y", "int N =  x.length  ", "GeneralPath path =  new GeneralPath (  )   ", " path.moveTo (  ,  )   ", "for (  ;  i   <  N   ;  i ++  ) ", " path.lineTo (  ,  )   ", " path.closePath (  )   ", " offscreen.fill (  path   )   ", " draw (  )   "]]
[[" return  new Property (     ,  getChronology (  )   . monthOfYear (  )    )   "]]
[["String host , String realm", " return   authenticationTokens   ,  remove (  host.concat (  realm   )    )     . authenticationTokens  . remove (  host.concat (  realm   )    )   "]]
[["IMessageEditorController controller , boolean editable", " return  new InputTab (  controller   ,  editable   )   "]]
[[" if (  log   !=  null   ) ", " updateCode (  )   ", " return  publishVersion (  )   "], [" if (  log   !=  null   ) ", " log.info (  STR_   +  deployment.getVersion (  )    +  STR_   +  deployment.getStage (  )    +  STR_   +  functionArn   +  STR_   )   ", " updateCode (  )   ", " return  publishVersion (  )   "]]
[["Object oo =  get_Value (  COLUMNNAME_IsQtyPercentage   )   ", " if (  oo   !=  null   ) ", " if (  oo   instanceof Boolean ) ", " return "], ["Object oo =  get_Value (  COLUMNNAME_IsQtyPercentage   )   ", " if (  oo   !=  null   ) ", " if (  oo   instanceof Boolean ) ", " return  STR_.equals (  oo   )   "], ["Object oo =  get_Value (  COLUMNNAME_IsQtyPercentage   )   ", " if (  oo   !=  null   ) ", " return  BOOL_  "]]
[["File file", " deleteRecursively (  file   ,  null   )   "]]
[["long threshold", " if (  state   ==  IDLE   &&  idleSince   <  threshold   ) ", " d (  STR_   )   ", " state   =  EXPIRED  ", " conn.closeConnection (  )   ", " return  BOOL_  "], ["long threshold", " if (  state   ==  IDLE   &&  idleSince   <  threshold   ) ", " d (  STR_   )   ", " return  BOOL_  "]]
[[" doInsertbyURL (  STR_   ,  packagePath   +  STR_   )   ", "long mutationResult =  doDeleteWithAccessPath (  null   ,  null   ,  null   )   ", " assertEquals (  NUM_   ,  mutationResult   )   "]]
[["FontRenderContext frc , char text , Bidi bidi , int flags", "  frc    . frc   =  frc  ", "  text    . text   =  text.clone (  )   ", "  bidi    . bidi   =  bidi  ", "  flags    . flags   =  flags  ", "  lineBidi    . lineBidi   =  bidi  ", "  lineStart    . lineStart   =  NUM_  ", "  lineLimit    . lineLimit   =  text.length  "]]
[["String s", "Automaton a =  naiveLev1 (  s   )   ", " a   =  Operations.union (  a   ,  transpositionsOf (  s   )    )   ", " a   =  MinimizationOperations.minimize (  a   ,  DEFAULT_MAX_DETERMINIZED_STATES   )   ", " return  a  "]]
[["boolean transientOnly = ! _space.getEngine (  )   . isColdStart (  )   ", " return  _recoveryGroup.recover (  transientOnly   ,  transientOnly   )   "]]
[["GeneralName name", " switch (  name.getTagNo (  )    ) ", " case NUM_", " checkExcludedDN (  ASN1Sequence.getInstance (  name.getName (  )   . toASN1Primitive (  )    )    )   "], ["GeneralName name", " switch (  name.getTagNo (  )    ) ", " case NUM_", " checkExcludedURI (  excludedSubtreesURI   ,  DERIA5String.getInstance (  name.getName (  )    )   . getString (  )    )   "], ["GeneralName name", " switch (  name.getTagNo (  )    ) ", " case NUM_", " checkExcludedEmail (  excludedSubtreesEmail   ,  extractNameAsString (  name   )    )   "], ["GeneralName name", " switch (  name.getTagNo (  )    ) ", " case NUM_", " checkExcludedDNS (  excludedSubtreesDNS   ,  DERIA5String.getInstance (  name.getName (  )    )   . getString (  )    )   "], ["GeneralName name", " switch (  name.getTagNo (  )    ) ", " case NUM_", "byte ip =  ASN1OctetString.getInstance (  name.getName (  )    )   . getOctets (  )   ", " checkExcludedIP (  excludedSubtreesIP   ,  ip   )   "]]
[[" return  version  "]]
[["String columnName", " return  new ColumnReference (  columnName   )   "]]
[["int access , String name , String desc , String signature , Object value", " if (  cv   !=  null   ) ", " return  null  "], ["int access , String name , String desc , String signature , Object value", " if (  cv   !=  null   ) ", " return  cv.visitField (  access   ,  name   ,  desc   ,  signature   ,  value   )   "]]
[["int len , int rounds", " if (  len   !=  NUM_   &&  len   !=  NUM_   &&  len   !=  NUM_   ) ", " new IllegalArgumentException (  STR_   +  len   )   ", "byte rawKeyValue =  constructKeyValue (  len   ,  rounds   )   ", "SecretKeySpec key =  new SecretKeySpec (  rawKeyValue   ,  STR_   )   ", " return  key  "], ["int len , int rounds", " if (  len   !=  NUM_   &&  len   !=  NUM_   &&  len   !=  NUM_   ) ", "byte rawKeyValue =  constructKeyValue (  len   ,  rounds   )   ", "SecretKeySpec key =  new SecretKeySpec (  rawKeyValue   ,  STR_   )   ", " return  key  "]]
[]
[["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " myHost.updateProgress (  progressLabel   ,  progress   )   ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "], ["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "]]
[["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", " bytesToRead   = ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", " bytesToRead   = ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) ", " bytesToRead   = "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", " bytesToRead   = ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) ", " bytesToRead   = ", " return  totalRead  "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", " bytesToRead   = ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) ", " return  totalRead  "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) ", " bytesToRead   = "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) ", " bytesToRead   = ", " return  totalRead  "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) ", " return  totalRead  "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " if (  length   ==  NUM_   ) ", " return  NUM_  "], ["InputStream input , OutputStream output , long inputOffset , long length , byte buffer", " if (  inputOffset   >  NUM_   ) ", " skipFully (  input   ,  inputOffset   )   ", " if (  length   ==  NUM_   ) ", "int bufferLength =  buffer.length  ", "int bytesToRead =  bufferLength  ", " if (  length   >  NUM_   &&  length   <  bufferLength   ) ", " bytesToRead   = ", "int read", "long totalRead =  NUM_  ", "while (  bytesToRead   >  NUM_   &&  EOF   !=  read   =  input.read (  buffer   ,  NUM_   ,  bytesToRead   )    )", " output.write (  buffer   ,  NUM_   ,  read   )   ", " totalRead   +=  read  ", " if (  length   >  NUM_   ) "]]
[["int columnIndex , long x", " new NotUpdatable (  )   "]]
[["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " myHost.updateProgress (  progressLabel   ,  progress   )   ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "], ["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "]]
[[" return  rethrow (  getMessage (  )    )   "]]
[["int theByte", " if (  suspendEncoding   ) ", "  write (  theByte   )     . write (  theByte   )   ", " return "], ["int theByte", " if (  suspendEncoding   ) ", " if (  encode   ) ", " if (  decodabet   [  theByte   &  NUM_   ] >  WHITE_SPACE_ENC   ) ", " if (  decodabet   [  theByte   &  NUM_   ] !=  WHITE_SPACE_ENC   ) ", " new java.io.IOException (  STR_   )   "], ["int theByte", " if (  suspendEncoding   ) ", " if (  encode   ) ", " if (  decodabet   [  theByte   &  NUM_   ] >  WHITE_SPACE_ENC   ) ", " buffer   [  position ++  ] = ", " if (  position   >=  bufferLength   ) ", "int len =  Base64.decode4to3 (  buffer   ,  NUM_   ,  b4   ,  NUM_   ,  options   )   ", " out.write (  b4   ,  NUM_   ,  len   )   ", " position   =  NUM_  "], ["int theByte", " if (  suspendEncoding   ) ", " if (  encode   ) ", " buffer   [  position ++  ] = ", " if (  position   >=  bufferLength   ) ", " out.write (  encode3to4 (  b4   ,  buffer   ,  bufferLength   ,  options   )    )   ", " lineLength   +=  NUM_  ", " if (  breakLines   &&  lineLength   >=  MAX_LINE_LENGTH   ) ", " out.write (  NEW_LINE   )   ", " lineLength   =  NUM_  ", " position   =  NUM_  "], ["int theByte", " if (  suspendEncoding   ) ", " if (  encode   ) ", " buffer   [  position ++  ] = ", " if (  position   >=  bufferLength   ) ", " out.write (  encode3to4 (  b4   ,  buffer   ,  bufferLength   ,  options   )    )   ", " lineLength   +=  NUM_  ", " if (  breakLines   &&  lineLength   >=  MAX_LINE_LENGTH   ) ", " position   =  NUM_  "]]
[["String message", "   "]]
[["   "]]
[["Class cls , QName qname", " return "]]
[["Expr node", "List list =  parent   ==  null   ||  state   ==  null  ? getInitListNoTransform (  )   : getInitList (  )   ", " list.addChild (  node   )   "]]
[["byte in , int iOff , int iLen , int lineLen , String lineSeparator", "int blockLen =  lineLen   *  NUM_   /  NUM_  ", " if (  blockLen   <=  NUM_   ) ", "int lines =  iLen   +  blockLen   -  NUM_   /  blockLen  ", "int bufLen =  iLen   +  NUM_   /  NUM_   *  NUM_   +  lines   *  lineSeparator.length (  )   ", "StringBuilder buf =  new StringBuilder (  bufLen   )   ", "int ip =  NUM_  ", "while (  ip   <  iLen   )", "int l =  Math.min (  iLen   -  ip   ,  blockLen   )   ", " buf.append (  encode (  in   ,  iOff   +  ip   ,  l   )    )   ", " buf.append (  lineSeparator   )   ", " ip   +=  l  ", " return  buf.toString (  )   "], ["byte in , int iOff , int iLen , int lineLen , String lineSeparator", "int blockLen =  lineLen   *  NUM_   /  NUM_  ", " if (  blockLen   <=  NUM_   ) ", "int lines =  iLen   +  blockLen   -  NUM_   /  blockLen  ", "int bufLen =  iLen   +  NUM_   /  NUM_   *  NUM_   +  lines   *  lineSeparator.length (  )   ", "StringBuilder buf =  new StringBuilder (  bufLen   )   ", "int ip =  NUM_  ", "while (  ip   <  iLen   )", "int l =  Math.min (  iLen   -  ip   ,  blockLen   )   ", " buf.append (  encode (  in   ,  iOff   +  ip   ,  l   )    )   ", " buf.append (  lineSeparator   )   ", " ip   +=  l  "], ["byte in , int iOff , int iLen , int lineLen , String lineSeparator", "int blockLen =  lineLen   *  NUM_   /  NUM_  ", " if (  blockLen   <=  NUM_   ) ", " new IllegalArgumentException (  )   ", "int lines =  iLen   +  blockLen   -  NUM_   /  blockLen  ", "int bufLen =  iLen   +  NUM_   /  NUM_   *  NUM_   +  lines   *  lineSeparator.length (  )   ", "StringBuilder buf =  new StringBuilder (  bufLen   )   ", "int ip =  NUM_  ", "while (  ip   <  iLen   )", "int l =  Math.min (  iLen   -  ip   ,  blockLen   )   ", " buf.append (  encode (  in   ,  iOff   +  ip   ,  l   )    )   ", " buf.append (  lineSeparator   )   ", " ip   +=  l  ", " return  buf.toString (  )   "], ["byte in , int iOff , int iLen , int lineLen , String lineSeparator", "int blockLen =  lineLen   *  NUM_   /  NUM_  ", " if (  blockLen   <=  NUM_   ) ", " new IllegalArgumentException (  )   ", "int lines =  iLen   +  blockLen   -  NUM_   /  blockLen  ", "int bufLen =  iLen   +  NUM_   /  NUM_   *  NUM_   +  lines   *  lineSeparator.length (  )   ", "StringBuilder buf =  new StringBuilder (  bufLen   )   ", "int ip =  NUM_  ", "while (  ip   <  iLen   )", "int l =  Math.min (  iLen   -  ip   ,  blockLen   )   ", " buf.append (  encode (  in   ,  iOff   +  ip   ,  l   )    )   ", " buf.append (  lineSeparator   )   ", " ip   +=  l  "]]
[[" return  nodes.keySet (  )   . iterator (  )   "]]
[["Graphics2D gc", " colorByClasses   =  BOOL_  ", " colorBySeries   =  BOOL_  ", " doDraw (  gc   )   "]]
[["Cursor cursor , String field , ContentValues values , String key", " values.put (  key   ,  cursor.getString (  cursor.getColumnIndexOrThrow (  field   )    )    )   "]]
[[" currentIterator   =  null  ", " currentId   =  null  ", " return  isCurrentSet (  )   "]]
[["Consul consul", "   "]]
[[" log.info (  STR_   )   "]]
[["String newPattern", " applyPattern (  newPattern   )   "]]
[["ActionMapping mappings , ActionForm form , HttpServletRequest request , HttpServletResponse response", " saveCurrentInvocation (  KeysClientsInvocations.VALORACION_DICTAMEN   ,  request   )   ", " removeInTemporalSession (  request   ,  ValoracionConstants.LISTA_BOLETINES_OFICIALES_KEY   )   ", " setInTemporalSession (  request   ,  ValoracionConstants.LISTA_BOLETINES_OFICIALES_KEY   ,  getGestionValoracionBI (  request   )   . getBoletinesOficiales (  )    )   ", " setReturnActionFordward (  request   ,  mappings.findForward (  STR_   )    )   "]]
[["Entry e", " setTitle (  e.file.getName (  )    )   ", " checkField.setText (  e.check   )   ", " enclPanel.setInfo (  e.encl   )   ", " selfPanel.setInfo (  e.self   )   ", " body.setText (  e.file.getCharContent (  BOOL_   )   . toString (  )    )   ", "Highlighter highlighter =  body.getHighlighter (  )   ", " highlighter.removeAllHighlights (  )   ", " addHighlight (  highlighter   ,  e.encl   ,  enclColor   )   ", " addHighlight (  highlighter   ,  e.self   ,  selfColor   )   ", " scroll (  body   ,  getMinPos (  enclPanel.info   ,  selfPanel.info   )    )   "]]
[["int dx , int minX , int maxX , int dy , int minY , int maxY", " if (  dx   !=  NUM_   ) ", " leadRow   +=  dy  ", " if (  leadRow   >  maxY   ) ", " leadRow   =  minY  ", " leadColumn ++ ", " if (  leadColumn   >  maxX   ) ", " leadColumn   =  minX  "], ["int dx , int minX , int maxX , int dy , int minY , int maxY", " if (  dx   !=  NUM_   ) ", " leadRow   +=  dy  ", " if (  leadRow   >  maxY   ) ", " if (  leadRow   <  minY   ) ", " leadRow   =  maxY  ", " leadColumn -- ", " if (  leadColumn   <  minX   ) ", " leadColumn   =  maxX  "], ["int dx , int minX , int maxX , int dy , int minY , int maxY", " if (  dx   !=  NUM_   ) ", " leadColumn   +=  dx  ", " if (  leadColumn   >  maxX   ) ", " if (  leadColumn   <  minX   ) ", " leadColumn   =  maxX  ", " leadRow -- ", " if (  leadRow   <  minY   ) ", " leadRow   =  maxY  "], ["int dx , int minX , int maxX , int dy , int minY , int maxY", " if (  dx   !=  NUM_   ) ", " leadColumn   +=  dx  ", " if (  leadColumn   >  maxX   ) ", " leadColumn   =  minX  ", " leadRow ++ ", " if (  leadRow   >  maxY   ) ", " leadRow   =  minY  "]]
[[" if (   inflight   ,  get (  )     . inflight  . get (  )    >=  MAX_INFLIGHT   ) ", " if (  NUM_   ==   pending   ,  get (  )     . pending  . get (  )    ) ", " if (  idx   >=  runnables.size (  )    ) ", " return "], [" if (   inflight   ,  get (  )     . inflight  . get (  )    >=  MAX_INFLIGHT   ) ", " if (  NUM_   ==   pending   ,  get (  )     . pending  . get (  )    ) ", " if (  idx   >=  runnables.size (  )    ) ", "GTSDecoderIteratorRunnable runnable =  runnables.get (  idx   )   ", " executor.execute (  runnable   )   ", " idx ++ "], [" if (   inflight   ,  get (  )     . inflight  . get (  )    >=  MAX_INFLIGHT   ) ", " if (  NUM_   ==   pending   ,  get (  )     . pending  . get (  )    ) ", " return "], [" if (   inflight   ,  get (  )     . inflight  . get (  )    >=  MAX_INFLIGHT   ) ", " return "]]
[["ProvidedRuntimeLibraryDependency object", " return  null  "]]
[["String message", " if (  myHost   !=  null   ) ", " System.out.println (  message   )   "], ["String message", " if (  myHost   !=  null   ) ", " myHost.showFeedback (  message   )   "]]
[["Map propMap", "   "]]
[["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case BIGGER", " result   =  database.compare (  l   ,  r   )    >  NUM_  ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case SMALLER_EQUAL", " result   =  database.compare (  l   ,  r   )    <=  NUM_  ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case SPATIAL_INTERSECTS", "ValueGeometry lg", "ValueGeometry rg", " result   =  lg.intersectsBoundingBox (  rg   )   ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case NOT_EQUAL , NOT_EQUAL_NULL_SAFE", " result   = ! database.areEqual (  l   ,  r   )   ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case SMALLER", " result   =  database.compare (  l   ,  r   )    <  NUM_  ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case BIGGER_EQUAL", " result   =  database.compare (  l   ,  r   )    >=  NUM_  ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case EQUAL , EQUAL_NULL_SAFE", " result   =  database.areEqual (  l   ,  r   )   ", " return  result  "], ["Database database , Value l , Value r , int compareType", "boolean result", " switch (  compareType   ) ", " case ", " DbException.throwInternalError (  STR_   +  compareType   )   ", " return  result  "]]
[]
[["List ids", " if ( ! ids.iterator (  )   . hasNext (  )    ) ", "String shortVdcId =  VdcUtil.getVdcId (  VirtualArray    ,  ids.iterator (  )   . next (  )    )   . toString (  )   ", "Iterator dbIterator", " if (  shortVdcId.equals (  VdcUtil.getLocalShortVdcId (  )    )    ) ", " dbIterator   =  _dbClient.queryIterativeObjects (  getResourceClass (  )    ,  ids   )   ", " return  new ObjectVirtualPoolBulkRep (  BulkList.wrapping (  dbIterator   ,  new mapObjectVirtualPoolWithResources (  )    ,  new BulkList.VirtualPoolFilter (  Type.object   )    )    )   "], ["List ids", " if ( ! ids.iterator (  )   . hasNext (  )    ) ", "String shortVdcId =  VdcUtil.getVdcId (  VirtualArray    ,  ids.iterator (  )   . next (  )    )   . toString (  )   ", "Iterator dbIterator", " if (  shortVdcId.equals (  VdcUtil.getLocalShortVdcId (  )    )    ) ", "GeoServiceClient geoClient =  _geoHelper.getClient (  shortVdcId   )   ", " dbIterator   =  geoClient.queryObjects (  getResourceClass (  )    ,  ids   )   ", " return  new ObjectVirtualPoolBulkRep (  BulkList.wrapping (  dbIterator   ,  new mapObjectVirtualPoolWithResources (  )    ,  new BulkList.VirtualPoolFilter (  Type.object   )    )    )   "], ["List ids", " if ( ! ids.iterator (  )   . hasNext (  )    ) ", " return  new ObjectVirtualPoolBulkRep (  )   "]]
[["String key", " if (  key   ==  null   ) ", "Entry e =   get (  key   )     . get (  key   )   ", " return  e   ==  null  ? BOOL_  : e.enabled (  )   "], ["String key", " if (  key   ==  null   ) ", " return  BOOL_  "]]
[["MultiDomainServerState cookie , DN domainDN", "ServerState providedState =  cookie.getServerState (  domainDN   )   ", " if (  providedState   ==  null   ) ", "ServerState domainOldestState =  getReplicationServerDomain (  domainDN   )   . getOldestState (  )   ", "for ( CSN oldestCsn :  domainOldestState   )", "CSN providedCsn =  providedState.getCSN (  oldestCsn.getServerId (  )    )   ", " if (  providedCsn   !=  null   &&  providedCsn.isOlderThan (  oldestCsn   )    ) ", " return  BOOL_  "], ["MultiDomainServerState cookie , DN domainDN", "ServerState providedState =  cookie.getServerState (  domainDN   )   ", " if (  providedState   ==  null   ) ", "ServerState domainOldestState =  getReplicationServerDomain (  domainDN   )   . getOldestState (  )   ", "for ( CSN oldestCsn :  domainOldestState   )", "CSN providedCsn =  providedState.getCSN (  oldestCsn.getServerId (  )    )   ", " if (  providedCsn   !=  null   &&  providedCsn.isOlderThan (  oldestCsn   )    ) "], ["MultiDomainServerState cookie , DN domainDN", "ServerState providedState =  cookie.getServerState (  domainDN   )   ", " if (  providedState   ==  null   ) ", "ServerState domainOldestState =  getReplicationServerDomain (  domainDN   )   . getOldestState (  )   ", "for ( CSN oldestCsn :  domainOldestState   )", "CSN providedCsn =  providedState.getCSN (  oldestCsn.getServerId (  )    )   ", " if (  providedCsn   !=  null   &&  providedCsn.isOlderThan (  oldestCsn   )    ) ", " return  BOOL_  "], ["MultiDomainServerState cookie , DN domainDN", "ServerState providedState =  cookie.getServerState (  domainDN   )   ", " if (  providedState   ==  null   ) ", " return  BOOL_  "]]
[[" intersections   =  detector.intersections (  items   )   ", " return  intersections.size (  )   "]]
[["Vector data", " window.getWListbox (  )   . clear (  )   ", " window.getWListbox (  )   . getModel (  )   . removeTableModelListener (  window   )   ", "ListModelTable model =  new ListModelTable (  data   )   ", " model.addTableModelListener (  window   )   ", " window.getWListbox (  )   . setData (  model   ,  getOISColumnNames (  )    )   ", " configureMiniTable (  window.getWListbox (  )    )   "]]
[[" glDeleteTextures (  raytraceTexture   )   ", " glDeleteTextures (  positionTexture   )   ", " glDeleteTextures (  normalTexture   )   ", " glDeleteRenderbuffers (  depthBuffer   )   ", " glDeleteFramebuffers (  fbo   )   ", " createRaytracingTexture (  )   ", " createRasterizerTextures (  )   ", " createRasterFrameBufferObject (  )   "]]
[["Object elem , int index", " if (  index   >=  elementCount   ) ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elementData   [  i   ] ==  null   ) ", " return  i  "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elementData   [  i   ] ==  null   ) ", " return - NUM_  "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elementData   [  i   ] ==  null   ) "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elem.equals (  elementData   [  i   ] )    ) ", " return  i  "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elem.equals (  elementData   [  i   ] )    ) ", " return - NUM_  "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elem.equals (  elementData   [  i   ] )    ) "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " new IndexOutOfBoundsException (  index   +  STR_   +  elementCount   )   ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elementData   [  i   ] ==  null   ) ", " return  i  "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " new IndexOutOfBoundsException (  index   +  STR_   +  elementCount   )   ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elementData   [  i   ] ==  null   ) ", " return - NUM_  "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " new IndexOutOfBoundsException (  index   +  STR_   +  elementCount   )   ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elementData   [  i   ] ==  null   ) "], ["Object elem , int index", " if (  index   >=  elementCount   ) ", " new IndexOutOfBoundsException (  index   +  STR_   +  elementCount   )   ", " if (  elem   ==  null   ) ", "for (  ;  i   >=  NUM_   ;  i --  ) ", " if (  elem.equals (  elementData   [  i   ] )    ) ", " return  i  "]]
[["JFrame parent , IFrontEndDebuggerProvider debugger", " m_parent   =  Preconditions.checkNotNull (  parent   ,  STR_   )   ", " m_debugger   =  Preconditions.checkNotNull (  debugger   ,  STR_   )   ", " putValue (  Action.NAME   ,  STR_   )   ", " putValue (  Action.SHORT_DESCRIPTION   ,  STR_   )   ", " putValue (  Action.SMALL_ICON   ,  new ImageIcon (  STR_   )    )   "]]
[[" return  distinct  "]]
[["double regularization , int iterations , KernelTrick kernel", "   "]]
[[" return  basicBlock   !=  null  "]]
[["String message , Exception e", "   ", "  m_exception    . m_exception   =  e  "]]
[["Picture picture", " width   =  picture.width (  )   ", " height   =  picture.height (  )   ", " image   =  new BufferedImage (  width   ,  height   ,  BufferedImage.TYPE_INT_RGB   )   ", " filename   =  picture.filename  ", "for (  ;  col   <  width (  )    ;  col ++  ) ", "for (  ;  row   <  height (  )    ;  row ++  ) ", " image.setRGB (  col   ,  row   ,  picture.get (  col   ,  row   )   . getRGB (  )    )   "]]
[[" accepted   =  BOOL_  ", " new LicenseRejectedException (     )   "]]
[["String path , String template", "File file =  new File (  path   ,  template   )   ", " if (  file.canRead (  )    ) ", " return  new BufferedInputStream (  new FileInputStream (  file.getAbsolutePath (  )    )    )   "], ["String path , String template", "File file =  new File (  path   ,  template   )   ", " if (  file.canRead (  )    ) ", " return  null  "]]
[["Automaton other", "int otherNumStates =  other.getNumStates (  )   ", "for (  ;  s   <  otherNumStates   ;  s ++  ) ", "int newState =  createState (  )   ", " setAccept (  newState   ,  other.isAccept (  s   )    )   "]]
[["int cacheSize , int partitions , Comparator comparator", "int m =  NUM_  ", "while (  m   <  partitions   )", " m   =  m   *  NUM_  ", "int partitionSize =  cacheSize   /  m  ", " if (  partitionSize   <  NUM_   ) ", "  arc    . arc   = ", "for (  ;  i   <   arc   ,  length    . arc  . length   ;  i ++  ) ", "  arc   , [  i   ]  . arc   [  i   ] =  new ComparableARC (  partitionSize   ,  comparator   )   "], ["int cacheSize , int partitions , Comparator comparator", "int m =  NUM_  ", "while (  m   <  partitions   )", " m   =  m   *  NUM_  ", "int partitionSize =  cacheSize   /  m  ", " if (  partitionSize   <  NUM_   ) ", "  arc    . arc   = ", "for (  ;  i   <   arc   ,  length    . arc  . length   ;  i ++  ) ", "  arc   , [  i   ]  . arc   [  i   ] =  new ComparableARC (  partitionSize   ,  comparator   )   ", " m   -=  NUM_  ", "  mask    . mask   =  m  "], ["int cacheSize , int partitions , Comparator comparator", "int m =  NUM_  ", "while (  m   <  partitions   )", " m   =  m   *  NUM_  ", "int partitionSize =  cacheSize   /  m  ", " if (  partitionSize   <  NUM_   ) ", " partitionSize   =  NUM_  ", "  arc    . arc   = ", "for (  ;  i   <   arc   ,  length    . arc  . length   ;  i ++  ) ", "  arc   , [  i   ]  . arc   [  i   ] =  new ComparableARC (  partitionSize   ,  comparator   )   "], ["int cacheSize , int partitions , Comparator comparator", "int m =  NUM_  ", "while (  m   <  partitions   )", " m   =  m   *  NUM_  ", "int partitionSize =  cacheSize   /  m  ", " if (  partitionSize   <  NUM_   ) ", " partitionSize   =  NUM_  ", "  arc    . arc   = ", "for (  ;  i   <   arc   ,  length    . arc  . length   ;  i ++  ) ", "  arc   , [  i   ]  . arc   [  i   ] =  new ComparableARC (  partitionSize   ,  comparator   )   ", " m   -=  NUM_  ", "  mask    . mask   =  m  "], ["int cacheSize , int partitions , Comparator comparator", "int m =  NUM_  ", "while (  m   <  partitions   )", " m   =  m   *  NUM_  "]]
[["ClassLoader loader , Properties props , Configuration config", "for (  ;  i.hasNext (  )    ;  ) ", "String key", "String className =  props.getProperty (  key   )   ", " if (  Debug.verboseOn (  )    ) ", " Debug.logVerbose (  STR_   +  key   +  STR_   +  className   ,  module   )   ", " config.setSharedVariable (  key   ,  loader.loadClass (  className   )   . newInstance (  )    )   "], ["ClassLoader loader , Properties props , Configuration config", "for (  ;  i.hasNext (  )    ;  ) ", "String key", "String className =  props.getProperty (  key   )   ", " if (  Debug.verboseOn (  )    ) ", " config.setSharedVariable (  key   ,  loader.loadClass (  className   )   . newInstance (  )    )   "]]
[[" return  right  "]]
[["Object values , boolean isnew", "Vector v =  new Vector (  )   ", "for (  ;  i   <  values.length   ;  i ++  ) ", " v.add (  values   [  i   ] )   ", " insertData (  v   ,  isnew   )   "], ["Object values , boolean isnew", "Vector v =  new Vector (  )   ", "for (  ;  i   <  values.length   ;  i ++  ) ", " v.add (  values   [  i   ] )   "]]
[["int nextCleanInt =  nextCleanInternal (  )   ", " return  nextCleanInt   == - NUM_  ? STR_  :"]]
[["GridDeployment dep , Object target , Class annCls", " return  ioc.isAnnotationPresent (  target   ,  annCls   ,  dep   )   "]]
[["   "]]
[["Path path , int fillingRule", " if (  clippingPath   ==  null   ||  clippingPath.isEmpty (  )    ) ", "Path pathCopy =  new Path (  path   )   ", " pathCopy.closeAllSubpaths (  )   ", "IClipper clipper =  new DefaultClipper (  )   ", " ClipperBridge.addPath (  clipper   ,  clippingPath   ,  IClipper.PolyType.SUBJECT   )   ", " ClipperBridge.addPath (  clipper   ,  pathCopy   ,  IClipper.PolyType.CLIP   )   ", "PolyTree resultTree =  new PolyTree (  )   ", " clipper.execute (  IClipper.ClipType.INTERSECTION   ,  resultTree   ,  IClipper.PolyFillType.NON_ZERO   ,  ClipperBridge.getFillType (  fillingRule   )    )   ", " clippingPath   =  ClipperBridge.convertToPath (  resultTree   )   "], ["Path path , int fillingRule", " if (  clippingPath   ==  null   ||  clippingPath.isEmpty (  )    ) ", " return "]]
[["String title , String timeAxisLabel , String valueAxisLabel , OHLCDataset dataset , boolean legend", "ValueAxis timeAxis =  new DateAxis (  timeAxisLabel   )   ", "NumberAxis valueAxis =  new NumberAxis (  valueAxisLabel   )   ", "XYPlot plot =  new XYPlot (  dataset   ,  timeAxis   ,  valueAxis   ,  null   )   ", " plot.setRenderer (  new CandlestickRenderer (  )    )   ", "JFreeChart chart =  new JFreeChart (  title   ,  JFreeChart.DEFAULT_TITLE_FONT   ,  plot   ,  legend   )   ", " currentTheme.apply (  chart   )   ", " return  chart  "]]
[["String value0 , String value1 , String value2", " return  new SM_SYSTEM_MESSAGE (  NUM_   ,  value0   ,  value1   ,  value2   )   "]]
[["Long wardId", "HierarchyType hType =  heirarchyTypeService.getHierarchyTypeByName (  hierarchyTypeName   )   ", "List areaList =  new LinkedList (  )   ", "BoundaryType childBoundaryType =  boundaryTypeService.getBoundaryTypeByNameAndHierarchyType (  STR_   ,  hType   )   ", "Boundary parentBoundary =  boundaryService.getBoundaryById (  wardId   )   ", " areaList   =  new LinkedList (  crossHeirarchyService.getCrossHierarchyChildrens (  parentBoundary   ,  childBoundaryType   )    )   ", " LOGGER.info (  STR_   +  areaList.toString (  )    )   ", " return  areaList  "]]
[["int messageType", " return  messageType   ==  MESSAGE_TYPE_FAILED   ||  messageType   ==  MESSAGE_TYPE_OUTBOX   ||  messageType   ==  MESSAGE_TYPE_SENT   ||  messageType   ==  MESSAGE_TYPE_QUEUED  "]]
[["Offset jtocOffset", " type   =  JTOC_ACCESS  ", " JTOCoffset   =  jtocOffset  "]]
[[" return  mThumbnail   !=  null  "]]
[["boolean useRtuOverTcp", " if ( ! isConnected (  )    ) ", " logger.debug (  STR_   )   ", " socket   =  new Socket (  )   ", " socket.setReuseAddress (  BOOL_   )   ", " socket.setSoLinger (  BOOL_   ,  NUM_   )   ", " socket.setKeepAlive (  BOOL_   )   ", " setTimeout (  timeout   )   ", " socket.connect (  new InetSocketAddress (  address   ,  port   )    ,  timeout   )   ", " prepareTransport (  useRtuOverTcp   )   ", " connected   =  BOOL_  "]]
[["Payload payload", " assertRequester (  )   ", " return  requester.requestResponse (  payload   )   "]]
[[" _id   =  Defs.NULL_ID  ", " _dest   =  Defs.DESTINATION_USER  ", " _product   =  UserDefs.PRODUCT_IDOC  ", " _perm   =  UserDefs.PERMISSION_NONE  "]]
[["boolean b", " if (  booleanField_   !=  null   ) ", " writeByteDirect (  b  ? Types.BOOLEAN_TRUE  : Types.BOOLEAN_FALSE   )   "], ["boolean b", " if (  booleanField_   !=  null   ) ", " writeFieldBeginInternal (  booleanField_   ,  b  ? Types.BOOLEAN_TRUE  : Types.BOOLEAN_FALSE   )   ", " booleanField_   =  null  "]]
[["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "], ["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " myHost.updateProgress (  progressLabel   ,  progress   )   ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "]]
[["String queryString", "PLParser parser =  new PLParser (  )   ", "Sentence alpha =  parser.parse (  queryString   )   ", " return  new TTEntails (  )   . ttEntails (     ,  alpha   )   "]]
[[" changeSet   =  null  "]]
[[" return  sTrainingTaskFuture   !=  null  "]]
[["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", " relativeFile   =  FileUtil.openFile (  f.getParentFile (  )    ,  relativeStr   )   ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", " relativeFile   =  FileUtil.openFile (  f.getParentFile (  )    ,  relativeStr   )   ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " Trace.trace (  STR_   +  relativeStr   +  STR_   +  result.getName (  )    )   ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", " relativeFile   =  FileUtil.openFile (  f.getParentFile (  )    ,  relativeStr   )   ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " result   =  new LocalFile (  relativeFile   )   ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", " relativeFile   =  FileUtil.openFile (  f.getParentFile (  )    ,  relativeStr   )   ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " result   =  new LocalFile (  relativeFile   )   ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " Trace.trace (  STR_   +  relativeStr   +  STR_   +  result.getName (  )    )   ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " Trace.trace (  STR_   +  relativeStr   +  STR_   +  result.getName (  )    )   ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " result   =  new LocalFile (  relativeFile   )   ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " if (  FileUtils.isFile (  f   )    ) ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " result   =  new LocalFile (  relativeFile   )   ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " Trace.trace (  STR_   +  relativeStr   +  STR_   +  result.getName (  )    )   ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " relativeFile   =  FileUtil.openFile (  f   ,  relativeStr   )   ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " return  result  "], ["String relativeStr", "File relativeFile =  null  ", " if (  FileUtils.isDirectory (  f   )    ) ", " relativeFile   =  FileUtil.openFile (  f   ,  relativeStr   )   ", "VirtualFile result =  null  ", " if (  relativeFile   !=  null   &&  FileUtils.exists (  relativeFile   )    ) ", " if (  result   !=  null   &&  Trace.pathResolver   ) ", " Trace.trace (  STR_   +  relativeStr   +  STR_   +  result.getName (  )    )   ", " return  result  "]]
[["long instant , long amount", " instant   =    ", " FieldUtils.verifyValueBounds (     ,  get (  instant   )    ,  iMin   ,  iMax   )   ", " return  instant  "]]
[["Statement object", " return  null  "]]
[["Type type", " if (  type   instanceof ParameterizedType ) ", " if (  String  equals (  type   )     . equals (  type   )    ||  type   instanceof Class &&  ) ", " return  STR_  "], ["Type type", " if (  type   instanceof ParameterizedType ) ", " if (  String  equals (  type   )     . equals (  type   )    ||  type   instanceof Class &&  ) ", " if (  Integer  equals (  type   )     . equals (  type   )    ||  Integer.TYPE.equals (  type   )    ||  Long  equals (  type   )     . equals (  type   )    ||  Long.TYPE.equals (  type   )    ||  Double  equals (  type   )     . equals (  type   )    ||  Double.TYPE.equals (  type   )    ) ", " return  STR_  "], ["Type type", " if (  type   instanceof ParameterizedType ) ", " if (  String  equals (  type   )     . equals (  type   )    ||  type   instanceof Class &&  ) ", " if (  Integer  equals (  type   )     . equals (  type   )    ||  Integer.TYPE.equals (  type   )    ||  Long  equals (  type   )     . equals (  type   )    ||  Long.TYPE.equals (  type   )    ||  Double  equals (  type   )     . equals (  type   )    ||  Double.TYPE.equals (  type   )    ) ", " if (  Boolean  equals (  type   )     . equals (  type   )    ) ", " return  STR_  "], ["Type type", " if (  type   instanceof ParameterizedType ) ", " if (  String  equals (  type   )     . equals (  type   )    ||  type   instanceof Class &&  ) ", " if (  Integer  equals (  type   )     . equals (  type   )    ||  Integer.TYPE.equals (  type   )    ||  Long  equals (  type   )     . equals (  type   )    ||  Long.TYPE.equals (  type   )    ||  Double  equals (  type   )     . equals (  type   )    ||  Double.TYPE.equals (  type   )    ) ", " if (  Boolean  equals (  type   )     . equals (  type   )    ) ", " return  type.getTypeName (  )   "], ["Type type", " if (  type   instanceof ParameterizedType ) ", "ParameterizedType parameterizedType", "Type rawType =  parameterizedType.getRawType (  )   ", " return  convertParametrizedType (  type   ,  parameterizedType   ,  rawType   )   "]]
[["Solution solution", "double x =  EncodingUtils.getReal (  solution   )   ", "double f =  new double [  numberOfObjectives   ]   ", "int k =  numberOfVariables   -  numberOfObjectives   +  NUM_  ", "double g =  NUM_  ", "for (  ;  i   <  numberOfVariables   ;  i ++  ) ", " g   +=  Math.pow (  x   [  i   ] -  NUM_   ,  NUM_   )   ", "for (  ;  i   <  numberOfObjectives   ;  i ++  ) ", " f   [  i   ] =  NUM_   +  g  ", "for (  ;  j   <  numberOfObjectives   -  i   -  NUM_   ;  j ++  ) ", " f   [  i   ] *=  Math.cos (  NUM_   *  Math.PI   *  x   [  j   ] )   "], ["Solution solution", "double x =  EncodingUtils.getReal (  solution   )   ", "double f =  new double [  numberOfObjectives   ]   ", "int k =  numberOfVariables   -  numberOfObjectives   +  NUM_  ", "double g =  NUM_  ", "for (  ;  i   <  numberOfVariables   ;  i ++  ) ", " g   +=  Math.pow (  x   [  i   ] -  NUM_   ,  NUM_   )   ", "for (  ;  i   <  numberOfObjectives   ;  i ++  ) ", " f   [  i   ] =  NUM_   +  g  ", "for (  ;  j   <  numberOfObjectives   -  i   -  NUM_   ;  j ++  ) ", " f   [  i   ] *=  Math.cos (  NUM_   *  Math.PI   *  x   [  j   ] )   ", " if (  i   !=  NUM_   ) ", " f   [  i   ] *=  Math.sin (  NUM_   *  Math.PI   *  x   [  numberOfObjectives   -  i   -  NUM_   ] )   "], ["Solution solution", "double x =  EncodingUtils.getReal (  solution   )   ", "double f =  new double [  numberOfObjectives   ]   ", "int k =  numberOfVariables   -  numberOfObjectives   +  NUM_  ", "double g =  NUM_  ", "for (  ;  i   <  numberOfVariables   ;  i ++  ) ", " g   +=  Math.pow (  x   [  i   ] -  NUM_   ,  NUM_   )   ", "for (  ;  i   <  numberOfObjectives   ;  i ++  ) ", " f   [  i   ] =  NUM_   +  g  ", "for (  ;  j   <  numberOfObjectives   -  i   -  NUM_   ;  j ++  ) ", " f   [  i   ] *=  Math.cos (  NUM_   *  Math.PI   *  x   [  j   ] )   ", " if (  i   !=  NUM_   ) ", " f   [  i   ] *=  Math.sin (  NUM_   *  Math.PI   *  x   [  numberOfObjectives   -  i   -  NUM_   ] )   ", " solution.setObjectives (  f   )   "], ["Solution solution", "double x =  EncodingUtils.getReal (  solution   )   ", "double f =  new double [  numberOfObjectives   ]   ", "int k =  numberOfVariables   -  numberOfObjectives   +  NUM_  ", "double g =  NUM_  ", "for (  ;  i   <  numberOfVariables   ;  i ++  ) ", " g   +=  Math.pow (  x   [  i   ] -  NUM_   ,  NUM_   )   ", "for (  ;  i   <  numberOfObjectives   ;  i ++  ) ", " f   [  i   ] =  NUM_   +  g  ", "for (  ;  j   <  numberOfObjectives   -  i   -  NUM_   ;  j ++  ) ", " f   [  i   ] *=  Math.cos (  NUM_   *  Math.PI   *  x   [  j   ] )   ", " if (  i   !=  NUM_   ) "], ["Solution solution", "double x =  EncodingUtils.getReal (  solution   )   ", "double f =  new double [  numberOfObjectives   ]   ", "int k =  numberOfVariables   -  numberOfObjectives   +  NUM_  ", "double g =  NUM_  ", "for (  ;  i   <  numberOfVariables   ;  i ++  ) ", " g   +=  Math.pow (  x   [  i   ] -  NUM_   ,  NUM_   )   ", "for (  ;  i   <  numberOfObjectives   ;  i ++  ) ", " f   [  i   ] =  NUM_   +  g  ", "for (  ;  j   <  numberOfObjectives   -  i   -  NUM_   ;  j ++  ) ", " f   [  i   ] *=  Math.cos (  NUM_   *  Math.PI   *  x   [  j   ] )   ", " if (  i   !=  NUM_   ) ", " solution.setObjectives (  f   )   "], ["Solution solution", "double x =  EncodingUtils.getReal (  solution   )   ", "double f =  new double [  numberOfObjectives   ]   ", "int k =  numberOfVariables   -  numberOfObjectives   +  NUM_  ", "double g =  NUM_  ", "for (  ;  i   <  numberOfVariables   ;  i ++  ) ", " g   +=  Math.pow (  x   [  i   ] -  NUM_   ,  NUM_   )   "]]
[["MySqlConfig mySqlConfig , ZkBinLogStateConfig zkConfig , LinkedBlockingQueue txEventQueue", "  openReplicator    . openReplicator   =  new OpenReplicator (  )   ", "  openReplicator   ,  setUser (  mySqlConfig.getUser (  )    )     . openReplicator  . setUser (  mySqlConfig.getUser (  )    )   ", "  openReplicator   ,  setPassword (  mySqlConfig.getPassword (  )    )     . openReplicator  . setPassword (  mySqlConfig.getPassword (  )    )   ", "  openReplicator   ,  setServerId (  mySqlConfig.getServerId (  )    )     . openReplicator  . setServerId (  mySqlConfig.getServerId (  )    )   ", "  openReplicator   ,  setPort (  mySqlConfig.getPort (  )    )     . openReplicator  . setPort (  mySqlConfig.getPort (  )    )   ", "  openReplicator   ,  setHost (  mySqlConfig.getHost (  )    )     . openReplicator  . setHost (  mySqlConfig.getHost (  )    )   ", "BinLogPosition binLogPosition =  getBinLogPositionToStartFrom (  mySqlConfig   ,  zkConfig   )   ", "  openReplicator   ,  setBinlogPosition (  binLogPosition.getBinLogPosition (  )    )     . openReplicator  . setBinlogPosition (  binLogPosition.getBinLogPosition (  )    )   ", "  openReplicator   ,  setBinlogFileName (  binLogPosition.getBinLogFileName (  )    )     . openReplicator  . setBinlogFileName (  binLogPosition.getBinLogFileName (  )    )   ", "  openReplicator   ,  setBinlogEventListener (  new SpoutBinLogEventListener (  txEventQueue   ,  getSchema (  mySqlConfig   )    ,  binLogPosition.getBinLogFileName (  )    )    )     . openReplicator  . setBinlogEventListener (  new SpoutBinLogEventListener (  txEventQueue   ,  getSchema (  mySqlConfig   )    ,  binLogPosition.getBinLogFileName (  )    )    )   ", " return  binLogPosition  "]]
[["Object t1", "Matrix3d m2", " return   m00    . m00   ==  m2.m00   &&   m01    . m01   ==  m2.m01   &&   m02    . m02   ==  m2.m02   &&   m10    . m10   ==  m2.m10   &&   m11    . m11   ==  m2.m11   &&   m12    . m12   ==  m2.m12   &&   m20    . m20   ==  m2.m20   &&   m21    . m21   ==  m2.m21   &&   m22    . m22   ==  m2.m22  "]]
[["PropertyChangeEvent e", " getHandler (  )   . propertyChange (  e   )   "]]
[[" return  textLine.isDirectionLTR (  )   "]]
[["WbXmlAttribute pi", "  prePi   ,  add (  pi   )     . prePi  . add (  pi   )   ", " return    "]]
[["int direction", "boolean down =  direction   ==  View.FOCUS_DOWN  ", "int height =  getHeight (  )   ", " if (  down   ) ", " mTempRect.top   =  getScrollY (  )    +  height  ", "int count =  getChildCount (  )   ", " if (  count   >  NUM_   ) ", " mTempRect.bottom   =  mTempRect.top   +  height  ", " return  scrollAndFocus (  direction   ,  mTempRect.top   ,  mTempRect.bottom   )   "], ["int direction", "boolean down =  direction   ==  View.FOCUS_DOWN  ", "int height =  getHeight (  )   ", " if (  down   ) ", " mTempRect.top   =  getScrollY (  )    +  height  ", "int count =  getChildCount (  )   ", " if (  count   >  NUM_   ) ", "View view =  getChildAt (  count   -  NUM_   )   ", " if (  mTempRect.top   +  height   >  view.getBottom (  )    ) ", " mTempRect.bottom   =  mTempRect.top   +  height  ", " return  scrollAndFocus (  direction   ,  mTempRect.top   ,  mTempRect.bottom   )   "], ["int direction", "boolean down =  direction   ==  View.FOCUS_DOWN  ", "int height =  getHeight (  )   ", " if (  down   ) ", " mTempRect.top   =  getScrollY (  )    +  height  ", "int count =  getChildCount (  )   ", " if (  count   >  NUM_   ) ", "View view =  getChildAt (  count   -  NUM_   )   ", " if (  mTempRect.top   +  height   >  view.getBottom (  )    ) ", " mTempRect.top   =  view.getBottom (  )    -  height  ", " mTempRect.bottom   =  mTempRect.top   +  height  ", " return  scrollAndFocus (  direction   ,  mTempRect.top   ,  mTempRect.bottom   )   "], ["int direction", "boolean down =  direction   ==  View.FOCUS_DOWN  ", "int height =  getHeight (  )   ", " if (  down   ) ", " mTempRect.top   =  getScrollY (  )    -  height  ", " if (  mTempRect.top   <  NUM_   ) ", " mTempRect.top   =  NUM_  ", " mTempRect.bottom   =  mTempRect.top   +  height  ", " return  scrollAndFocus (  direction   ,  mTempRect.top   ,  mTempRect.bottom   )   "], ["int direction", "boolean down =  direction   ==  View.FOCUS_DOWN  ", "int height =  getHeight (  )   ", " if (  down   ) ", " mTempRect.top   =  getScrollY (  )    -  height  ", " if (  mTempRect.top   <  NUM_   ) ", " mTempRect.bottom   =  mTempRect.top   +  height  ", " return  scrollAndFocus (  direction   ,  mTempRect.top   ,  mTempRect.bottom   )   "]]
[["boolean withHash", " return  encode0 (  client   ,  server   )   "]]
[["int rows , int columns", " return  make (  rows   ,  columns   )   . assign (  cern.jet.math.Functions.random (  )    )   "]]
[["IR ir", " return    "]]
[["T part", "  part    . part   =  part  "]]
[["EntryEventImpl ev", "  removeAllData   , [   removeAllDataSize    . removeAllDataSize   ]  . removeAllData   [   removeAllDataSize    . removeAllDataSize   ] =  new RemoveAllEntryData (  ev   )   ", "  removeAllDataSize    . removeAllDataSize   +=  NUM_  "]]
[["Time day", " day.hour   =  mSelectedDay.hour  ", " day.minute   =  mSelectedDay.minute  ", " day.second   =  mSelectedDay.second  ", " setSelectedDay (  day   )   "]]
[["String key , Object from , Object to", " ranges.add (  new Range (  key   ,  from   ,  to   )    )   ", " return    "]]
[["String message , Throwable cause , boolean enableSuppression , boolean writableStackTrace", "   "]]
[[" return  makeRegistrarCommon (  )   . setClientId (  STR_   )   . setRegistrarName (  STR_   )   . setIanaIdentifier (  NUM_   )   . setPassword (  STR_   )   . setPhoneNumber (  STR_   )   . setPhonePasscode (  STR_   )   . build (  )   "]]
[[" return  getState (  )   . isInitializing (  )   "]]
[[" inUserLoginGoToLocationSelection (  )   ", " inLocationSelectionClickLocation (  LOCATION_NAME   )   ", " pressBack (  )   ", " inLocationSelectionCheckZonesAndTentsDisplayed (  )   "]]
[["DbObject object , Right right", " if (  grantedRights   ==  null   ) ", " grantedRights.put (  object   ,  right   )   "], ["DbObject object , Right right", " if (  grantedRights   ==  null   ) ", " grantedRights   =  New.hashMap (  )   ", " grantedRights.put (  object   ,  right   )   "]]
[]
[["   "]]
[["ScoringFunctionFactory delegate , EventsManager events , ScoreTracker scoreTracker , MatsimServices controler", "  delegate    . delegate   =  delegate  ", "  events    . events   =  events  ", "  scoreTracker    . scoreTracker   =  scoreTracker  ", "  controler    . controler   =  controler  "]]
[["Set categories", " if (  categories   ==  null   ) ", "Iterator it =  categories.iterator (  )   ", " if (  mCategories   ==  null   ) ", "while (  it.hasNext (  )    )", "String category =  it.next (  )   ", " if ( ! mCategories.contains (  category   )    ) "], ["Set categories", " if (  categories   ==  null   ) ", "Iterator it =  categories.iterator (  )   ", " if (  mCategories   ==  null   ) ", "while (  it.hasNext (  )    )", "String category =  it.next (  )   ", " if ( ! mCategories.contains (  category   )    ) ", " return  category  "], ["Set categories", " if (  categories   ==  null   ) ", "Iterator it =  categories.iterator (  )   ", " if (  mCategories   ==  null   ) ", "while (  it.hasNext (  )    )", "String category =  it.next (  )   ", " if ( ! mCategories.contains (  category   )    ) ", " return  null  "], ["Set categories", " if (  categories   ==  null   ) ", "Iterator it =  categories.iterator (  )   ", " if (  mCategories   ==  null   ) ", " return  it.hasNext (  )   ? it.next (  )   : null  "], ["Set categories", " if (  categories   ==  null   ) ", " return  null  "]]
[["int from , int to", "double N =  to   -  from   +  NUM_  ", "double quickSortEstimate =  N   *  Math.log (  N   )    /  NUM_  ", "double width =  NUM_  ", "double countSortEstimate =  Math.max (  width   ,  N   )   ", " if (  countSortEstimate   <  quickSortEstimate   ) ", " quickSortFromTo (  from   ,  to   )   "], ["int from , int to", "double N =  to   -  from   +  NUM_  ", "double quickSortEstimate =  N   *  Math.log (  N   )    /  NUM_  ", "double width =  NUM_  ", "double countSortEstimate =  Math.max (  width   ,  N   )   ", " if (  countSortEstimate   <  quickSortEstimate   ) ", " countSortFromTo (  from   ,  to   )   "]]
[["BSPTree node", " if (  childAfter (  node   )   . getCut (  )    !=  null   ) ", "while (  isAfterParent (  node   )    )", " node   =  node.getParent (  )   "], ["BSPTree node", " if (  childAfter (  node   )   . getCut (  )    !=  null   ) ", "while (  isAfterParent (  node   )    )", " node   =  node.getParent (  )   ", " return  node.getParent (  )   "], ["BSPTree node", " if (  childAfter (  node   )   . getCut (  )    !=  null   ) ", " return  leafAfter (  node   )   . getParent (  )   "]]
[["String value", " return  unsafeParam (  STR_   ,  value   )   "]]
[["int udpPort , int timeoutMillis", "DatagramSocket socket =  null  ", " socket   =  new DatagramSocket (  )   ", " broadcast (  udpPort   ,  socket   )   ", " socket.setSoTimeout (  timeoutMillis   )   ", "DatagramPacket packet =  new DatagramPacket (  new byte [  NUM_   ]    ,  NUM_   )   ", " socket.receive (  packet   )   ", " if (  INFO   ) ", " return  packet.getAddress (  )   "], ["int udpPort , int timeoutMillis", "DatagramSocket socket =  null  ", " socket   =  new DatagramSocket (  )   ", " broadcast (  udpPort   ,  socket   )   ", " socket.setSoTimeout (  timeoutMillis   )   ", "DatagramPacket packet =  new DatagramPacket (  new byte [  NUM_   ]    ,  NUM_   )   ", " socket.receive (  packet   )   ", " if (  INFO   ) ", " info (  STR_   ,  STR_   +  packet.getAddress (  )    )   ", " return  packet.getAddress (  )   "]]
[["Collection ps", "boolean didChange =  BOOL_  ", "for ( Artist p :  ps   )", " if ( ! mArtists.contains (  p   )    &&  p   !=  null   ) ", " mArtists.add (  p   )   ", " didChange   =  BOOL_  ", " if (  didChange   ) ", " sortList (  )   "], ["Collection ps", "boolean didChange =  BOOL_  ", "for ( Artist p :  ps   )", " if ( ! mArtists.contains (  p   )    &&  p   !=  null   ) ", " mArtists.add (  p   )   ", " didChange   =  BOOL_  "], ["Collection ps", "boolean didChange =  BOOL_  ", "for ( Artist p :  ps   )", " if ( ! mArtists.contains (  p   )    &&  p   !=  null   ) ", " if (  didChange   ) ", " sortList (  )   "], ["Collection ps", "boolean didChange =  BOOL_  ", "for ( Artist p :  ps   )", " if ( ! mArtists.contains (  p   )    &&  p   !=  null   ) "]]
[["int apiLevel", " return  PROPERTY_DESCRIPTORS  "]]
[["CalendarDate date", " return  getDayOfWeek (  )    ==  date.getDayOfWeek (  )    &&  getMonth (  )    ==  date.getMonth (  )    &&  getYear (  )    ==  date.getYear (  )    &&  getEra (  )    ==  date.getEra (  )   "]]
[["IGame game , Entity ae , Targetable target , boolean useSensors , LosEffects los , List allECMInfo", " if ( ! ae.getCrew (  )   . isActive (  )    ) ", " return  BOOL_  "], ["IGame game , Entity ae , Targetable target , boolean useSensors , LosEffects los , List allECMInfo", " if ( ! ae.getCrew (  )   . isActive (  )    ) ", " if (  target.isOffBoard (  )    ) ", " return  BOOL_  "], ["IGame game , Entity ae , Targetable target , boolean useSensors , LosEffects los , List allECMInfo", " if ( ! ae.getCrew (  )   . isActive (  )    ) ", " if (  target.isOffBoard (  )    ) ", " if (  los   ==  null   ) ", " los   =  LosEffects.calculateLos (  game   ,  ae.getId (  )    ,  target   )   ", "boolean isVisible =  los.canSee (  )    &&  Compute.inVisualRange (  game   ,  los   ,  ae   ,  target   )   ", " if (  useSensors   ) ", " isVisible   =  isVisible   ||  Compute.inSensorRange (  game   ,  los   ,  ae   ,  target   ,  allECMInfo   )   ", " return  isVisible  "], ["IGame game , Entity ae , Targetable target , boolean useSensors , LosEffects los , List allECMInfo", " if ( ! ae.getCrew (  )   . isActive (  )    ) ", " if (  target.isOffBoard (  )    ) ", " if (  los   ==  null   ) ", " los   =  LosEffects.calculateLos (  game   ,  ae.getId (  )    ,  target   )   ", "boolean isVisible =  los.canSee (  )    &&  Compute.inVisualRange (  game   ,  los   ,  ae   ,  target   )   ", " if (  useSensors   ) ", " return  isVisible  "], ["IGame game , Entity ae , Targetable target , boolean useSensors , LosEffects los , List allECMInfo", " if ( ! ae.getCrew (  )   . isActive (  )    ) ", " if (  target.isOffBoard (  )    ) ", " if (  los   ==  null   ) ", "boolean isVisible =  los.canSee (  )    &&  Compute.inVisualRange (  game   ,  los   ,  ae   ,  target   )   ", " if (  useSensors   ) ", " isVisible   =  isVisible   ||  Compute.inSensorRange (  game   ,  los   ,  ae   ,  target   ,  allECMInfo   )   ", " return  isVisible  "], ["IGame game , Entity ae , Targetable target , boolean useSensors , LosEffects los , List allECMInfo", " if ( ! ae.getCrew (  )   . isActive (  )    ) ", " if (  target.isOffBoard (  )    ) ", " if (  los   ==  null   ) ", "boolean isVisible =  los.canSee (  )    &&  Compute.inVisualRange (  game   ,  los   ,  ae   ,  target   )   ", " if (  useSensors   ) ", " return  isVisible  "]]
[["RPObject player", " if (  player.has (  AWAY   )    ) ", " if (  player.has (  GRUMPY   )    ) ", " player.remove (  GRUMPY   )   "], ["RPObject player", " if (  player.has (  AWAY   )    ) ", " player.remove (  AWAY   )   ", " if (  player.has (  GRUMPY   )    ) ", " player.remove (  GRUMPY   )   "]]
[["CapabilitiesFilterChangeEvent e", " if (  e.getFilter (  )    ==  null   ) ", " updateCapabilitiesFilter (  )   "], ["CapabilitiesFilterChangeEvent e", " if (  e.getFilter (  )    ==  null   ) ", " updateCapabilitiesFilter (  null   )   "]]
[["while (   stop    . stop   )", " System.out.print (  STR_   )   "]]
[["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " if (  s   !=  null   ) ", " LockSupport.unpark (  s.thread   )   "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) ", " if (  s   !=  null   ) ", " LockSupport.unpark (  s.thread   )   "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) ", " s   =  t  "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) ", " s   =  t  ", " if (  s   !=  null   ) ", " LockSupport.unpark (  s.thread   )   "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", " compareAndSetWaitStatus (  node   ,  ws   ,  NUM_   )   ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " if (  s   !=  null   ) ", " LockSupport.unpark (  s.thread   )   "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", " compareAndSetWaitStatus (  node   ,  ws   ,  NUM_   )   ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) ", " if (  s   !=  null   ) ", " LockSupport.unpark (  s.thread   )   "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", " compareAndSetWaitStatus (  node   ,  ws   ,  NUM_   )   ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", " compareAndSetWaitStatus (  node   ,  ws   ,  NUM_   )   ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) ", " s   =  t  "], ["Node node", "int ws =  node.waitStatus  ", " if (  ws   <  NUM_   ) ", " compareAndSetWaitStatus (  node   ,  ws   ,  NUM_   )   ", "Node s =  node.next  ", " if (  s   ==  null   ||  s.waitStatus   >  NUM_   ) ", " s   =  null  ", "for (  ;  t   !=  null   &&  t   !=  node   ;  t   =  t.prev   ) ", " if (  t.waitStatus   <=  NUM_   ) ", " s   =  t  ", " if (  s   !=  null   ) ", " LockSupport.unpark (  s.thread   )   "]]
[[" setCachedExpression (  generateExpression (  )    )   ", " checkSymbolIsValid (  )   ", "FieldConfigBase parent =  getParent (  )   ", " if (  parent   !=  null   ) ", " parent.valueUpdated (  )   "]]
[["PdfDecoderInt decode_pdf , GUIFactory currentGUI , GUIThumbnailPanel thumbnails , Values commonValues", " new UnsupportedOperationException (  STR_   )   "]]
[["Canvas canvas", " addTaint (  canvas.getTaint (  )    )   "]]
[["float f", " return  *  f  "]]
[["Category category", " return  category   ==  CakePHP3Module.Category.TEMPLATE   ||  category   ==  CakePHP3Module.Category.TEMPLATE_CELL   ||  category   ==  CakePHP3Module.Category.ELEMENT   ||  category   ==  CakePHP3Module.Category.ERROR   ||  category   ==  CakePHP3Module.Category.LAYOUT   ||  category   ==  CakePHP3Module.Category.EMAIL   ||  category   ==  CakePHP3Module.Category.PAGES  "]]
[["int bytesConsumed", " peekBufferLength   -=  bytesConsumed  ", " peekBufferPosition   =  NUM_  ", " System.arraycopy (  peekBuffer   ,  bytesConsumed   ,  peekBuffer   ,  NUM_   ,  peekBufferLength   )   "]]
[["int typeRef", "  value    . value   =  typeRef  "]]
[["int size", " data   =  new double [  size   ]   "]]
[["String param", " if (  isEmpty (  param   )    ) ", " return  BOOL_  "], ["String param", " if (  isEmpty (  param   )    ) ", " return  param.equalsIgnoreCase (  STR_   )    ||  param.equalsIgnoreCase (  STR_   )   "]]
[["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " myHost.updateProgress (  progressLabel   ,  progress   )   ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "], ["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "]]
[["String description", " desc   =  description  "]]
[[" return  STR_   +   index    . index   +  STR_   +   character    . character   +  STR_   +   line    . line   +  STR_  "]]
[["Composite parent , String text , int hspan", "Label l =  new Label (  parent   ,  SWT.NONE   )   ", " l.setFont (  parent.getFont (  )    )   ", " if (  text   !=  null   ) ", " l.setText (  text   )   ", "GridData gd =  new GridData (  GridData.FILL_HORIZONTAL   )   ", " gd.horizontalSpan   =  hspan  ", " gd.grabExcessHorizontalSpace   =  BOOL_  ", " l.setLayoutData (  gd   )   ", " return  l  "], ["Composite parent , String text , int hspan", "Label l =  new Label (  parent   ,  SWT.NONE   )   ", " l.setFont (  parent.getFont (  )    )   ", " if (  text   !=  null   ) ", "GridData gd =  new GridData (  GridData.FILL_HORIZONTAL   )   ", " gd.horizontalSpan   =  hspan  ", " gd.grabExcessHorizontalSpace   =  BOOL_  ", " l.setLayoutData (  gd   )   ", " return  l  "]]
[["IMultiPoint items", " if (  items   ==  null   ) ", " return "], ["IMultiPoint items", " if (  items   ==  null   ) ", " model.setItems (  items   )   ", "int width =  getCanvas (  )   . getWidth (  )   ", "int height =  getCanvas (  )   . getHeight (  )   ", " nativeItems   =  items  ", " items   =  transform (  items   ,  width   ,  height   )   ", " model.setItems (  items   )   ", " getCanvas (  )   . redrawState (  )   ", " getCanvas (  )   . repaint (  )   "]]
[["DN dn", "   "]]
[["HttpServletRequest httpServletRequest , String orgId , String spaceId , String jsonString", "JSONObject response =  new JSONObject (  )   ", " response.put (  STR_   ,  TESTPOLICYID   )   ", " return  RestApiResponseHandler.getResponseCreatedOk (  response.toString (  )    )   "]]
[["BytecodePosition bytecodePosition", "ArrayList elements =  new ArrayList (  )   ", "BytecodePosition position =  bytecodePosition  ", "while (  position   !=  null   )", "ResolvedJavaMethod method =  position.getMethod (  )   ", " if (  method   !=  null   ) ", " position   =  position.getCaller (  )   ", " return  elements.toArray (  new StackTraceElement [  NUM_   ]    )   "], ["BytecodePosition bytecodePosition", "ArrayList elements =  new ArrayList (  )   ", "BytecodePosition position =  bytecodePosition  ", "while (  position   !=  null   )", "ResolvedJavaMethod method =  position.getMethod (  )   ", " if (  method   !=  null   ) ", " position   =  position.getCaller (  )   "], ["BytecodePosition bytecodePosition", "ArrayList elements =  new ArrayList (  )   ", "BytecodePosition position =  bytecodePosition  ", "while (  position   !=  null   )", "ResolvedJavaMethod method =  position.getMethod (  )   ", " if (  method   !=  null   ) ", " elements.add (  method.asStackTraceElement (  position.getBCI (  )    )    )   ", " position   =  position.getCaller (  )   ", " return  elements.toArray (  new StackTraceElement [  NUM_   ]    )   "], ["BytecodePosition bytecodePosition", "ArrayList elements =  new ArrayList (  )   ", "BytecodePosition position =  bytecodePosition  ", "while (  position   !=  null   )", "ResolvedJavaMethod method =  position.getMethod (  )   ", " if (  method   !=  null   ) ", " elements.add (  method.asStackTraceElement (  position.getBCI (  )    )    )   ", " position   =  position.getCaller (  )   "]]
[["JsonCommand jsonCommand , DataIntegrityViolationException dve", "Throwable realCause =  dve.getMostSpecificCause (  )   ", " if (  realCause.getMessage (  )   . contains (  ReportMailingJobConstants.NAME_PARAM_NAME   )    ) ", "String name =  jsonCommand.stringValueOfParameterNamed (  ReportMailingJobConstants.NAME_PARAM_NAME   )   ", " new PlatformDataIntegrityException (  STR_   ,  STR_   +  name   +  STR_   ,  ReportMailingJobConstants.NAME_PARAM_NAME   ,  name   )   ", " logger.error (  dve.getMessage (  )    ,  dve   )   ", " new PlatformDataIntegrityException (  STR_   ,  STR_   +  realCause.getMessage (  )    )   "], ["JsonCommand jsonCommand , DataIntegrityViolationException dve", "Throwable realCause =  dve.getMostSpecificCause (  )   ", " if (  realCause.getMessage (  )   . contains (  ReportMailingJobConstants.NAME_PARAM_NAME   )    ) ", " logger.error (  dve.getMessage (  )    ,  dve   )   ", " new PlatformDataIntegrityException (  STR_   ,  STR_   +  realCause.getMessage (  )    )   "]]
[["String guid , String traitInstanceDefinition", " guid   =  ParamChecker.notEmpty (  guid   ,  STR_   )   ", " traitInstanceDefinition   =  ParamChecker.notEmpty (  traitInstanceDefinition   ,  STR_   )   ", "ITypedStruct traitInstance =  deserializeTraitInstance (  traitInstanceDefinition   )   ", " addTrait (  guid   ,  traitInstance   )   "]]
[["ServletContext context", " if (  context   !=  null   ) ", " scanForFacesServlet (  context   )   "]]
[["Paint color", "  color    . color   =  color  "]]
[["Class clazz", " return  ClassUtils.isPrimitiveOrWrapper (  clazz   )    ||  clazz.equals (  String    )    ||  clazz.equals (  IDiscordClient    )   "]]
[["String propertyName", " return  properties.get (  propertyName   )   "]]
[["int value", " flushBits (  )   ", " out.write (  value   &  NUM_   )   ", " out.write (  value   >>  NUM_   )   ", " out.write (  value   >>  NUM_   )   ", " out.write (  value   >>  NUM_   )   ", " bytesWritten   +=  NUM_  "]]
[["  control   ,  setEnabled (  BOOL_   )     . control  . setEnabled (  BOOL_   )   ", " return    "]]
[[" if (  outer   == - NUM_   ) ", "Point2D.Double ctr =  getCenter (  )   ", " outer   =  NUM_  ", "double dist =  NUM_  ", "for (  ;  i   <  n   ;  i ++  ) ", "Node cp =  get (  i   )   ", "double d =  Geom.length2 (  ctr.x   ,  ctr.y   ,  cp.x   [  NUM_   ] ,  cp.y   [  NUM_   ] )   ", " if (  d   >  dist   ) "], [" if (  outer   == - NUM_   ) ", "Point2D.Double ctr =  getCenter (  )   ", " outer   =  NUM_  ", "double dist =  NUM_  ", "for (  ;  i   <  n   ;  i ++  ) ", "Node cp =  get (  i   )   ", "double d =  Geom.length2 (  ctr.x   ,  ctr.y   ,  cp.x   [  NUM_   ] ,  cp.y   [  NUM_   ] )   ", " if (  d   >  dist   ) ", " dist   =  d  ", " outer   =  i  "], [" if (  outer   == - NUM_   ) ", "Point2D.Double ctr =  getCenter (  )   ", " outer   =  NUM_  ", "double dist =  NUM_  ", "for (  ;  i   <  n   ;  i ++  ) ", "Node cp =  get (  i   )   ", "double d =  Geom.length2 (  ctr.x   ,  ctr.y   ,  cp.x   [  NUM_   ] ,  cp.y   [  NUM_   ] )   ", " if (  d   >  dist   ) ", " dist   =  d  ", " outer   =  i  ", " return  outer  "], [" if (  outer   == - NUM_   ) ", "Point2D.Double ctr =  getCenter (  )   ", " outer   =  NUM_  ", "double dist =  NUM_  ", "for (  ;  i   <  n   ;  i ++  ) ", "Node cp =  get (  i   )   ", "double d =  Geom.length2 (  ctr.x   ,  ctr.y   ,  cp.x   [  NUM_   ] ,  cp.y   [  NUM_   ] )   ", " if (  d   >  dist   ) ", " return  outer  "], [" if (  outer   == - NUM_   ) ", " return  outer  "]]
[[" return   io   ,  getPointerField (     ,  NUM_   )     . io  . getPointerField (     ,  NUM_   )   "]]
[["String skillcaster , String skillname", " return  new SM_SYSTEM_MESSAGE (  NUM_   ,  skillcaster   ,  skillname   )   "]]
[["Border border", "   "]]
[["MessageFactory messageFactory , File saveDir", "   "]]
[[" if (  STGroup.trackCreationEvents   ) ", " if (  debugState   ==  null   ) ", " debugState   =  new ST.DebugState (  )   ", " debugState.newSTEvent   =  new ConstructionEvent (  )   "], [" if (  STGroup.trackCreationEvents   ) ", " if (  debugState   ==  null   ) ", " debugState.newSTEvent   =  new ConstructionEvent (  )   "]]
[[" helperTextColors.clear (  )   "]]
[["List expressions , List dims , List msrs", "for ( CustomAggregateExpression expression :  expressions   )", "List dimsFromExpr =  expression.getReferredColumns (  )   ", "for ( CarbonColumn dimFromExpr :  dimsFromExpr   )", " if ( ! dimFromExpr.isDimesion (  )    ) ", " dims.add (  )   "], ["List expressions , List dims , List msrs", "for ( CustomAggregateExpression expression :  expressions   )", "List dimsFromExpr =  expression.getReferredColumns (  )   ", "for ( CarbonColumn dimFromExpr :  dimsFromExpr   )", " if ( ! dimFromExpr.isDimesion (  )    ) ", " msrs.add (  )   "]]
[]
[["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " return  replacer  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", " return  replacer  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", "int encodedVersion =  encoded   [  NUM_   ] &  NUM_   <<  NUM_   |  encoded   [  NUM_   ] &  NUM_  ", " if (  clientVersion   !=  encodedVersion   ) ", " if (  clientVersion   >  NUM_   ||  serverVersion   !=  encodedVersion   ) ", " return  encoded  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", "int encodedVersion =  encoded   [  NUM_   ] &  NUM_   <<  NUM_   |  encoded   [  NUM_   ] &  NUM_  ", " if (  clientVersion   !=  encodedVersion   ) ", " if (  clientVersion   >  NUM_   ||  serverVersion   !=  encodedVersion   ) ", " encoded   =  replacer  ", " return  encoded  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", "int encodedVersion =  encoded   [  NUM_   ] &  NUM_   <<  NUM_   |  encoded   [  NUM_   ] &  NUM_  ", " if (  clientVersion   !=  encodedVersion   ) ", " return  encoded  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", " random   =  JCAUtil.getSecureRandom (  )   ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " return  replacer  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", " random   =  JCAUtil.getSecureRandom (  )   ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", " return  replacer  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", " random   =  JCAUtil.getSecureRandom (  )   ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", "int encodedVersion =  encoded   [  NUM_   ] &  NUM_   <<  NUM_   |  encoded   [  NUM_   ] &  NUM_  ", " if (  clientVersion   !=  encodedVersion   ) ", " if (  clientVersion   >  NUM_   ||  serverVersion   !=  encodedVersion   ) ", " return  encoded  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", " random   =  JCAUtil.getSecureRandom (  )   ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", "int encodedVersion =  encoded   [  NUM_   ] &  NUM_   <<  NUM_   |  encoded   [  NUM_   ] &  NUM_  ", " if (  clientVersion   !=  encodedVersion   ) ", " if (  clientVersion   >  NUM_   ||  serverVersion   !=  encodedVersion   ) ", " encoded   =  replacer  ", " return  encoded  "], ["int clientVersion , int serverVersion , SecureRandom random , byte encoded , boolean isFailOver", " if (  random   ==  null   ) ", " random   =  JCAUtil.getSecureRandom (  )   ", "byte replacer =  new byte [  NUM_   ]   ", " random.nextBytes (  replacer   )   ", " if ( ! isFailOver   &&  encoded   !=  null   ) ", " if (  encoded.length   !=  NUM_   ) ", "int encodedVersion =  encoded   [  NUM_   ] &  NUM_   <<  NUM_   |  encoded   [  NUM_   ] &  NUM_  ", " if (  clientVersion   !=  encodedVersion   ) ", " return  encoded  "]]
[["int ch , int width", "StringBuffer buf =  new StringBuffer (  )   ", " return  appendNumber (  buf   ,  ch   ,  NUM_   ,  width   )   . toString (  )   "]]
[["Characters characters", "String data =  characters.getData (  )   ", " if (  characters.isCData (  )    ) ", " return  factory.createCDATA (  data   )   "], ["Characters characters", "String data =  characters.getData (  )   ", " if (  characters.isCData (  )    ) ", " return  factory.createText (  data   )   "]]
[["Map serverProperties", "DN dn =  makeDNFromServerProperties (  serverProperties   )   ", "ModifyRequest request =  newModifyRequest (  dn   )   ", "for ( ServerProperty prop :  serverProperties.keySet (  )    )", "Attribute attr =  makeAttrFromServerProperty (  prop   ,  serverProperties.get (  prop   )    )   ", " if (  attr   !=  null   ) ", " request.addModification (  new Modification (  REPLACE   ,  attr   )    )   "], ["Map serverProperties", "DN dn =  makeDNFromServerProperties (  serverProperties   )   ", "ModifyRequest request =  newModifyRequest (  dn   )   ", "for ( ServerProperty prop :  serverProperties.keySet (  )    )", "Attribute attr =  makeAttrFromServerProperty (  prop   ,  serverProperties.get (  prop   )    )   ", " if (  attr   !=  null   ) ", " request.addModification (  new Modification (  REPLACE   ,  attr   )    )   ", " throwIfNotSuccess (  connectionWrapper.getConnection (  )   . modify (  request   )    )   ", " if (  serverProperties.containsKey (  ServerProperty.INSTANCE_PUBLIC_KEY_CERTIFICATE   )    ) ", " registerInstanceKeyCertificate (  serverProperties   ,  dn   )   "], ["Map serverProperties", "DN dn =  makeDNFromServerProperties (  serverProperties   )   ", "ModifyRequest request =  newModifyRequest (  dn   )   ", "for ( ServerProperty prop :  serverProperties.keySet (  )    )", "Attribute attr =  makeAttrFromServerProperty (  prop   ,  serverProperties.get (  prop   )    )   ", " if (  attr   !=  null   ) "], ["Map serverProperties", "DN dn =  makeDNFromServerProperties (  serverProperties   )   ", "ModifyRequest request =  newModifyRequest (  dn   )   ", "for ( ServerProperty prop :  serverProperties.keySet (  )    )", "Attribute attr =  makeAttrFromServerProperty (  prop   ,  serverProperties.get (  prop   )    )   ", " if (  attr   !=  null   ) ", " throwIfNotSuccess (  connectionWrapper.getConnection (  )   . modify (  request   )    )   ", " if (  serverProperties.containsKey (  ServerProperty.INSTANCE_PUBLIC_KEY_CERTIFICATE   )    ) ", " registerInstanceKeyCertificate (  serverProperties   ,  dn   )   "]]
[[" if ( ! checkCallerThread   ) ", " return  BOOL_  "], [" if ( ! checkCallerThread   ) ", " if (  currentThread   ==  null   ) ", " logger.error (  STR_   )   ", "Map map =  Thread.getAllStackTraces (  )   ", "for ( Thread t :  map.keySet (  )    )", "String msg =  STR_   +  t   +  STR_  ", "for ( StackTraceElement e :  map.get (  t   )    )", " msg   +=  STR_   +  e   +  STR_  "], [" if ( ! checkCallerThread   ) ", " if (  currentThread   ==  null   ) ", " logger.error (  STR_   )   ", "Map map =  Thread.getAllStackTraces (  )   ", "for ( Thread t :  map.keySet (  )    )", "String msg =  STR_   +  t   +  STR_  ", "for ( StackTraceElement e :  map.get (  t   )    )", " msg   +=  STR_   +  e   +  STR_  ", " logger.error (  msg   )   ", " currentThread   =  Thread.currentThread (  )   ", " return  Thread.currentThread (  )    !=  currentThread  "], [" if ( ! checkCallerThread   ) ", " if (  currentThread   ==  null   ) ", " logger.error (  STR_   )   ", "Map map =  Thread.getAllStackTraces (  )   ", "for ( Thread t :  map.keySet (  )    )", "String msg =  STR_   +  t   +  STR_  ", "for ( StackTraceElement e :  map.get (  t   )    )", " msg   +=  STR_   +  e   +  STR_  ", " logger.error (  msg   )   "], [" if ( ! checkCallerThread   ) ", " if (  currentThread   ==  null   ) ", " return  Thread.currentThread (  )    !=  currentThread  "]]
[["Context context , List imagePaths , int width , int height", " mContext   =  context  ", "  mImagePaths    . mImagePaths   =  imagePaths  ", "  mWidth    . mWidth   =  width  ", "  mHeight    . mHeight   =  height  ", " mAbImageLoader   =  new AbImageLoader (  mContext   )   ", " mAbImageLoader.setMaxWidth (   mWidth    . mWidth   )   ", " mAbImageLoader.setMaxHeight (   mHeight    . mHeight   )   ", " mAbImageLoader.setLoadingImage (  R.drawable.image_loading   )   ", " mAbImageLoader.setErrorImage (  R.drawable.image_error   )   ", " mAbImageLoader.setEmptyImage (  R.drawable.image_empty   )   "]]
[[" map.clear (  )   ", " closeCache (  )   ", " clientVM1.invoke (  null   )   ", " clientVM2.invoke (  null   )   ", " serverVM0.invoke (  null   )   ", " serverVM1.invoke (  null   )   ", " serverVM0.invoke (  null   )   ", " serverVM1.invoke (  null   )   ", " disconnectAllFromDS (  )   "]]
[["int tagId , int ifdId", " mData.removeTag (  getTrueTagKey (  tagId   )    ,  ifdId   )   "]]
[["Object object", " if (  object   ==  null   ) ", " return  null  "], ["Object object", " if (  object   ==  null   ) ", " if (  object   instanceof SpaceMapEntry ) ", " return  _converter.toInternal (  object   )   "], ["Object object", " if (  object   ==  null   ) ", " if (  object   instanceof SpaceMapEntry ) ", " if (  object   instanceof Map.Entry ) ", "Map.Entry entry", "SpaceMapEntry envelope =  MapEntryFactory.create (  entry.getKey (  )    ,  entry.getValue (  )    )   ", " return  _converter.toInternal (  envelope   )   "], ["Object object", " if (  object   ==  null   ) ", " if (  object   instanceof SpaceMapEntry ) ", " if (  object   instanceof Map.Entry ) ", " if (  _converter   !=  null   ) ", " return  _converter.toInternal (  object   )   "], ["Object object", " if (  object   ==  null   ) ", " if (  object   instanceof SpaceMapEntry ) ", " if (  object   instanceof Map.Entry ) ", " if (  _converter   !=  null   ) ", " return  null  "]]
[["Coord projection", " if ( ! projection.isProjected (  )    ) ", " return  inverseMercator (  projection.getLatitude (  )    ,  projection.getLongitude (  )    )   "], ["Coord projection", " if ( ! projection.isProjected (  )    ) ", " return  projection  "]]
[["java.io.ObjectInputStream s", " s.defaultReadObject (  )   ", " set (  s.readDouble (  )    )   "]]
[["Event event", " if (  event   instanceof Cancellable ) ", " executor.execute (  listener   ,  event   )   "], ["Event event", " if (  event   instanceof Cancellable ) ", " if (  &&  isIgnoringCancelled (  )    ) ", " executor.execute (  listener   ,  event   )   "], ["Event event", " if (  event   instanceof Cancellable ) ", " if (  &&  isIgnoringCancelled (  )    ) ", " return "]]
[["int nodePointer", " if (  mWebView   ==  null   ) ", " Message.obtain (  mWebView.mPrivateHandler   ,  WebView.FORM_DID_BLUR   ,  nodePointer   ,  NUM_   )   . sendToTarget (  )   "], ["int nodePointer", " if (  mWebView   ==  null   ) ", " return "]]
[["CharSequenceTranslator translators", "  translators    . translators   =  translators.clone (  )   "]]
[["int array", "List integers =  new ArrayList (  )   ", "for (  ;  i   <  array.length   ;  i ++  ) ", " integers.add (  array   [  i   ] )   "], ["int array", "List integers =  new ArrayList (  )   ", "for (  ;  i   <  array.length   ;  i ++  ) ", " integers.add (  array   [  i   ] )   ", " return  integers  "]]
[[" Config.registerSelf (  SocketCommandProcessor    )   ", " port   =  Config.parms.getInt (  STR_   )   "]]
[["String vertexSource , String fragmentSource", " mVShaderHandle   =  loadShader (  GLES20.GL_VERTEX_SHADER   ,  vertexSource   )   ", " if (  mVShaderHandle   ==  NUM_   ) ", " mFShaderHandle   =  loadShader (  GLES20.GL_FRAGMENT_SHADER   ,  fragmentSource   )   ", " if (  mFShaderHandle   ==  NUM_   ) ", " return  NUM_  "], ["String vertexSource , String fragmentSource", " mVShaderHandle   =  loadShader (  GLES20.GL_VERTEX_SHADER   ,  vertexSource   )   ", " if (  mVShaderHandle   ==  NUM_   ) ", " mFShaderHandle   =  loadShader (  GLES20.GL_FRAGMENT_SHADER   ,  fragmentSource   )   ", " if (  mFShaderHandle   ==  NUM_   ) ", "int program =  GLES20.glCreateProgram (  )   ", " if (  program   !=  NUM_   ) ", " GLES20.glAttachShader (  program   ,  mVShaderHandle   )   ", " GLES20.glAttachShader (  program   ,  mFShaderHandle   )   ", " GLES20.glLinkProgram (  program   )   ", "int linkStatus =  new int [  NUM_   ]   ", " GLES20.glGetProgramiv (  program   ,  GLES20.GL_LINK_STATUS   ,  linkStatus   ,  NUM_   )   ", " if (  linkStatus   [  NUM_   ] !=  GLES20.GL_TRUE   ) ", " RajLog.e (  STR_   +  getClass (  )   . getCanonicalName (  )    +  STR_   )   ", " RajLog.e (  GLES20.glGetProgramInfoLog (  program   )    )   ", " GLES20.glDeleteProgram (  program   )   ", " program   =  NUM_  ", " return  program  "], ["String vertexSource , String fragmentSource", " mVShaderHandle   =  loadShader (  GLES20.GL_VERTEX_SHADER   ,  vertexSource   )   ", " if (  mVShaderHandle   ==  NUM_   ) ", " mFShaderHandle   =  loadShader (  GLES20.GL_FRAGMENT_SHADER   ,  fragmentSource   )   ", " if (  mFShaderHandle   ==  NUM_   ) ", "int program =  GLES20.glCreateProgram (  )   ", " if (  program   !=  NUM_   ) ", " GLES20.glAttachShader (  program   ,  mVShaderHandle   )   ", " GLES20.glAttachShader (  program   ,  mFShaderHandle   )   ", " GLES20.glLinkProgram (  program   )   ", "int linkStatus =  new int [  NUM_   ]   ", " GLES20.glGetProgramiv (  program   ,  GLES20.GL_LINK_STATUS   ,  linkStatus   ,  NUM_   )   ", " if (  linkStatus   [  NUM_   ] !=  GLES20.GL_TRUE   ) ", " return  program  "], ["String vertexSource , String fragmentSource", " mVShaderHandle   =  loadShader (  GLES20.GL_VERTEX_SHADER   ,  vertexSource   )   ", " if (  mVShaderHandle   ==  NUM_   ) ", " mFShaderHandle   =  loadShader (  GLES20.GL_FRAGMENT_SHADER   ,  fragmentSource   )   ", " if (  mFShaderHandle   ==  NUM_   ) ", "int program =  GLES20.glCreateProgram (  )   ", " if (  program   !=  NUM_   ) ", " return  program  "], ["String vertexSource , String fragmentSource", " mVShaderHandle   =  loadShader (  GLES20.GL_VERTEX_SHADER   ,  vertexSource   )   ", " if (  mVShaderHandle   ==  NUM_   ) ", " return  NUM_  "]]
[["IllegalArgumentException expected =  expectThrows (  IllegalArgumentException    ,  null   )   ", " assertTrue (  expected.getMessage (  )   . contains (  STR_   )    )   "]]
[[" return  new com.sun.identity.wsfederation.jaxb.wsspolicy.impl.WssRelV20Token10ElementImpl (  )   "]]
[]
[["Catbert.FastStack stack", " if (  stack.getUIMgr (  )    !=  null   &&  stack.getUIMgr (  )   . getUIClientType (  )    ==  UIClient.REMOTE_UI   &&  stack.getUIMgr (  )   . getRootPanel (  )   . getRenderEngine (  )    instanceof MiniClientSageRenderer ) ", " return  null  "], ["Catbert.FastStack stack", " if (  stack.getUIMgr (  )    !=  null   &&  stack.getUIMgr (  )   . getUIClientType (  )    ==  UIClient.REMOTE_UI   &&  stack.getUIMgr (  )   . getRootPanel (  )   . getRenderEngine (  )    instanceof MiniClientSageRenderer ) ", " return "]]
[[" currBuf   =  NUM_  ", " currBufIdx   = - NUM_  ", " bufPosition   =  NUM_  ", " bufStart   =  NUM_  ", " bufLength   =  NUM_  ", " file.setLength (  NUM_   )   "]]
[["String path , ParameterMap params", "   ", "  httpMethod    . httpMethod   =  HttpMethod.DELETE  "]]
[["String message", " logger.info (  logPrefix   +  message   )   "]]
[["HistoryChangedListener l", " m_HistoryChangedListeners.add (  l   )   "]]
[[" onAction (  ActionType.LOOK_CLOSELY   )   "]]
[[" return  new com.sun.identity.liberty.ws.common.jaxb.utility.impl.ReceivedElementImpl (  )   "]]
[["ClassDescriptor classDescriptor", " add (  ClassAnnotation.fromClassDescriptor (  classDescriptor   )    )   ", " return    "]]
[["String name", " return  validateImportDeclaration (  name   ,  CompilerOptions.VERSION_1_3   ,  CompilerOptions.VERSION_1_3   )   "]]
[["Component comp", " removeConstraints (  comp   )   "]]
[["T config", " config.addCredentials (     )   ", "String xml =  POST (   url    . url   +  STR_   +  config.getType (  )    ,  config.toXML (  )    )   ", "Element root =  parse (  xml   )   ", " if (  root   ==  null   ) ", " config   = ", " config.parseXML (  root   )   ", " return  config  "], ["T config", " config.addCredentials (     )   ", "String xml =  POST (   url    . url   +  STR_   +  config.getType (  )    ,  config.toXML (  )    )   ", "Element root =  parse (  xml   )   ", " if (  root   ==  null   ) ", " return  null  "]]
[["double latitude , double longitude", " setCoordinates (  latitude   ,  longitude   )   "]]
[["Path parent", " if (  parent   ==  null   ) ", " new FileNotFoundException (  )   ", "  name    . name   =  parent.toString (  )   ", "Path pathPath =  parent  ", " path   =  pathPath.toString (  )   ", " isDir   =  BOOL_  ", " isRoot   =  BOOL_  ", " setUserObject (   name    . name   )   "], ["Path parent", " if (  parent   ==  null   ) ", "  name    . name   =  parent.toString (  )   ", "Path pathPath =  parent  ", " path   =  pathPath.toString (  )   ", " isDir   =  BOOL_  ", " isRoot   =  BOOL_  ", " setUserObject (   name    . name   )   "]]
[[" return  amIActive  "]]
[["ParseOperationSet other", "for ( String key :  other.keySet (  )    )", "ParseFieldOperation operation1 =  other.get (  key   )   ", "ParseFieldOperation operation2 =  get (  key   )   ", " if (  operation2   !=  null   ) ", " operation2   =  operation2.mergeWithPrevious (  operation1   )   ", " put (  key   ,  operation2   )   "], ["ParseOperationSet other", "for ( String key :  other.keySet (  )    )", "ParseFieldOperation operation1 =  other.get (  key   )   ", "ParseFieldOperation operation2 =  get (  key   )   ", " if (  operation2   !=  null   ) ", " operation2   =  operation1  ", " put (  key   ,  operation2   )   "]]
[["Document document , String elementName", "String value =  STR_  ", "NodeList nodeList =  document.getElementsByTagName (  elementName   )   ", " if (  nodeList.getLength (  )    >  NUM_   ) ", " return  value  "], ["Document document , String elementName", "String value =  STR_  ", "NodeList nodeList =  document.getElementsByTagName (  elementName   )   ", " if (  nodeList.getLength (  )    >  NUM_   ) ", " value   =  nodeList.item (  NUM_   )   . getTextContent (  )   ", " return  value  "]]
[["String prefix , FileDescriptor fd , PrintWriter writer , String args", " delegate.dump (  prefix   ,  fd   ,  writer   ,  args   )   "]]
[["int index , Object d", " if (  index   <  size   ) ", " return "], ["int index , Object d", " if (  index   <  size   ) ", "int oldSize =  size   , capacity =  vector.length  ", " size   =  index   +  NUM_  ", " if (  capacity   >=  size   ) ", " return "], ["int index , Object d", " if (  index   <  size   ) ", "int oldSize =  size   , capacity =  vector.length  ", " size   =  index   +  NUM_  ", " if (  capacity   >=  size   ) ", "while (  capacity   <  size   )", " capacity   *=  NUM_  "], ["int index , Object d", " if (  index   <  size   ) ", "int oldSize =  size   , capacity =  vector.length  ", " size   =  index   +  NUM_  ", " if (  capacity   >=  size   ) ", "while (  capacity   <  size   )", " capacity   *=  NUM_  ", "Object t =  new Object [  capacity   ]   ", " System.arraycopy (  vector   ,  NUM_   ,  t   ,  NUM_   ,  oldSize   )   ", " if (  d   !=  null   ) ", " vector   =  t  "], ["int index , Object d", " if (  index   <  size   ) ", "int oldSize =  size   , capacity =  vector.length  ", " size   =  index   +  NUM_  ", " if (  capacity   >=  size   ) ", "while (  capacity   <  size   )", " capacity   *=  NUM_  ", "Object t =  new Object [  capacity   ]   ", " System.arraycopy (  vector   ,  NUM_   ,  t   ,  NUM_   ,  oldSize   )   ", " if (  d   !=  null   ) ", " Arrays.fill (  t   ,  oldSize   ,  size   ,  d   )   ", " vector   =  t  "]]
[["String uuid , RetrieveInfo ri", "LoadElementByUuid loadByUuid =  new LoadElementByUuid (  uuid   ,  ri   )   ", " loadByUuid   =  commandService.executeCommand (  loadByUuid   )   ", "CnATreeElement element =  loadByUuid.getElement (  )   ", " assertNotNull (  STR_   +  uuid   ,  element   )   ", "RetrieveCnATreeElement retrieveCommand =  new RetrieveCnATreeElement (  element.getTypeId (  )    ,  element.getDbId (  )    ,  RetrieveInfo.getChildrenInstance (  )    )   ", " retrieveCommand   =  commandService.executeCommand (  retrieveCommand   )   ", "CnATreeElement elementWithChildren =  retrieveCommand.getElement (  )   ", " assertNotNull (  STR_   +  uuid   ,  elementWithChildren   )   ", " assertNotNull (  STR_   +  uuid   ,  elementWithChildren.getChildren (  )    )   ", "LoadElementForEditor loadForEditor =  new LoadElementForEditor (  element   ,  BOOL_   )   ", " loadForEditor   =  ServiceFactory.lookupCommandService (  )   . executeCommand (  loadForEditor   )   ", " element   =  loadForEditor.getElement (  )   ", " assertNotNull (  STR_   +  uuid   ,  element   )   ", " element.setChildren (  elementWithChildren.getChildren (  )    )   ", " return  element  "]]
[["NetUtils.NetType type"]]
[["TransactionConfidenceEventListener listener", " addTransactionConfidenceEventListener (  Threading.USER_THREAD   ,  listener   )   "]]
[["String targetObjectId", " jsonValue.put (  TARGET_OBJECT_ID   ,  targetObjectId   )   ", " return  self (  )   "]]
[["Object items =   items    . items  ", "E x", " items   [  takeIndex   ] =  null  ", " takeIndex   =  inc (  takeIndex   )   ", " count -- ", " if (  itrs   !=  null   ) ", " notFull.signal (  )   ", " return  x  "], ["Object items =   items    . items  ", "E x", " items   [  takeIndex   ] =  null  ", " takeIndex   =  inc (  takeIndex   )   ", " count -- ", " if (  itrs   !=  null   ) ", " itrs.elementDequeued (  )   ", " notFull.signal (  )   ", " return  x  "]]
[["Object element , String columnPropertyName", "int columnIndex =  TableViewerUtils.columnPropertyNameToColumnIndex (  columnPropertyName   ,  BOOL_   ,  viewer   )   ", " viewer.editElement (  element   ,  columnIndex   )   "]]
[[" if (  secureRandom   ==  null   ) ", " secureRandom   =  new SecureRandom (  )   ", "byte cnonceBytes =  new byte [  NUM_   ]   ", " secureRandom.nextBytes (  cnonceBytes   )   ", " return  Base64.encode (  cnonceBytes   )   "], [" if (  secureRandom   ==  null   ) ", "byte cnonceBytes =  new byte [  NUM_   ]   ", " secureRandom.nextBytes (  cnonceBytes   )   ", " return  Base64.encode (  cnonceBytes   )   "]]
[["ConcreteRule base , Sequence target , PhraseAlignment align , Scorer scorer , FeatureExtractor featurizer , Sequence sourceSequence , InputProperties inputProperties , int sourceInputId", "Rule baseRule =  base.abstractRule  ", "Rule newRule =  new Rule (  baseRule.scores   ,  baseRule.phraseScoreNames   ,  target   ,  baseRule.source   ,  align   ,  PHRASE_TABLE_NAME   )   ", " newRule.reoderingScores   =  baseRule.reoderingScores  ", " newRule.forwardOrientation   =  baseRule.forwardOrientation  ", " newRule.backwardOrientation   =  baseRule.backwardOrientation  ", "ConcreteRule rule =  new ConcreteRule (  newRule   ,  base.sourceCoverage   ,  featurizer   ,  scorer   ,  sourceSequence   ,  sourceInputId   ,  inputProperties   )   ", " return  rule  "]]
[["Cursor cursor", "   ", " resetMappings (  )   "]]
[["Context context , String number", "Uri uri =  Uri.parse (  STR_   +  number   )   ", "Intent intent =  new Intent (  Intent.ACTION_CALL   ,  uri   )   ", " if (  ActivityCompat.checkSelfPermission (  context   ,  Manifest.permission.CALL_PHONE   )    !=  PackageManager.PERMISSION_GRANTED   ) ", " return "], ["Context context , String number", "Uri uri =  Uri.parse (  STR_   +  number   )   ", "Intent intent =  new Intent (  Intent.ACTION_CALL   ,  uri   )   ", " if (  ActivityCompat.checkSelfPermission (  context   ,  Manifest.permission.CALL_PHONE   )    !=  PackageManager.PERMISSION_GRANTED   ) ", " context.startActivity (  intent   )   "]]
[["PsiElement anchor , FQNamesProvider functionName", "PsiElement parent =  PsiTreeUtil.findFirstParent (  anchor   ,  new MyFunctionCondition (  functionName   )    )   ", " if (  parent   instanceof PyCallExpression ) ", " return "], ["PsiElement anchor , FQNamesProvider functionName", "PsiElement parent =  PsiTreeUtil.findFirstParent (  anchor   ,  new MyFunctionCondition (  functionName   )    )   ", " if (  parent   instanceof PyCallExpression ) ", " return  null  "]]
[["String value0 , String value1", " return  new SM_SYSTEM_MESSAGE (  NUM_   ,  value0   ,  value1   )   "]]
[["ConcurrentMap actionMap =  new ConcurrentHashMap (  NUM_   )   ", " actionMap.put (  ActionFileInto    ,  new FileIntoAction (  )    )   ", " actionMap.put (  ActionKeep    ,  new KeepAction (  )    )   ", " actionMap.put (  ActionRedirect    ,  new RedirectAction (  )    )   ", " actionMap.put (  ActionReject    ,  new RejectAction (  )    )   ", " actionMap.put (  ActionVacation    ,  new VacationAction (  )    )   ", " return  actionMap  "]]
[[" return  Collections.unmodifiableList (  mStepList   )   . iterator (  )   "]]
[["  attribute    . attribute   =  null  ", "  filterConfig    . filterConfig   =  null  "]]
[["String args", " DOMTestCase.doMain (  namednodemapreturnattrnode    ,  args   )   "]]
[[" assertNotNull (  STR_   ,  mTestActivity   )   ", " assertNotNull (  STR_   ,  mTestFragment   )   "]]
[["IMethod method", "StringBuffer buf =  new StringBuffer (  )   ", " buf.append (  STR_   )   ", " buf.append (  method.getElementName (  )    )   ", " buf.append (  STR_   )   ", "boolean first =  BOOL_  ", "for ( String paramType :  method.getParameterTypes (  )    )", " if (  first   ) ", " first   =  BOOL_  ", " buf.append (  Signature.toString (  paramType   )    )   ", " buf.append (  STR_   )   ", " return  buf.toString (  )   "], ["IMethod method", "StringBuffer buf =  new StringBuffer (  )   ", " buf.append (  STR_   )   ", " buf.append (  method.getElementName (  )    )   ", " buf.append (  STR_   )   ", "boolean first =  BOOL_  ", "for ( String paramType :  method.getParameterTypes (  )    )", " if (  first   ) ", " first   =  BOOL_  ", " buf.append (  Signature.toString (  paramType   )    )   "], ["IMethod method", "StringBuffer buf =  new StringBuffer (  )   ", " buf.append (  STR_   )   ", " buf.append (  method.getElementName (  )    )   ", " buf.append (  STR_   )   ", "boolean first =  BOOL_  ", "for ( String paramType :  method.getParameterTypes (  )    )", " if (  first   ) ", " buf.append (  STR_   )   ", " buf.append (  Signature.toString (  paramType   )    )   ", " buf.append (  STR_   )   ", " return  buf.toString (  )   "], ["IMethod method", "StringBuffer buf =  new StringBuffer (  )   ", " buf.append (  STR_   )   ", " buf.append (  method.getElementName (  )    )   ", " buf.append (  STR_   )   ", "boolean first =  BOOL_  ", "for ( String paramType :  method.getParameterTypes (  )    )", " if (  first   ) ", " buf.append (  STR_   )   ", " buf.append (  Signature.toString (  paramType   )    )   "]]
[["Object a , int fromIndex , int toIndex", " rangeCheck (  a.length   ,  fromIndex   ,  toIndex   )   ", " quickSort1 (  a   ,  fromIndex   ,  toIndex   -  fromIndex   )   "]]
[["MethodInfo mproto", " return  isMissing  ? null  : getDetails (  )   . findMethodHere (  mproto   )   "]]
[["String interfaceName , int line", " interfaceNames   !=  null  ? interfaceNames  : interfaceNames   =  new TreeSet (  )   ", " addImportName (  interfaceName   ,  line   )   "]]
[["int numRows", "List testData =  new ArrayList (  numRows   )   ", "for (  ;  i   <  numRows   ; ++ i   ) ", "ByteString key =  ByteString.copyFromUtf8 (  String.format (  STR_   ,  i   )    )   ", "ByteString value =  ByteString.copyFromUtf8 (  String.format (  STR_   ,  i   )    )   ", " testData.add (  KV.of (  key   ,  value   )    )   ", " return  testData  "], ["int numRows", "List testData =  new ArrayList (  numRows   )   ", "for (  ;  i   <  numRows   ; ++ i   ) ", "ByteString key =  ByteString.copyFromUtf8 (  String.format (  STR_   ,  i   )    )   ", "ByteString value =  ByteString.copyFromUtf8 (  String.format (  STR_   ,  i   )    )   ", " testData.add (  KV.of (  key   ,  value   )    )   "]]
[["NotThreadSafeBridgeIdleDebugListener listener", " mBridgeIdleListeners.add (  listener   )   "]]
[["double constant , double vector", " if (  constant   ==  NUM_   ) ", "for (  ;  i   <  vector.length   ;  i ++  ) ", " vector   [  i   ] *=  constant  "], ["double constant , double vector", " if (  constant   ==  NUM_   ) ", " return "]]
[[" return  stw  "]]
[[" map.clear (  )   "]]
[["OutputStream out , String encoding", "XMLObjectWriter writer =  new XMLObjectWriter (  )   ", " writer.setOutput (  out   ,  encoding   )   ", " return  writer  "]]
[[" return  isClosed  "]]
[[" if (  configPropertiesFile   !=  null   ) ", "Properties props =  new Properties (  )   ", "for ( String key :  fieldValueMap.keySet (  )    )", "String value =  fieldValueMap.get (  key   )   ", " if (  value   !=  null   ) ", "OutputStream out =  new FileOutputStream (  configPropertiesFile   )   ", " props.store (  out   ,  STR_   )   ", " out.close (  )   "], [" if (  configPropertiesFile   !=  null   ) ", "Properties props =  new Properties (  )   ", "for ( String key :  fieldValueMap.keySet (  )    )", "String value =  fieldValueMap.get (  key   )   ", " if (  value   !=  null   ) ", " props.setProperty (  key   ,  value   )   ", "OutputStream out =  new FileOutputStream (  configPropertiesFile   )   ", " props.store (  out   ,  STR_   )   ", " out.close (  )   "], [" if (  configPropertiesFile   !=  null   ) ", "Properties props =  new Properties (  )   ", "for ( String key :  fieldValueMap.keySet (  )    )", "String value =  fieldValueMap.get (  key   )   ", " if (  value   !=  null   ) ", " props.setProperty (  key   ,  value   )   "], [" if (  configPropertiesFile   !=  null   ) ", "Properties props =  new Properties (  )   ", "for ( String key :  fieldValueMap.keySet (  )    )", "String value =  fieldValueMap.get (  key   )   ", " if (  value   !=  null   ) "]]
[["UploadSingleInitiationRequest uploadSingleInitiationRequest", "UploadSingleInitiationResponse uploadSingleInitiationResponse =  uploadDownloadService.initiateUploadSingle (  uploadSingleInitiationRequest   )   ", "for ( BusinessObjectData businessObjectData :  Arrays.asList (  uploadSingleInitiationResponse.getSourceBusinessObjectData (  )    ,  uploadSingleInitiationResponse.getTargetBusinessObjectData (  )    )    )", "BusinessObjectDataKey businessObjectDataKey =  businessObjectDataHelper.getBusinessObjectDataKey (  businessObjectData   )   ", "for ( NotificationEventTypeEntity.EventTypesBdata eventType :  Arrays.asList (  NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_RGSTN   ,  NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_STTS_CHG   )    )", " notificationEventService.processBusinessObjectDataNotificationEventAsync (  eventType   ,  businessObjectDataKey   ,  businessObjectData.getStatus (  )    ,  null   )   ", "for ( StorageUnit storageUnit :  businessObjectData.getStorageUnits (  )    )", " notificationEventService.processStorageUnitNotificationEventAsync (  NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG   ,  businessObjectDataKey   ,  storageUnit.getStorage (  )   . getName (  )    ,  storageUnit.getStorageUnitStatus (  )    ,  null   )   "], ["UploadSingleInitiationRequest uploadSingleInitiationRequest", "UploadSingleInitiationResponse uploadSingleInitiationResponse =  uploadDownloadService.initiateUploadSingle (  uploadSingleInitiationRequest   )   ", "for ( BusinessObjectData businessObjectData :  Arrays.asList (  uploadSingleInitiationResponse.getSourceBusinessObjectData (  )    ,  uploadSingleInitiationResponse.getTargetBusinessObjectData (  )    )    )", "BusinessObjectDataKey businessObjectDataKey =  businessObjectDataHelper.getBusinessObjectDataKey (  businessObjectData   )   ", "for ( NotificationEventTypeEntity.EventTypesBdata eventType :  Arrays.asList (  NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_RGSTN   ,  NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_STTS_CHG   )    )", " notificationEventService.processBusinessObjectDataNotificationEventAsync (  eventType   ,  businessObjectDataKey   ,  businessObjectData.getStatus (  )    ,  null   )   ", "for ( StorageUnit storageUnit :  businessObjectData.getStorageUnits (  )    )", " notificationEventService.processStorageUnitNotificationEventAsync (  NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG   ,  businessObjectDataKey   ,  storageUnit.getStorage (  )   . getName (  )    ,  storageUnit.getStorageUnitStatus (  )    ,  null   )   ", " return  uploadSingleInitiationResponse  "], ["UploadSingleInitiationRequest uploadSingleInitiationRequest", "UploadSingleInitiationResponse uploadSingleInitiationResponse =  uploadDownloadService.initiateUploadSingle (  uploadSingleInitiationRequest   )   ", "for ( BusinessObjectData businessObjectData :  Arrays.asList (  uploadSingleInitiationResponse.getSourceBusinessObjectData (  )    ,  uploadSingleInitiationResponse.getTargetBusinessObjectData (  )    )    )", "BusinessObjectDataKey businessObjectDataKey =  businessObjectDataHelper.getBusinessObjectDataKey (  businessObjectData   )   ", "for ( NotificationEventTypeEntity.EventTypesBdata eventType :  Arrays.asList (  NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_RGSTN   ,  NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_STTS_CHG   )    )", " notificationEventService.processBusinessObjectDataNotificationEventAsync (  eventType   ,  businessObjectDataKey   ,  businessObjectData.getStatus (  )    ,  null   )   "]]
[[" thrown.expect (  IllegalArgumentException    )   ", " new User (  null   )   "]]
[["int index , long l", " return   writeULong (  index   ,  l   )     . writeULong (  index   ,  l   )   "]]
[["ActionEvent ev", " executeImmediately (  STR_   )   "]]
[["String domainName", " if (  UrlUtils.isASCII (  domainName   )    ) ", " return  UrlUtils.toPunycode (  domainName   )   "], ["String domainName", " if (  UrlUtils.isASCII (  domainName   )    ) ", " return  domainName  "]]
[["double x , double mu , double sigma , double lambda", "double dx =  x   -  mu  ", "double lss =  lambda   *  sigma   *  sigma  ", "double erfc =  NormalDistribution.erfc (  lss   -  dx   /  sigma   *  MathUtil.SQRT2   )   ", " return  erfc   >  NUM_  ? NUM_   *  lambda   *  Math.exp (  lambda   *  lss   *  NUM_   -  dx   )    *  erfc  : NUM_  "]]
[[" return ! isAffineLoop (  )   "]]
[["String message", " if (  myHost   !=  null   ) ", " myHost.showFeedback (  message   )   "], ["String message", " if (  myHost   !=  null   ) ", " System.out.println (  message   )   "]]
[["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  GREATER_THAN  ", " if ( ! parameters.isEmpty (  )    ) ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  GREATER_THAN  ", " if ( ! parameters.isEmpty (  )    ) ", " retval   +=  SEMICOLON   +  parameters.encode (  )   ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " if ( ! parameters.isEmpty (  )    ) ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " if ( ! parameters.isEmpty (  )    ) ", " retval   +=  SEMICOLON   +  parameters.encode (  )   ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  LESS_THAN  ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  GREATER_THAN  ", " if ( ! parameters.isEmpty (  )    ) ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  LESS_THAN  ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  GREATER_THAN  ", " if ( ! parameters.isEmpty (  )    ) ", " retval   +=  SEMICOLON   +  parameters.encode (  )   ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  LESS_THAN  ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " if ( ! parameters.isEmpty (  )    ) ", " return  retval  "], ["String retval =  STR_  ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " retval   +=  LESS_THAN  ", " retval   +=  address.encode (  )   ", " if (  address.getAddressType (  )    ==  AddressImpl.ADDRESS_SPEC   ) ", " if ( ! parameters.isEmpty (  )    ) ", " retval   +=  SEMICOLON   +  parameters.encode (  )   ", " return  retval  "]]
[["int modifiers", " return  modifiers   &  ACCESS_TEST   ==  NUM_  "]]
[["String type", "JSONObject action =  new JSONObject (  )   ", " if (  type   !=  null   ) ", " return  action  "], ["String type", "JSONObject action =  new JSONObject (  )   ", " if (  type   !=  null   ) ", " action.put (  STR_   ,  type   )   ", " return  action  "]]
[["long n", " if (  n   <=  NUM_   ) ", " return  NUM_  "], ["long n", " if (  n   <=  NUM_   ) ", "int adj =  NUM_  ", " if (  isBack   ) ", "long pos", "long len", "long newpos", " pos   =  getPosition (  )   ", " len   =  length (  )   ", " newpos   =  pos   +  n  ", " if (  newpos   >  len   ) ", " newpos   =  len  ", " seek (  newpos   )   ", " return  newpos   -  pos   +  adj  "], ["long n", " if (  n   <=  NUM_   ) ", "int adj =  NUM_  ", " if (  isBack   ) ", "long pos", "long len", "long newpos", " pos   =  getPosition (  )   ", " len   =  length (  )   ", " newpos   =  pos   +  n  ", " if (  newpos   >  len   ) ", " seek (  newpos   )   ", " return  newpos   -  pos   +  adj  "], ["long n", " if (  n   <=  NUM_   ) ", "int adj =  NUM_  ", " if (  isBack   ) ", " isBack   =  BOOL_  ", " if (  n   ==  NUM_   ) ", " return  NUM_  "], ["long n", " if (  n   <=  NUM_   ) ", "int adj =  NUM_  ", " if (  isBack   ) ", " isBack   =  BOOL_  ", " if (  n   ==  NUM_   ) ", "-- n  ", " adj   =  NUM_  ", "long pos", "long len", "long newpos", " pos   =  getPosition (  )   ", " len   =  length (  )   ", " newpos   =  pos   +  n  ", " if (  newpos   >  len   ) ", " newpos   =  len  ", " seek (  newpos   )   ", " return  newpos   -  pos   +  adj  "], ["long n", " if (  n   <=  NUM_   ) ", "int adj =  NUM_  ", " if (  isBack   ) ", " isBack   =  BOOL_  ", " if (  n   ==  NUM_   ) ", "-- n  ", " adj   =  NUM_  ", "long pos", "long len", "long newpos", " pos   =  getPosition (  )   ", " len   =  length (  )   ", " newpos   =  pos   +  n  ", " if (  newpos   >  len   ) ", " seek (  newpos   )   ", " return  newpos   -  pos   +  adj  "]]
[[" return  new EWMA (  M5_ALPHA   ,  NUM_   ,  TimeUnit.SECONDS   )   "]]
[[" MessageDigest.getInstance (  STR_   )   . update (  new byte [  ]    ,  Integer.MAX_VALUE   ,  Integer.MAX_VALUE   )   ", " fail (  )   "]]
[["String name", "   "]]
[["URI mirrorUri , String evtType , Operation.Status status , String description", " VplexMirrorTaskCompleter.recordBourneVplexMirrorEvent (  _dbClient   ,  mirrorUri   ,  evtType   ,  status   ,  description   )   "]]
[[" if ( ! hasNext (  GSER_INTEGER   )    ) ", "LocalizableMessage msg =  WARN_GSER_NO_VALID_INTEGER.get (  gserValue.substring (  pos   ,  length   )    )   ", " DecodeException.error (  msg   )   ", " return  new BigInteger (  next (  GSER_INTEGER   )    )   "], [" if ( ! hasNext (  GSER_INTEGER   )    ) ", " return  new BigInteger (  next (  GSER_INTEGER   )    )   "]]
[["InternalDistributedMember member , PersistentMemberID persistentID", "  membershipChanged    . membershipChanged   =  BOOL_  "]]
[[" debugCodeCall (  STR_   )   ", " return  BOOL_  "]]
[["String string", " if (  string   ==  null   ) ", " new JSONException (  STR_   )   ", " if (   mode    . mode   ==  STR_   ) ", " new JSONException (  STR_   )   "], ["String string", " if (  string   ==  null   ) ", " new JSONException (  STR_   )   ", " if (   mode    . mode   ==  STR_   ) ", "  stack   , [   top    . top   -  NUM_   ] ,  putOnce (  string   ,  Boolean.TRUE   )     . stack   [   top    . top   -  NUM_   ]. putOnce (  string   ,  Boolean.TRUE   )   ", " if (   comma    . comma   ) ", "  writer   ,  write (  JSONObject.quote (  string   )    )     . writer  . write (  JSONObject.quote (  string   )    )   ", "  writer   ,  write (  STR_   )     . writer  . write (  STR_   )   ", "  comma    . comma   =  BOOL_  ", "  mode    . mode   =  STR_  ", " return    "], ["String string", " if (  string   ==  null   ) ", " new JSONException (  STR_   )   ", " if (   mode    . mode   ==  STR_   ) ", "  stack   , [   top    . top   -  NUM_   ] ,  putOnce (  string   ,  Boolean.TRUE   )     . stack   [   top    . top   -  NUM_   ]. putOnce (  string   ,  Boolean.TRUE   )   ", " if (   comma    . comma   ) ", "  writer   ,  write (  STR_   )     . writer  . write (  STR_   )   ", "  writer   ,  write (  JSONObject.quote (  string   )    )     . writer  . write (  JSONObject.quote (  string   )    )   ", "  writer   ,  write (  STR_   )     . writer  . write (  STR_   )   ", "  comma    . comma   =  BOOL_  ", "  mode    . mode   =  STR_  ", " return    "], ["String string", " if (  string   ==  null   ) ", " if (   mode    . mode   ==  STR_   ) ", " new JSONException (  STR_   )   "], ["String string", " if (  string   ==  null   ) ", " if (   mode    . mode   ==  STR_   ) ", "  stack   , [   top    . top   -  NUM_   ] ,  putOnce (  string   ,  Boolean.TRUE   )     . stack   [   top    . top   -  NUM_   ]. putOnce (  string   ,  Boolean.TRUE   )   ", " if (   comma    . comma   ) ", "  writer   ,  write (  JSONObject.quote (  string   )    )     . writer  . write (  JSONObject.quote (  string   )    )   ", "  writer   ,  write (  STR_   )     . writer  . write (  STR_   )   ", "  comma    . comma   =  BOOL_  ", "  mode    . mode   =  STR_  ", " return    "], ["String string", " if (  string   ==  null   ) ", " if (   mode    . mode   ==  STR_   ) ", "  stack   , [   top    . top   -  NUM_   ] ,  putOnce (  string   ,  Boolean.TRUE   )     . stack   [   top    . top   -  NUM_   ]. putOnce (  string   ,  Boolean.TRUE   )   ", " if (   comma    . comma   ) ", "  writer   ,  write (  STR_   )     . writer  . write (  STR_   )   ", "  writer   ,  write (  JSONObject.quote (  string   )    )     . writer  . write (  JSONObject.quote (  string   )    )   ", "  writer   ,  write (  STR_   )     . writer  . write (  STR_   )   ", "  comma    . comma   =  BOOL_  ", "  mode    . mode   =  STR_  ", " return    "]]
[["Launch launch , EmailSenderCase oneCase", " return  null   !=  oneCase.getTags (  )    && ! oneCase.getTags (  )   . isEmpty (  )    ||  null   !=  launch.getTags (  )    &&  oneCase.getTags (  )   . containsAll (  launch.getTags (  )    )   "]]
[["Comparator cmp", "   "]]
[[" return  getInstance (  )   . trackFreedReferenceCounts (  )   "]]
[["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case INT", " return  org.apache.carbondata.format.DataType.INT  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case TIMESTAMP", " return  org.apache.carbondata.format.DataType.TIMESTAMP  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case DOUBLE", " return  org.apache.carbondata.format.DataType.DOUBLE  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case ", " return  org.apache.carbondata.format.DataType.STRING  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case STRING", " return  org.apache.carbondata.format.DataType.STRING  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case ARRAY", " return  org.apache.carbondata.format.DataType.ARRAY  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case STRUCT", " return  org.apache.carbondata.format.DataType.STRUCT  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case DECIMAL", " return  org.apache.carbondata.format.DataType.DECIMAL  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case LONG", " return  org.apache.carbondata.format.DataType.LONG  "], ["DataType dataType", " if (  null   ==  dataType   ) ", " switch (  dataType   ) ", " case SHORT", " return  org.apache.carbondata.format.DataType.SHORT  "]]
[["FeatureProvider featureProvider", "  _featureProvider    . _featureProvider   =  featureProvider  ", " return    "]]
[["LuaTable table", "JSONObject obj =  toJSONObject (  table   )   ", " return  obj.toString (  NUM_   )   "]]
[[" return  EncodingUtils.testBit (  __isset_bitfield   ,  __TRANSACTIONID_ISSET_ID   )   "]]
[["X509Certificate cert , Set trustAnchors", " return  findTrustAnchor (  cert   ,  trustAnchors   ,  null   )   "]]
[["String name", "   "]]
[["List l", "int len =  l.size (  )   ", "String ret =  new String [  len   ]   ", "for (  ;  i   <  len   ;  i ++  ) ", " ret   [  i   ] =  l.get (  i   )   . toString (  )   "], ["List l", "int len =  l.size (  )   ", "String ret =  new String [  len   ]   ", "for (  ;  i   <  len   ;  i ++  ) ", " ret   [  i   ] =  l.get (  i   )   . toString (  )   ", " return  ret  "]]
[["String className", " if (  toTestClasses.isEmpty (  )    ) ", " computeInterestingClasses (  graph   )   ", " if (  toTestClasses.contains (  className   )    ) ", " return  BOOL_  "], ["String className", " if (  toTestClasses.isEmpty (  )    ) ", " computeInterestingClasses (  graph   )   ", " if (  toTestClasses.contains (  className   )    ) ", " return  BOOL_  "], ["String className", " if (  toTestClasses.isEmpty (  )    ) ", " if (  toTestClasses.contains (  className   )    ) ", " return  BOOL_  "], ["String className", " if (  toTestClasses.isEmpty (  )    ) ", " if (  toTestClasses.contains (  className   )    ) ", " return  BOOL_  "]]
[["String key", "Key k =  new Key (  key   )   ", " options.remove (  key   )   ", "HashSet on =  optionNames.get (  k.getSectionName (  )    )   ", " if (  on   !=  null   ) ", " on.remove (  k.getOptionName (  )    )   ", " if (  on.isEmpty (  )    ) ", " cleanupSection (  k.getSectionName (  )    )   "]]
[["ChildState cs", " minorChanged   =  BOOL_  "]]
[["String inetAddress", " return  isValidInet4Address (  inetAddress   )    ||  isValidInet6Address (  inetAddress   )   "]]
[["long l", " return  l   &  NUM_   <<  NUM_   |  l   &  NUM_   <<  NUM_   |  l   &  NUM_   <<  NUM_   |  l   &  NUM_   <<  NUM_   |  l   >>>  NUM_   &  NUM_   |  l   >>>  NUM_   &  NUM_   |  l   >>>  NUM_   &  NUM_   |  l   >>>  NUM_   &  NUM_  "]]
[["while (  nextLine (  )    )", " if (  comment   ==  null   || ! comment.reset (  buf   )   . matches (  )    ) ", " tokenizer.initialize (  buf   ,  NUM_   ,  buf.length (  )    )   ", " return  BOOL_  "], ["while (  nextLine (  )    )", " if (  comment   ==  null   || ! comment.reset (  buf   )   . matches (  )    ) "], ["while (  nextLine (  )    )", " if (  comment   ==  null   || ! comment.reset (  buf   )   . matches (  )    ) ", " return  BOOL_  "]]
[["String filename", " if (  filename   ==  null   ) ", "  addElevations (  new File (  filename   )    )     . addElevations (  new File (  filename   )    )   "], ["String filename", " if (  filename   ==  null   ) ", "String message =  Logging.getMessage (  STR_   )   ", " Logging.logger (  )   . severe (  message   )   ", " new IllegalArgumentException (  message   )   ", "  addElevations (  new File (  filename   )    )     . addElevations (  new File (  filename   )    )   "]]
[["byte in , int sizeLimit", "ByteArrayOutputStream outStream =  new ByteArrayOutputStream (  EXPECTED_COMPRESSION_RATIO   *  in.length   )   ", "GZIPInputStream inStream =  new GZIPInputStream (  new ByteArrayInputStream (  in   )    )   ", "byte buf =  new byte [  BUF_SIZE   ]   ", "int written =  NUM_  ", "while (  BOOL_   )", "int size =  inStream.read (  buf   )   ", " if (  size   <=  NUM_   ) ", " if (  written   +  size   >  sizeLimit   ) ", " outStream.write (  buf   ,  NUM_   ,  sizeLimit   -  written   )   ", " outStream.write (  buf   ,  NUM_   ,  size   )   ", " written   +=  size  ", " outStream.close (  )   ", " return  outStream.toByteArray (  )   "], ["byte in , int sizeLimit", "ByteArrayOutputStream outStream =  new ByteArrayOutputStream (  EXPECTED_COMPRESSION_RATIO   *  in.length   )   ", "GZIPInputStream inStream =  new GZIPInputStream (  new ByteArrayInputStream (  in   )    )   ", "byte buf =  new byte [  BUF_SIZE   ]   ", "int written =  NUM_  ", "while (  BOOL_   )", "int size =  inStream.read (  buf   )   ", " if (  size   <=  NUM_   ) ", " if (  written   +  size   >  sizeLimit   ) ", " outStream.write (  buf   ,  NUM_   ,  sizeLimit   -  written   )   ", " outStream.write (  buf   ,  NUM_   ,  size   )   ", " written   +=  size  "], ["byte in , int sizeLimit", "ByteArrayOutputStream outStream =  new ByteArrayOutputStream (  EXPECTED_COMPRESSION_RATIO   *  in.length   )   ", "GZIPInputStream inStream =  new GZIPInputStream (  new ByteArrayInputStream (  in   )    )   ", "byte buf =  new byte [  BUF_SIZE   ]   ", "int written =  NUM_  ", "while (  BOOL_   )", "int size =  inStream.read (  buf   )   ", " if (  size   <=  NUM_   ) ", " if (  written   +  size   >  sizeLimit   ) ", " outStream.write (  buf   ,  NUM_   ,  size   )   ", " written   +=  size  ", " outStream.close (  )   ", " return  outStream.toByteArray (  )   "], ["byte in , int sizeLimit", "ByteArrayOutputStream outStream =  new ByteArrayOutputStream (  EXPECTED_COMPRESSION_RATIO   *  in.length   )   ", "GZIPInputStream inStream =  new GZIPInputStream (  new ByteArrayInputStream (  in   )    )   ", "byte buf =  new byte [  BUF_SIZE   ]   ", "int written =  NUM_  ", "while (  BOOL_   )", "int size =  inStream.read (  buf   )   ", " if (  size   <=  NUM_   ) ", " if (  written   +  size   >  sizeLimit   ) ", " outStream.write (  buf   ,  NUM_   ,  size   )   ", " written   +=  size  "]]
[["GraphicAttributes ga", " createGraphic (  ga   )   "]]
[]
[["User user", " users.remove (  user   )   "]]
[[" if (  heartbeatTimer   !=  null   ) ", " LOGGER.debug (  STR_   ,  context.getCluster (  )   . member (  )   . address (  )    )   ", " heartbeatTimer.cancel (  )   "]]
[[" mActionBarHeaderPullingProgressLayout.setVisibility (  View.INVISIBLE   )   ", " mActionBarHeaderRefreshingProgressBar.setVisibility (  View.VISIBLE   )   "]]
[]
[["XmlPullParser parser , InputStream gpxIn", "List latLngs =  new ArrayList (  )   ", " parser.setInput (  gpxIn   ,  null   )   ", " parser.nextTag (  )   ", "while (  parser.next (  )    !=  XmlPullParser.END_DOCUMENT   )", " if (  parser.getEventType (  )    !=  XmlPullParser.START_TAG   ) ", " if (  parser.getName (  )   . equals (  STR_   )    ) ", " return  latLngs  "], ["XmlPullParser parser , InputStream gpxIn", "List latLngs =  new ArrayList (  )   ", " parser.setInput (  gpxIn   ,  null   )   ", " parser.nextTag (  )   ", "while (  parser.next (  )    !=  XmlPullParser.END_DOCUMENT   )", " if (  parser.getEventType (  )    !=  XmlPullParser.START_TAG   ) ", " if (  parser.getName (  )   . equals (  STR_   )    ) "], ["XmlPullParser parser , InputStream gpxIn", "List latLngs =  new ArrayList (  )   ", " parser.setInput (  gpxIn   ,  null   )   ", " parser.nextTag (  )   ", "while (  parser.next (  )    !=  XmlPullParser.END_DOCUMENT   )", " if (  parser.getEventType (  )    !=  XmlPullParser.START_TAG   ) ", " if (  parser.getName (  )   . equals (  STR_   )    ) ", " latLngs.add (  new LatLng (  Double.valueOf (  parser.getAttributeValue (  null   ,  STR_   )    )    ,  Double.valueOf (  parser.getAttributeValue (  null   ,  STR_   )    )    )    )   ", " return  latLngs  "], ["XmlPullParser parser , InputStream gpxIn", "List latLngs =  new ArrayList (  )   ", " parser.setInput (  gpxIn   ,  null   )   ", " parser.nextTag (  )   ", "while (  parser.next (  )    !=  XmlPullParser.END_DOCUMENT   )", " if (  parser.getEventType (  )    !=  XmlPullParser.START_TAG   ) ", " if (  parser.getName (  )   . equals (  STR_   )    ) ", " latLngs.add (  new LatLng (  Double.valueOf (  parser.getAttributeValue (  null   ,  STR_   )    )    ,  Double.valueOf (  parser.getAttributeValue (  null   ,  STR_   )    )    )    )   "]]
[["int dims", "  table    . table   =  new MultiDimIntTable (  dims   )   "]]
[["Element el , String attributeUser , String attributePassword , Credentials defaultCredentials", "String user =  el.getAttribute (  attributeUser   )   ", "String pass =  el.getAttribute (  attributePassword   )   ", " if (  user   ==  null   ) ", " return  defaultCredentials  "], ["Element el , String attributeUser , String attributePassword , Credentials defaultCredentials", "String user =  el.getAttribute (  attributeUser   )   ", "String pass =  el.getAttribute (  attributePassword   )   ", " if (  user   ==  null   ) ", " if (  pass   ==  null   ) ", " pass   =  STR_  ", " return  CredentialsImpl.toCredentials (  user   ,  pass   )   "], ["Element el , String attributeUser , String attributePassword , Credentials defaultCredentials", "String user =  el.getAttribute (  attributeUser   )   ", "String pass =  el.getAttribute (  attributePassword   )   ", " if (  user   ==  null   ) ", " if (  pass   ==  null   ) ", " return  CredentialsImpl.toCredentials (  user   ,  pass   )   "]]
[["boolean disableNotification", "  disableNotification    . disableNotification   =  disableNotification  ", " return    "]]
[["int chunkX , int chunkY , int chunksPerFragmentX , int chunksPerFragmentY", "List result =  new LinkedList (  )   ", "for (  ;  y   <=  chunksPerFragmentY   +  SURROUNDING_CHUNKS   ;  y ++  ) ", "for (  ;  x   <=  chunksPerFragmentX   +  SURROUNDING_CHUNKS   ;  x ++  ) ", "EndIsland island =  tryCreateEndIsland (  chunkX   +  x   ,  chunkY   +  y   )   ", " if (  island   !=  null   ) "], ["int chunkX , int chunkY , int chunksPerFragmentX , int chunksPerFragmentY", "List result =  new LinkedList (  )   ", "for (  ;  y   <=  chunksPerFragmentY   +  SURROUNDING_CHUNKS   ;  y ++  ) ", "for (  ;  x   <=  chunksPerFragmentX   +  SURROUNDING_CHUNKS   ;  x ++  ) ", "EndIsland island =  tryCreateEndIsland (  chunkX   +  x   ,  chunkY   +  y   )   ", " if (  island   !=  null   ) ", " result.add (  island   )   "], ["int chunkX , int chunkY , int chunksPerFragmentX , int chunksPerFragmentY", "List result =  new LinkedList (  )   ", "for (  ;  y   <=  chunksPerFragmentY   +  SURROUNDING_CHUNKS   ;  y ++  ) ", "for (  ;  x   <=  chunksPerFragmentX   +  SURROUNDING_CHUNKS   ;  x ++  ) ", "EndIsland island =  tryCreateEndIsland (  chunkX   +  x   ,  chunkY   +  y   )   ", " if (  island   !=  null   ) ", " result.add (  island   )   ", " return  result  "], ["int chunkX , int chunkY , int chunksPerFragmentX , int chunksPerFragmentY", "List result =  new LinkedList (  )   ", "for (  ;  y   <=  chunksPerFragmentY   +  SURROUNDING_CHUNKS   ;  y ++  ) ", "for (  ;  x   <=  chunksPerFragmentX   +  SURROUNDING_CHUNKS   ;  x ++  ) ", "EndIsland island =  tryCreateEndIsland (  chunkX   +  x   ,  chunkY   +  y   )   ", " if (  island   !=  null   ) ", " return  result  "]]
[[" return  m_Formatter.format (  getStamp (  )    )   "]]
[[" if (  isZero (  )    ) ", " return  valueOf (  NUM_   )   "], [" if (  isZero (  )    ) ", " if (  isNegative (  )    ) ", "double x =  NUM_   /  Math.sqrt (  hi   )   ", "double ax =  hi   *  x  ", "DD axdd =  valueOf (  ax   )   ", "DD diffSq =   subtract (  axdd.sqr (  )    )     . subtract (  axdd.sqr (  )    )   ", "double d2 =  diffSq.hi   *  x   *  NUM_  ", " return  axdd.add (  d2   )   "], [" if (  isZero (  )    ) ", " if (  isNegative (  )    ) ", " return  NaN  "]]
[["Window owner , String key , Collection selectionValues , T initialSelectionValue , InputValidator inputValidator , Object keyArguments", "   ", "  inputValidator    . inputValidator   =  inputValidator  ", "  okButton    . okButton   =  makeOkButton (  )   ", "for ( T selectionValue :  selectionValues   )", " comboBox.addItem (  selectionValue   )   "], ["Window owner , String key , Collection selectionValues , T initialSelectionValue , InputValidator inputValidator , Object keyArguments", "   ", "  inputValidator    . inputValidator   =  inputValidator  ", "  okButton    . okButton   =  makeOkButton (  )   ", "for ( T selectionValue :  selectionValues   )", " comboBox.addItem (  selectionValue   )   ", " comboBox.setSelectedItem (  initialSelectionValue   )   ", " initGui (  )   "]]
[["String serviceName", " if (  serviceName   ==  null   ||  serviceName.length (  )    ==  NUM_   ) ", "for (  ;  i   <  reservedNames.length   ;  i ++  ) ", " if (  serviceName.startsWith (  reservedNames   [  i   ] )    ) ", " new IllegalArgumentException (  LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_RESERVED_FOR_INTERNAL_USE_ONLY.toLocalizedString (  serviceName   )    )   "], ["String serviceName", " if (  serviceName   ==  null   ||  serviceName.length (  )    ==  NUM_   ) ", "for (  ;  i   <  reservedNames.length   ;  i ++  ) ", " if (  serviceName.startsWith (  reservedNames   [  i   ] )    ) "], ["String serviceName", " if (  serviceName   ==  null   ||  serviceName.length (  )    ==  NUM_   ) ", " new IllegalArgumentException (  LocalizedStrings.DLockService_LOCK_SERVICE_NAME_MUST_NOT_BE_NULL_OR_EMPTY.toLocalizedString (  )    )   ", "for (  ;  i   <  reservedNames.length   ;  i ++  ) ", " if (  serviceName.startsWith (  reservedNames   [  i   ] )    ) ", " new IllegalArgumentException (  LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_RESERVED_FOR_INTERNAL_USE_ONLY.toLocalizedString (  serviceName   )    )   "], ["String serviceName", " if (  serviceName   ==  null   ||  serviceName.length (  )    ==  NUM_   ) ", " new IllegalArgumentException (  LocalizedStrings.DLockService_LOCK_SERVICE_NAME_MUST_NOT_BE_NULL_OR_EMPTY.toLocalizedString (  )    )   ", "for (  ;  i   <  reservedNames.length   ;  i ++  ) ", " if (  serviceName.startsWith (  reservedNames   [  i   ] )    ) "]]
[[" return "]]
[["int from , int to , java.util.Comparator c", " if (  size   ==  NUM_   ) ", " return "], ["int from , int to , java.util.Comparator c", " if (  size   ==  NUM_   ) ", " checkRangeFromTo (  from   ,  to   ,  size   )   ", " cern.colt.Sorting.quickSort (  elements   ,  from   ,  to   +  NUM_   ,  c   )   "]]
[["int k =  mDegree   -  NUM_   >>  NUM_   +  NUM_  ", "byte result =  new byte [  k   ]   ", "int i", "for (  i   =  NUM_   ;  i   <  k   ;  i ++  ) ", " result   [  k   -  i   -  NUM_   ] = ", " return  result  "], ["int k =  mDegree   -  NUM_   >>  NUM_   +  NUM_  ", "byte result =  new byte [  k   ]   ", "int i", "for (  i   =  NUM_   ;  i   <  k   ;  i ++  ) ", " result   [  k   -  i   -  NUM_   ] = "]]
[["String followerId , String followingTagId", " unfollow (  followerId   ,  followingTagId   ,  Follow.FOLLOWING_TYPE_C_TAG   )   "]]
[["UndoableEdit edit", "UndoableEditEvent event =  null  ", " if (  listenerList.getListenerCount (  )    >  NUM_   ) ", "Object listeners =  listenerList.getListenerList (  )   ", "for (  ;  i   >=  NUM_   ;  i   -=  NUM_   ) ", " if (  event   ==  null   ) ", " event   =  new UndoableEditEvent (     ,  edit   )   ", " if (  listeners   [  i   ] ==  UndoableEditListener    ) "], ["UndoableEdit edit", "UndoableEditEvent event =  null  ", " if (  listenerList.getListenerCount (  )    >  NUM_   ) ", "Object listeners =  listenerList.getListenerList (  )   ", "for (  ;  i   >=  NUM_   ;  i   -=  NUM_   ) ", " if (  event   ==  null   ) ", " if (  listeners   [  i   ] ==  UndoableEditListener    ) "]]
[[" return  srvKeepBinary  ?   : new PlatformServices (  platformCtx   ,  services   ,  BOOL_   )   "]]
[["int seed , char aChar", " return  PRIME   *  seed   + "]]
[[" return  soot.PhaseOptions.getBoolean (  options   ,  STR_   )   "]]
[["String pattern", " if (  pattern   ==  null   ) ", " return  DateTimeFormat.forPattern (  pattern   )   . print (     )   "], ["String pattern", " if (  pattern   ==  null   ) ", " return  toString (  )   "]]
[["int currentScreen , int lastScreen", "ImageView points =  platformGridView.points  ", "for (  ;  i   <  points.length   ;  i ++  ) ", " points   [  i   ]. setImageBitmap (  platformGridView.grayPoint   )   "], ["int currentScreen , int lastScreen", "ImageView points =  platformGridView.points  ", "for (  ;  i   <  points.length   ;  i ++  ) ", " points   [  i   ]. setImageBitmap (  platformGridView.grayPoint   )   ", " points   [  currentScreen   ]. setImageBitmap (  platformGridView.bluePoint   )   "]]
[["BeanContextServices bcs , Object requestor , Object service", " backBCS.releaseService (  BeanContextServicesSupport. getBeanContextServicesPeer (  )     . getBeanContextServicesPeer (  )    ,  requestor   ,  service   )   "]]
[["SymbolTable symbolTable , XMLGrammarPool grammarPool , XMLComponentManager parentSettings", "   ", "String recognizedFeatures", " addRecognizedFeatures (  recognizedFeatures   )   ", "String recognizedProperties", " addRecognizedProperties (  recognizedProperties   )   ", " setFeature (  ALLOW_UE_AND_NOTATION_EVENTS   ,  BOOL_   )   ", " setFeature (  XINCLUDE_FIXUP_BASE_URIS   ,  BOOL_   )   ", " setFeature (  XINCLUDE_FIXUP_LANGUAGE   ,  BOOL_   )   ", " fNonXIncludeNSContext   =  new NamespaceSupport (  )   ", " fCurrentNSContext   =  fNonXIncludeNSContext  ", " setProperty (  NAMESPACE_CONTEXT   ,  fNonXIncludeNSContext   )   "]]
[["Item wordItem =  relation.getTail (  )   ", " if (  wordItem   !=  null   ) ", "FeatureSet featureSet =  wordItem.getFeatures (  )   ", " featureSet.setString (  STR_   ,  STR_   )   "]]
[["   ", " Log.d (  TAG   ,  STR_   )   "]]
[["AbstractHessianInput in , Object fields", " new UnsupportedOperationException (  toString (  )    )   "]]
[["Element element , String childElementName , Document document", "Element newElement =  document.createElement (  childElementName   )   ", " element.appendChild (  newElement   )   ", " return  newElement  "]]
[["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  term   )    )   ", " if (  label   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  label   )    )   ", " if (  labelLang   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  labelLang   )    )   ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  term   )    )   ", " if (  label   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  label   )    )   ", " if (  labelLang   !=  null   ) ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  term   )    )   ", " if (  label   !=  null   ) ", " if (  labelLang   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  labelLang   )    )   ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  term   )    )   ", " if (  label   !=  null   ) ", " if (  labelLang   !=  null   ) ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " if (  label   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  label   )    )   ", " if (  labelLang   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  labelLang   )    )   ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " if (  label   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  label   )    )   ", " if (  labelLang   !=  null   ) ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " if (  label   !=  null   ) ", " if (  labelLang   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  labelLang   )    )   ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  scheme   )    )   ", " if (  term   !=  null   ) ", " if (  label   !=  null   ) ", " if (  labelLang   !=  null   ) ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " if (  term   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  term   )    )   ", " if (  label   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  label   )    )   ", " if (  labelLang   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  labelLang   )    )   ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "], ["XmlWriter w", "ArrayList attrs =  new ArrayList (  NUM_   )   ", " if (  scheme   !=  null   ) ", " if (  term   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  term   )    )   ", " if (  label   !=  null   ) ", " attrs.add (  new XmlWriter.Attribute (  STR_   ,  label   )    )   ", " if (  labelLang   !=  null   ) ", " w.simpleElement (  Namespaces.atomNs   ,  STR_   ,  attrs   ,  null   )   "]]
[["RaptorState state =    ", "RaptorState ret =   copy (  )     . copy (  )   ", "RaptorState copy =  ret  ", "while (  state.previous   !=  null   )", " copy.previous   =  state.previous.copy (  )   ", " copy.previous.previous   =  null  ", " state   =  state.previous  ", " copy   =  copy.previous  ", " return  ret  "], ["RaptorState state =    ", "RaptorState ret =   copy (  )     . copy (  )   ", "RaptorState copy =  ret  ", "while (  state.previous   !=  null   )", " copy.previous   =  state.previous.copy (  )   ", " copy.previous.previous   =  null  ", " state   =  state.previous  ", " copy   =  copy.previous  "]]
[["char character , boolean isStyled", "  formatCode    . formatCode   =  character  ", "  isStyle    . isStyle   =  isStyled  ", "  formatText    . formatText   =  STR_   +  character  "]]
[["StorageSystem storage , CIMObjectPath groupPath , List volumeURIs", "Set returnedNativeGuids =  new HashSet (  )   ", "Set givenNativeGuids =  new HashSet (  )   ", "CloseableIterator volumePathItr =  null  ", "List volumes =  _dbClient.queryObject (  Volume    ,  volumeURIs   )   ", " volumePathItr   =  _helper.getAssociatorNames (  storage   ,  groupPath   ,  null   ,  SmisConstants.CIM_STORAGE_VOLUME   ,  null   ,  null   )   ", "while (  volumePathItr.hasNext (  )    )", " returnedNativeGuids.add (  _helper.getVolumeNativeGuid (  volumePathItr.next (  )    )    )   "], ["StorageSystem storage , CIMObjectPath groupPath , List volumeURIs", "Set returnedNativeGuids =  new HashSet (  )   ", "Set givenNativeGuids =  new HashSet (  )   ", "CloseableIterator volumePathItr =  null  ", "List volumes =  _dbClient.queryObject (  Volume    ,  volumeURIs   )   ", " volumePathItr   =  _helper.getAssociatorNames (  storage   ,  groupPath   ,  null   ,  SmisConstants.CIM_STORAGE_VOLUME   ,  null   ,  null   )   ", "while (  volumePathItr.hasNext (  )    )", " returnedNativeGuids.add (  _helper.getVolumeNativeGuid (  volumePathItr.next (  )    )    )   ", "for ( Volume volume :  volumes   )", " givenNativeGuids.add (  volume.getNativeGuid (  )    )   ", " _log.info (  STR_   ,  returnedNativeGuids   )   ", " _log.info (  STR_   ,  givenNativeGuids   )   ", "Set diff =  Sets.difference (  returnedNativeGuids   ,  givenNativeGuids   )   ", " return  diff.isEmpty (  )   "], ["StorageSystem storage , CIMObjectPath groupPath , List volumeURIs", "Set returnedNativeGuids =  new HashSet (  )   ", "Set givenNativeGuids =  new HashSet (  )   ", "CloseableIterator volumePathItr =  null  ", "List volumes =  _dbClient.queryObject (  Volume    ,  volumeURIs   )   ", " volumePathItr   =  _helper.getAssociatorNames (  storage   ,  groupPath   ,  null   ,  SmisConstants.CIM_STORAGE_VOLUME   ,  null   ,  null   )   ", "while (  volumePathItr.hasNext (  )    )", " returnedNativeGuids.add (  _helper.getVolumeNativeGuid (  volumePathItr.next (  )    )    )   ", "for ( Volume volume :  volumes   )", " givenNativeGuids.add (  volume.getNativeGuid (  )    )   "]]
[["long l", " tmp.push (  l   )   "]]
[["URI uri", " if (  uri   ==  null   ) ", " return  null  "], ["URI uri", " if (  uri   ==  null   ) ", "String scheme =  uri.getScheme (  )   ", " if (  scheme   ==  null   ||  EFS.SCHEME_FILE.equals (  scheme   )    ) ", " return  null  "], ["URI uri", " if (  uri   ==  null   ) ", "String scheme =  uri.getScheme (  )   ", " if (  scheme   ==  null   ||  EFS.SCHEME_FILE.equals (  scheme   )    ) ", " return  new Path (  uri.getSchemeSpecificPart (  )    )   "]]
[["String address", "  address    . address   =  address  ", " return    "]]
[["Object obj , String method , Class paramClasses , Object params", "Method m =  obj.getClass (  )   . getDeclaredMethod (  method   ,  paramClasses   )   ", " m.setAccessible (  BOOL_   )   ", " return  m.invoke (  obj   ,  params   )   "]]
[["DoubleArrayList data , double mean , double sampleVariance", " return  sampleSkew (  data.size (  )    ,  moment (  data   ,  NUM_   ,  mean   )    ,  sampleVariance   )   "]]
[["AdapterPathSegment segment", " mSegments.add (  segment   )   ", " return    "]]
[[" return  paused  "]]
[["String ruleActionId", " return  getAggregationMap (  )   . containsKey (  ruleActionId   )   "]]
[["String str", " if (  str.indexOf (  STR_   )    !=  str.lastIndexOf (  STR_   )    ) ", " new Error (  STR_   )   ", " if (  str.substring (  NUM_   )   . contains (  STR_   )    ) ", "String vals =  str.split (  STR_   )   ", "  min    . min   =  Double.parseDouble (  vals   [  NUM_   ] )   ", "  max    . max   =  Double.parseDouble (  vals   [  NUM_   ] )   ", " checkRangeValidity (  min   ,  max   )   "], ["String str", " if (  str.indexOf (  STR_   )    !=  str.lastIndexOf (  STR_   )    ) ", " new Error (  STR_   )   ", " if (  str.substring (  NUM_   )   . contains (  STR_   )    ) ", "  min    . min   =   max    . max   =  Double.parseDouble (  str   )   ", " checkRangeValidity (  min   ,  max   )   "], ["String str", " if (  str.indexOf (  STR_   )    !=  str.lastIndexOf (  STR_   )    ) ", " if (  str.substring (  NUM_   )   . contains (  STR_   )    ) ", "String vals =  str.split (  STR_   )   ", "  min    . min   =  Double.parseDouble (  vals   [  NUM_   ] )   ", "  max    . max   =  Double.parseDouble (  vals   [  NUM_   ] )   ", " checkRangeValidity (  min   ,  max   )   "], ["String str", " if (  str.indexOf (  STR_   )    !=  str.lastIndexOf (  STR_   )    ) ", " if (  str.substring (  NUM_   )   . contains (  STR_   )    ) ", "  min    . min   =   max    . max   =  Double.parseDouble (  str   )   ", " checkRangeValidity (  min   ,  max   )   "]]
[["RemoteOperationResult uploadResult , UploadFileOperation upload", " Log_OC.d (  TAG   ,  STR_   +  uploadResult   +  STR_   +  upload   )   ", " if (  uploadResult.isCancelled (  )    ) ", "String localPath =  FileUploader.LOCAL_BEHAVIOUR_MOVE   ==  upload.getLocalBehaviour (  )   ? upload.getStoragePath (  )   : null  ", " if (  uploadResult.isSuccess (  )    ) ", " updateUploadStatus (  upload.getOCUploadId (  )    ,  UploadStatus.UPLOAD_FAILED   ,  UploadResult.fromOperationResult (  uploadResult   )    ,  upload.getRemotePath (  )    ,  localPath   )   "], ["RemoteOperationResult uploadResult , UploadFileOperation upload", " Log_OC.d (  TAG   ,  STR_   +  uploadResult   +  STR_   +  upload   )   ", " if (  uploadResult.isCancelled (  )    ) ", "String localPath =  FileUploader.LOCAL_BEHAVIOUR_MOVE   ==  upload.getLocalBehaviour (  )   ? upload.getStoragePath (  )   : null  ", " if (  uploadResult.isSuccess (  )    ) ", " updateUploadStatus (  upload.getOCUploadId (  )    ,  UploadStatus.UPLOAD_SUCCEEDED   ,  UploadResult.UPLOADED   ,  upload.getRemotePath (  )    ,  localPath   )   "], ["RemoteOperationResult uploadResult , UploadFileOperation upload", " Log_OC.d (  TAG   ,  STR_   +  uploadResult   +  STR_   +  upload   )   ", " if (  uploadResult.isCancelled (  )    ) ", " removeUpload (  upload.getAccount (  )   . name   ,  upload.getRemotePath (  )    )   "]]
[["Element elem"]]
[[" return  enableNetworkLogging  "]]
[[" System.setProperty (  STR_   ,  STR_   )   ", " C2monServiceGateway.startC2monClientSynchronous (  )   ", "ClientCommandTag commandTag =  C2monServiceGateway.getCommandManager (  )   . getCommandTag (  NUM_   )   ", " assertNotNull (  commandTag.getName (  )    )   ", " assertTrue ( ! commandTag.getName (  )   . equalsIgnoreCase (  STR_   )    )   ", " assertNotNull (  commandTag.getProcessId (  )    )   ", " assertNotNull (  commandTag.getHardwareAddress (  )    )   "]]
[["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", " s_cc.readInfo (  connRW   )   ", " connRW.close (  )   ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", " connRO.close (  )   ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", " s_cc.readInfo (  connRW   )   ", " connRW.close (  )   ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", " connRO.close (  )   ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " connID.close (  )   ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", " s_cc.readInfo (  connRW   )   ", " connRW.close (  )   ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", " s_cc.readInfo (  connRW   )   ", " connRW.close (  )   ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " connID.close (  )   ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", " connRO.close (  )   ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", " connRO.close (  )   ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " connID.close (  )   ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "], ["boolean success =  BOOL_  ", "Connection connRW =  getConnectionRW (  )   ", " if (  connRW   !=  null   ) ", "Connection connRO =  getConnectionRO (  )   ", " if (  connRO   !=  null   ) ", "Connection connID =  getConnectionID (  )   ", " if (  connID   !=  null   ) ", " connID.close (  )   ", " success   =  connRW   !=  null   &&  connRO   !=  null   &&  connID   !=  null  ", " return  success  "]]
[["View parentView , int id", "T view =  null  ", "View genericView =  parentView.findViewById (  id   )   ", " view   = ", " return  view  "]]
[["Class type , Order order", " if (  order   !=  null   ) ", "for ( String name :  order.elements (  )    )", " if ( ! isElement (  name   )    ) ", " new ElementException (  STR_   ,  name   ,  type   )   "], ["Class type , Order order", " if (  order   !=  null   ) ", "for ( String name :  order.elements (  )    )", " if ( ! isElement (  name   )    ) "]]
[["Logger logger , Level level", " logger.setLevel (  level   )   ", "for ( Handler handler :  logger.getHandlers (  )    )", " handler.setLevel (  level   )   ", " if (  handler   instanceof ConsoleHandler ) ", " handler.setFormatter (  new ShortFormatter (  )    )   "], ["Logger logger , Level level", " logger.setLevel (  level   )   ", "for ( Handler handler :  logger.getHandlers (  )    )", " handler.setLevel (  level   )   ", " if (  handler   instanceof ConsoleHandler ) "]]
[["boolean allbad =  BOOL_  ", "for ( int m_remoteHostsStatu :  m_remoteHostsStatus   )", " if (  m_remoteHostsStatu   !=  CONNECTION_FAILED   ) ", " allbad   =  BOOL_  ", " if (  allbad   ) ", " m_plottingAborted   =  BOOL_  ", " notifyListeners (  BOOL_   ,  BOOL_   ,  BOOL_   ,  STR_   +  STR_   )   ", " return  allbad  "], ["boolean allbad =  BOOL_  ", "for ( int m_remoteHostsStatu :  m_remoteHostsStatus   )", " if (  m_remoteHostsStatu   !=  CONNECTION_FAILED   ) ", " allbad   =  BOOL_  ", " if (  allbad   ) ", " return  allbad  "], ["boolean allbad =  BOOL_  ", "for ( int m_remoteHostsStatu :  m_remoteHostsStatus   )", " if (  m_remoteHostsStatu   !=  CONNECTION_FAILED   ) ", " allbad   =  BOOL_  "], ["boolean allbad =  BOOL_  ", "for ( int m_remoteHostsStatu :  m_remoteHostsStatus   )", " if (  m_remoteHostsStatu   !=  CONNECTION_FAILED   ) ", " if (  allbad   ) ", " m_plottingAborted   =  BOOL_  ", " notifyListeners (  BOOL_   ,  BOOL_   ,  BOOL_   ,  STR_   +  STR_   )   ", " return  allbad  "], ["boolean allbad =  BOOL_  ", "for ( int m_remoteHostsStatu :  m_remoteHostsStatus   )", " if (  m_remoteHostsStatu   !=  CONNECTION_FAILED   ) ", " if (  allbad   ) ", " return  allbad  "], ["boolean allbad =  BOOL_  ", "for ( int m_remoteHostsStatu :  m_remoteHostsStatus   )", " if (  m_remoteHostsStatu   !=  CONNECTION_FAILED   ) "]]
[["Filter filter", " GrizzlyUtils.addFilterToConnection (  filter   ,  connection   )   "]]
[]
[["ImageConsumer ic", " ics.removeElement (  ic   )   "]]
[[" if (  sessionId   ==  null   ) ", " return  sessionId  "], [" if (  sessionId   ==  null   ) ", " sessionId   =  UUID.randomUUID (  )   ", " return  sessionId  "]]
[[" lmargin ++ "]]
[[" return  shell  "]]
[["PageServiceImpl tableService , int sequenceFlush", "   ", " tableService.compareAndSetBlobPage (     ,  _stub   )   ", "ArrayList buffers =  _buffers  ", " _buffers   =  null  ", " if (  buffers   !=  null   ) ", "for ( TempBuffer buffer :  buffers   )", " buffer.free (  )   "]]
[["FlavorListener listener", " if (  listener   ==  null   ||  flavorListeners   ==  null   ) ", " return "], ["FlavorListener listener", " if (  listener   ==  null   ||  flavorListeners   ==  null   ) ", " flavorListeners.remove (  listener   )   "]]
[[" return   store    . store   !=  null  "]]
[[" if (   values    . values   !=  null   ) ", "for ( FilteredDataTagValue tagValue :  values   )", " tagValue.log (  )   "]]
[["String path1 , String path2", "File file1 =  new File (  path1   )   ", "File file2 =  new File (  file1   ,  path2   )   ", " return  file2.getPath (  )   "]]
[["Draft3Job job , Object output , Object binding", "Object outputEval =  getOutputEval (  binding   )   ", " return  Draft3ExpressionResolver.resolve (  outputEval   ,  job   ,  output   )   "]]
[["Object object", " itemPropertyDescriptors.add (  createItemPropertyDescriptor (  ,  getResourceLocator (  )    ,  getString (  STR_   )    ,  getString (  STR_   ,  STR_   ,  STR_   )    ,  SexecPackage.Literals.TRACE_REACTION_WILL_FIRE__REACTION   ,  BOOL_   ,  BOOL_   ,  BOOL_   ,  null   ,  null   ,  null   )    )   "]]
[["Class type1 , Class type2", "   "]]
[["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " return "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " to   =  siteList.getSiteCount (  )    -  NUM_  ", " if (  every   <=  NUM_   ) ", " every   =  NUM_  ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) ", " addPattern (  pattern   ,  NUM_   )   "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " to   =  siteList.getSiteCount (  )    -  NUM_  ", " if (  every   <=  NUM_   ) ", " every   =  NUM_  ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " to   =  siteList.getSiteCount (  )    -  NUM_  ", " if (  every   <=  NUM_   ) ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) ", " addPattern (  pattern   ,  NUM_   )   "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " to   =  siteList.getSiteCount (  )    -  NUM_  ", " if (  every   <=  NUM_   ) ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " if (  every   <=  NUM_   ) ", " every   =  NUM_  ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) ", " addPattern (  pattern   ,  NUM_   )   "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " if (  every   <=  NUM_   ) ", " every   =  NUM_  ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " if (  every   <=  NUM_   ) ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) ", " addPattern (  pattern   ,  NUM_   )   "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " from   =  NUM_  ", " if (  to   <=  NUM_   ) ", " if (  every   <=  NUM_   ) ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) "], ["SiteList siteList , int from , int to , int every", " if (  siteList   ==  null   ) ", " if (  taxonList   ==  null   ) ", " if (  dataType   ==  null   ) ", " if (  dataType   !=  siteList.getDataType (  )    ) ", " new IllegalArgumentException (  STR_   )   ", " if (  from   <  NUM_   ) ", " if (  to   <=  NUM_   ) ", " to   =  siteList.getSiteCount (  )    -  NUM_  ", " if (  every   <=  NUM_   ) ", " every   =  NUM_  ", "for (  ;  i   <=  to   ;  i   +=  every   ) ", "int pattern =  siteList.getSitePattern (  i   )   ", " if (  pattern   !=  null   && ! isInvariant (  pattern   )    || ! isGapped (  pattern   )    && ! isAmbiguous (  pattern   )    && ! isUnknown (  pattern   )    ) ", " addPattern (  pattern   ,  NUM_   )   "]]
[["Context context , String dbName , int dbVersion , String sqlStatements", "SQLiteDatabase db =  context.openOrCreateDatabase (  dbName   ,  NUM_   ,  null   )   ", "String statements =  TextUtils.split (  sqlStatements   ,  STR_   )   ", "for ( String statement :  statements   )", " if (  TextUtils.isEmpty (  statement   )    ) ", " db.execSQL (  statement   )   ", " db.setVersion (  dbVersion   )   ", " db.close (  )   "], ["Context context , String dbName , int dbVersion , String sqlStatements", "SQLiteDatabase db =  context.openOrCreateDatabase (  dbName   ,  NUM_   ,  null   )   ", "String statements =  TextUtils.split (  sqlStatements   ,  STR_   )   ", "for ( String statement :  statements   )", " if (  TextUtils.isEmpty (  statement   )    ) ", " db.execSQL (  statement   )   "]]
[["long newMillis", " return  newMillis   ==  iMillis  ?   : new Instant (  newMillis   )   "]]
[["ColorMap cMap", " Landscape.getInstance (  )   . markDirty (  DirtyType.RenderState   )   "]]
[[" return  BOOL_  "]]
[["int key , boolean value", " if (  mSize   !=  NUM_   &&  key   <=  mKeys   [  mSize   -  NUM_   ] ) ", " put (  key   ,  value   )   ", " return "], ["int key , boolean value", " if (  mSize   !=  NUM_   &&  key   <=  mKeys   [  mSize   -  NUM_   ] ) ", "int pos =  mSize  ", " if (  pos   >=  mKeys.length   ) ", "int n =  ArrayUtils.idealIntArraySize (  pos   +  NUM_   )   ", "int nkeys =  new int [  n   ]   ", "boolean nvalues =  new boolean [  n   ]   ", " System.arraycopy (  mKeys   ,  NUM_   ,  nkeys   ,  NUM_   ,  mKeys.length   )   ", " System.arraycopy (  mValues   ,  NUM_   ,  nvalues   ,  NUM_   ,  mValues.length   )   ", " mKeys   =  nkeys  ", " mValues   =  nvalues  ", " mKeys   [  pos   ] =  key  ", " mValues   [  pos   ] =  value  ", " mSize   =  pos   +  NUM_  "], ["int key , boolean value", " if (  mSize   !=  NUM_   &&  key   <=  mKeys   [  mSize   -  NUM_   ] ) ", "int pos =  mSize  ", " if (  pos   >=  mKeys.length   ) ", " mKeys   [  pos   ] =  key  ", " mValues   [  pos   ] =  value  ", " mSize   =  pos   +  NUM_  "]]
[["LoadListener loader , String host , String realm , String username , String password", "CallbackProxy proxy =  loader.getFrame (  )   . getCallbackProxy (  )   ", " proxy.onReceivedHttpAuthCredentials (  host   ,  realm   ,  username   ,  password   )   "]]
[["DownloadInfo di", "ContentValues cv =  new ContentValues (  )   ", " cv.put (  DownloadColumns.INDEX   ,  di.mIndex   )   ", " cv.put (  DownloadColumns.FILENAME   ,  di.mFileName   )   ", " cv.put (  DownloadColumns.URI   ,  di.mUri   )   ", " cv.put (  DownloadColumns.ETAG   ,  di.mETag   )   ", " cv.put (  DownloadColumns.TOTALBYTES   ,  di.mTotalBytes   )   ", " cv.put (  DownloadColumns.CURRENTBYTES   ,  di.mCurrentBytes   )   ", " cv.put (  DownloadColumns.LASTMOD   ,  di.mLastMod   )   ", " cv.put (  DownloadColumns.STATUS   ,  di.mStatus   )   ", " cv.put (  DownloadColumns.CONTROL   ,  di.mControl   )   ", " cv.put (  DownloadColumns.NUM_FAILED   ,  di.mNumFailed   )   ", " cv.put (  DownloadColumns.RETRY_AFTER   ,  di.mRetryAfter   )   ", " cv.put (  DownloadColumns.REDIRECT_COUNT   ,  di.mRedirectCount   )   ", " return  updateDownload (  di   ,  cv   )   "]]
[[" zzAtEOF   =  BOOL_  ", " zzEndRead   =  zzStartRead  ", " if (  zzReader   !=  null   ) ", " zzReader.close (  )   "]]
[[" new PSSParameterSpec (  null   ,  STR_   ,  MGF1ParameterSpec.SHA1   ,  NUM_   ,  NUM_   )   ", " fail (  STR_   )   "]]
[["ByteList bytes , IntList namespaces", "for (  ;  i   <  namespaces.size (  )    ;  i ++  ) ", " bytes   =  Int (  bytes   ,  namespaces.get (  i   )    )   "], ["ByteList bytes , IntList namespaces", "for (  ;  i   <  namespaces.size (  )    ;  i ++  ) ", " bytes   =  Int (  bytes   ,  namespaces.get (  i   )    )   ", " return  bytes  "]]
[["JSONObject response", "JSONObject currently =  response.getJSONObject (  STR_   )   ", " return  currently.getDouble (  STR_   )   "]]
[["LocalDateTime newDateTime", " return  ofLocal (  newDateTime   ,  zone   ,  offset   )   "]]
[["int integer", "for (  ;  i   <  size   ;  i ++  ) ", " if (  data   [  i   ] ==  integer   ) "], ["int integer", "for (  ;  i   <  size   ;  i ++  ) ", " if (  data   [  i   ] ==  integer   ) ", " return  BOOL_  "], ["int integer", "for (  ;  i   <  size   ;  i ++  ) ", " if (  data   [  i   ] ==  integer   ) ", " return  BOOL_  "]]
[["CarbonDimension dimension , StringBuilder dimString , String parent", " dimString.append (  dimension.getColName (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  dimension.getDataType (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  parent   +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  dimension.getColumnId (  )    +  CarbonCommonConstants.HASH_SPC_CHARACTER   )   ", "for (  ;  i   <  dimension.getNumberOfChild (  )    ;  i ++  ) ", "CarbonDimension childDim =  dimension.getListOfChildDimensions (  )   . get (  i   )   ", " if (  childDim.getNumberOfChild (  )    >  NUM_   ) ", " dimString.append (  childDim.getColName (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  childDim.getDataType (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  dimension.getColName (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  childDim.getColumnId (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  childDim.getOrdinal (  )    +  CarbonCommonConstants.HASH_SPC_CHARACTER   )   "], ["CarbonDimension dimension , StringBuilder dimString , String parent", " dimString.append (  dimension.getColName (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  dimension.getDataType (  )    +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  parent   +  CarbonCommonConstants.COLON_SPC_CHARACTER   +  dimension.getColumnId (  )    +  CarbonCommonConstants.HASH_SPC_CHARACTER   )   ", "for (  ;  i   <  dimension.getNumberOfChild (  )    ;  i ++  ) ", "CarbonDimension childDim =  dimension.getListOfChildDimensions (  )   . get (  i   )   ", " if (  childDim.getNumberOfChild (  )    >  NUM_   ) ", " addAllComplexTypeChildren (  childDim   ,  dimString   ,  dimension.getColName (  )    )   "]]
[["IMap map , TransactionProvider txProvider , ExceptionTranslator exTranslator , int defaultIsolationLevel", "  map    . map   =  map  ", "  lockManager    . lockManager   =  new LockManager (  map   )   ", "  txProvider    . txProvider   =  txProvider  ", "  exTranslator    . exTranslator   =  exTranslator  ", " switch (  defaultIsolationLevel   ) ", " case  TransactionDefinition.ISOLATION_READ_UNCOMMITTED  ", "  defaultIsolationLevel    . defaultIsolationLevel   =  ReadModifiers.DIRTY_READ  "], ["IMap map , TransactionProvider txProvider , ExceptionTranslator exTranslator , int defaultIsolationLevel", "  map    . map   =  map  ", "  lockManager    . lockManager   =  new LockManager (  map   )   ", "  txProvider    . txProvider   =  txProvider  ", "  exTranslator    . exTranslator   =  exTranslator  ", " switch (  defaultIsolationLevel   ) ", " case  TransactionDefinition.ISOLATION_SERIALIZABLE  ", " new IllegalArgumentException (  STR_   )   "], ["IMap map , TransactionProvider txProvider , ExceptionTranslator exTranslator , int defaultIsolationLevel", "  map    . map   =  map  ", "  lockManager    . lockManager   =  new LockManager (  map   )   ", "  txProvider    . txProvider   =  txProvider  ", "  exTranslator    . exTranslator   =  exTranslator  ", " switch (  defaultIsolationLevel   ) ", " case  TransactionDefinition.ISOLATION_REPEATABLE_READ  ", "  defaultIsolationLevel    . defaultIsolationLevel   =  ReadModifiers.REPEATABLE_READ  "], ["IMap map , TransactionProvider txProvider , ExceptionTranslator exTranslator , int defaultIsolationLevel", "  map    . map   =  map  ", "  lockManager    . lockManager   =  new LockManager (  map   )   ", "  txProvider    . txProvider   =  txProvider  ", "  exTranslator    . exTranslator   =  exTranslator  ", " switch (  defaultIsolationLevel   ) ", " case  TransactionDefinition.ISOLATION_DEFAULT  ", "  defaultIsolationLevel    . defaultIsolationLevel   =  ReadModifiers.REPEATABLE_READ  "], ["IMap map , TransactionProvider txProvider , ExceptionTranslator exTranslator , int defaultIsolationLevel", "  map    . map   =  map  ", "  lockManager    . lockManager   =  new LockManager (  map   )   ", "  txProvider    . txProvider   =  txProvider  ", "  exTranslator    . exTranslator   =  exTranslator  ", " switch (  defaultIsolationLevel   ) ", " case  TransactionDefinition.ISOLATION_READ_COMMITTED  ", "  defaultIsolationLevel    . defaultIsolationLevel   =  ReadModifiers.READ_COMMITTED  "]]
[["VkApiClient client , UserActor actor , int userId", "   ", " accessToken (  actor.getAccessToken (  )    )   ", " userId (  userId   )   "]]
[["ByteBuffer content , Type targetType", " return  Charset.defaultCharset (  )   . decode (  content   )   . toString (  )   "]]
[["String queueid", "FetchItemQueue fiq =  queues.get (  queueid   )   ", " if (  fiq   ==  null   ) ", " if (  fiq.getQueueSize (  )    ==  NUM_   ) ", "int excCount =  fiq.incrementExceptionCounter (  )   ", " if (  maxExceptionsPerQueue   != - NUM_   &&  excCount   >=  maxExceptionsPerQueue   ) ", " return  NUM_  "], ["String queueid", "FetchItemQueue fiq =  queues.get (  queueid   )   ", " if (  fiq   ==  null   ) ", " if (  fiq.getQueueSize (  )    ==  NUM_   ) ", "int excCount =  fiq.incrementExceptionCounter (  )   ", " if (  maxExceptionsPerQueue   != - NUM_   &&  excCount   >=  maxExceptionsPerQueue   ) ", "int deleted =  fiq.emptyQueue (  )   ", " LOG.info (  STR_   +  queueid   +  STR_   +  deleted   +  STR_   +  excCount   +  STR_   )   ", "for (  ;  i   <  deleted   ;  i ++  ) ", " totalSize.decrementAndGet (  )   ", " return  deleted  "], ["String queueid", "FetchItemQueue fiq =  queues.get (  queueid   )   ", " if (  fiq   ==  null   ) ", " if (  fiq.getQueueSize (  )    ==  NUM_   ) ", "int excCount =  fiq.incrementExceptionCounter (  )   ", " if (  maxExceptionsPerQueue   != - NUM_   &&  excCount   >=  maxExceptionsPerQueue   ) ", "int deleted =  fiq.emptyQueue (  )   ", " LOG.info (  STR_   +  queueid   +  STR_   +  deleted   +  STR_   +  excCount   +  STR_   )   ", "for (  ;  i   <  deleted   ;  i ++  ) ", " totalSize.decrementAndGet (  )   "], ["String queueid", "FetchItemQueue fiq =  queues.get (  queueid   )   ", " if (  fiq   ==  null   ) ", " if (  fiq.getQueueSize (  )    ==  NUM_   ) ", " return  NUM_  "], ["String queueid", "FetchItemQueue fiq =  queues.get (  queueid   )   ", " if (  fiq   ==  null   ) ", " return  NUM_  "]]
[["Container c", "boolean result", "ChildFrameMDI mdiFrame", "ChildFrameSDI sdiFrame", " if (  c   !=  null   ) ", " result   =  BOOL_  ", " return  result  "], ["Container c", "boolean result", "ChildFrameMDI mdiFrame", "ChildFrameSDI sdiFrame", " if (  c   !=  null   ) ", " if (  c   instanceof ChildFrameMDI ) ", " mdiFrame   = ", " mdiFrame.setIcon (  BOOL_   )   ", " mdiFrame.toFront (  )   ", " createTitle (  mdiFrame.getTitle (  )    )   ", " result   =  BOOL_  ", " return  result  "], ["Container c", "boolean result", "ChildFrameMDI mdiFrame", "ChildFrameSDI sdiFrame", " if (  c   !=  null   ) ", " if (  c   instanceof ChildFrameMDI ) ", " if (  c   instanceof ChildFrameSDI ) ", " result   =  BOOL_  ", " return  result  "], ["Container c", "boolean result", "ChildFrameMDI mdiFrame", "ChildFrameSDI sdiFrame", " if (  c   !=  null   ) ", " if (  c   instanceof ChildFrameMDI ) ", " if (  c   instanceof ChildFrameSDI ) ", " sdiFrame   = ", " sdiFrame.setExtendedState (  JFrame.NORMAL   )   ", " sdiFrame.toFront (  )   ", " createTitle (  sdiFrame.getTitle (  )    )   ", " result   =  BOOL_  ", " return  result  "]]
[["int n", " if (  n   >  x.length   ) ", "double tmp =  new double [  n   ]   ", " pad (  x   ,  tmp   )   ", " x   =  tmp  "]]
[["Graphics2D graphics , Line2D line , double xOffset , double yOffset , double scale", "Point2D point1 =  new Point2D.Double (  line.getP1 (  )   . getX (  )    -  xOffset   *  scale   ,  line.getP1 (  )   . getY (  )    -  yOffset   *  scale   )   ", "Point2D point2 =  new Point2D.Double (  line.getP2 (  )   . getX (  )    -  xOffset   *  scale   ,  line.getP2 (  )   . getY (  )    -  yOffset   *  scale   )   ", " if (  graphics.getClip (  )   . contains (  point1   )    ||  graphics.getClip (  )   . contains (  point2   )    ) ", " graphics.draw (  new Line2D.Double (  point1   ,  point2   )    )   "]]
[["OperationGroup updateGroup , OperationGroup deleteGroup , OperationGroup dependsOnGroup", "BatchEntityLoader batchLoader =  new BatchEntityLoader (  )   ", " LOG.debug (  STR_   )   ", "OperationGroup mergedAndOptimized =  dependsOnGroup.mergedCopy (  updateGroup   ,  deleteGroup.reverse (  )    )   . optimizedForInsertCopy (  )   ", " batchLoader.addEntities (  mergedAndOptimized.getEntities (  )    )   ", " LOG.debug (  STR_   )   ", " LOG.debug (  STR_   )   ", " batchLoader.load (  )   "]]
[["String message", "   ", " cause   =  null  "]]
[["IProject project", " Check.notNull (  project   ,  STR_   )   ", " log.debug (  MessageFormat.format (  STR_   ,  project.getName (  )    )    )   ", " waitForManagerStartup (  )   ", " project.setPersistentProperty (  REPOSITORY_STATUS_KEY   ,  REPOSITORY_STATUS_OFFLINE_VALUE   )   ", "ProjectRepositoryData projectData =  projectDataMap.get (  project   )   ", " if (  projectData   !=  null   ) ", " log.error (  MessageFormat.format (  STR_   ,  project.getName (  )    )    )   ", " CodeMarkerDispatch.dispatch (  FINISH_PROJECT_ADDITION   )   ", " return "], ["IProject project", " Check.notNull (  project   ,  STR_   )   ", " log.debug (  MessageFormat.format (  STR_   ,  project.getName (  )    )    )   ", " waitForManagerStartup (  )   ", " project.setPersistentProperty (  REPOSITORY_STATUS_KEY   ,  REPOSITORY_STATUS_OFFLINE_VALUE   )   ", "ProjectRepositoryData projectData =  projectDataMap.get (  project   )   ", " if (  projectData   !=  null   ) ", " projectData   =  new ProjectRepositoryData (  )   ", " projectData.setStatus (  ProjectRepositoryStatus.OFFLINE   )   ", " projectDataMap.put (  project   ,  projectData   )   ", " log.info (  MessageFormat.format (  STR_   ,  project.getName (  )    )    )   ", " CodeMarkerDispatch.dispatch (  FINISH_PROJECT_ADDITION   )   "]]
[["Object lhs , Object rhs , boolean testTransients , Class reflectUpToClass", " return  reflectionEquals (  lhs   ,  rhs   ,  testTransients   ,  reflectUpToClass   ,  null   )   "]]
[["String text", "  progressText    . progressText   =  STR_  ", "  progressAddValue    . progressAddValue   =  BOOL_  ", " if (  text   !=  null   ) ", " if (  text.contains (  STR_   )    ) ", " text   =  text.replace (  STR_   ,  STR_   )   ", "  progressAddValue    . progressAddValue   =  BOOL_  ", "  progressText    . progressText   =  text  ", "  paint   ,  getTextBounds (   progressText    . progressText   ,  NUM_   ,   progressText   ,  length (  )     . progressText  . length (  )    ,   textBounds    . textBounds   )     . paint  . getTextBounds (   progressText    . progressText   ,  NUM_   ,   progressText   ,  length (  )     . progressText  . length (  )    ,   textBounds    . textBounds   )   "], ["String text", "  progressText    . progressText   =  STR_  ", "  progressAddValue    . progressAddValue   =  BOOL_  ", " if (  text   !=  null   ) ", " if (  text.contains (  STR_   )    ) ", "  progressText    . progressText   =  text  ", "  paint   ,  getTextBounds (   progressText    . progressText   ,  NUM_   ,   progressText   ,  length (  )     . progressText  . length (  )    ,   textBounds    . textBounds   )     . paint  . getTextBounds (   progressText    . progressText   ,  NUM_   ,   progressText   ,  length (  )     . progressText  . length (  )    ,   textBounds    . textBounds   )   "], ["String text", "  progressText    . progressText   =  STR_  ", "  progressAddValue    . progressAddValue   =  BOOL_  ", " if (  text   !=  null   ) ", "  paint   ,  getTextBounds (   progressText    . progressText   ,  NUM_   ,   progressText   ,  length (  )     . progressText  . length (  )    ,   textBounds    . textBounds   )     . paint  . getTextBounds (   progressText    . progressText   ,  NUM_   ,   progressText   ,  length (  )     . progressText  . length (  )    ,   textBounds    . textBounds   )   "]]
[["KeyEvent e", "int keycode =  e.getKeyCode (  )   ", " switch (  keycode   ) ", " case "], ["KeyEvent e", "int keycode =  e.getKeyCode (  )   ", " switch (  keycode   ) ", " case  KeyEvent.VK_U  ", " workspace.iterate (  )   "]]
[["List rules , int startIndex", "Location toBeMatchedRuleLocation =  model.getLocationInConfig (  rule   ,  SELECTOR_FIELD_NAME   )   ", "for (  ;  iter.hasNext (  )    ;  ) ", "String selector =  iter.next (  )   ", "for (  ;  i   <  rules.size (  )    ;  i ++  ) ", "RuleWrapper ruleWrapper =  rules.get (  i   )   ", " if (  isSubsumed (  selector   ,  ruleWrapper.selectors   )    ) "], ["List rules , int startIndex", "Location toBeMatchedRuleLocation =  model.getLocationInConfig (  rule   ,  SELECTOR_FIELD_NAME   )   ", "for (  ;  iter.hasNext (  )    ;  ) ", "String selector =  iter.next (  )   ", "for (  ;  i   <  rules.size (  )    ;  i ++  ) ", "RuleWrapper ruleWrapper =  rules.get (  i   )   ", " if (  isSubsumed (  selector   ,  ruleWrapper.selectors   )    ) ", "Location matchingRuleLocation =  model.getLocationInConfig (  ruleWrapper.rule   ,  SELECTOR_FIELD_NAME   )   ", " if ( ! maintainSelectorMinimizationBugExperimentEnabled (  )    &&  isSameYamlFile (  matchingRuleLocation   ,  toBeMatchedRuleLocation   )    ) ", " iter.remove (  )   "], ["List rules , int startIndex", "Location toBeMatchedRuleLocation =  model.getLocationInConfig (  rule   ,  SELECTOR_FIELD_NAME   )   ", "for (  ;  iter.hasNext (  )    ;  ) ", "String selector =  iter.next (  )   ", "for (  ;  i   <  rules.size (  )    ;  i ++  ) ", "RuleWrapper ruleWrapper =  rules.get (  i   )   ", " if (  isSubsumed (  selector   ,  ruleWrapper.selectors   )    ) ", "Location matchingRuleLocation =  model.getLocationInConfig (  ruleWrapper.rule   ,  SELECTOR_FIELD_NAME   )   ", " if ( ! maintainSelectorMinimizationBugExperimentEnabled (  )    &&  isSameYamlFile (  matchingRuleLocation   ,  toBeMatchedRuleLocation   )    ) ", " model.getDiagCollector (  )   . addDiag (  Diag.error (  matchingRuleLocation   ,  STR_   +  STR_   ,  ruleWrapper.getUnflattenedSelector (  )    ,  matchingRuleLocation.getDisplayString (  )    ,  selector   ,  toBeMatchedRuleLocation.getDisplayString (  )    )    )   ", " iter.remove (  )   "]]
[["String aclURL , ShareACLForm shareACL , String formAccessControlList", "String fileSystem =  null  ", "String shareName =  null  ", " if (  StringUtils.isNotBlank (  aclURL   )    ) ", "String parts =  aclURL.split (  STR_   )   ", " if (  parts.length   ==  NUM_   ) ", " fileSystem   =  parts   [  NUM_   ]", " shareName   =  parts   [  NUM_   ]", " if (  formAccessControlList   ==  null   ||  STR_.equals (  formAccessControlList   )    ) ", "FileCifsShareACLUpdateParams input =  createCifsShareAclParams (  formAccessControlList   )   ", "ViPRCoreClient client =  BourneUtil.getViprClient (  )   ", " client.fileSystems (  )   . updateShareACL (  uri (  fileSystem   )    ,  shareName   ,  input   )   ", " flash.success (  MessagesUtils.get (  ADDED   )    )   ", " listAcl (  fileSystem   ,  shareName   )   "], ["String aclURL , ShareACLForm shareACL , String formAccessControlList", "String fileSystem =  null  ", "String shareName =  null  ", " if (  StringUtils.isNotBlank (  aclURL   )    ) ", "String parts =  aclURL.split (  STR_   )   ", " if (  parts.length   ==  NUM_   ) ", " fileSystem   =  parts   [  NUM_   ]", " shareName   =  parts   [  NUM_   ]", " if (  formAccessControlList   ==  null   ||  STR_.equals (  formAccessControlList   )    ) ", " flash.error (  MessagesUtils.get (  STR_   )    ,  null   )   ", " listAcl (  fileSystem   ,  shareName   )   ", "FileCifsShareACLUpdateParams input =  createCifsShareAclParams (  formAccessControlList   )   ", "ViPRCoreClient client =  BourneUtil.getViprClient (  )   ", " client.fileSystems (  )   . updateShareACL (  uri (  fileSystem   )    ,  shareName   ,  input   )   ", " flash.success (  MessagesUtils.get (  ADDED   )    )   ", " listAcl (  fileSystem   ,  shareName   )   "], ["String aclURL , ShareACLForm shareACL , String formAccessControlList", "String fileSystem =  null  ", "String shareName =  null  ", " if (  StringUtils.isNotBlank (  aclURL   )    ) ", "String parts =  aclURL.split (  STR_   )   ", " if (  parts.length   ==  NUM_   ) ", " if (  formAccessControlList   ==  null   ||  STR_.equals (  formAccessControlList   )    ) ", "FileCifsShareACLUpdateParams input =  createCifsShareAclParams (  formAccessControlList   )   ", "ViPRCoreClient client =  BourneUtil.getViprClient (  )   ", " client.fileSystems (  )   . updateShareACL (  uri (  fileSystem   )    ,  shareName   ,  input   )   ", " flash.success (  MessagesUtils.get (  ADDED   )    )   ", " listAcl (  fileSystem   ,  shareName   )   "], ["String aclURL , ShareACLForm shareACL , String formAccessControlList", "String fileSystem =  null  ", "String shareName =  null  ", " if (  StringUtils.isNotBlank (  aclURL   )    ) ", "String parts =  aclURL.split (  STR_   )   ", " if (  parts.length   ==  NUM_   ) ", " if (  formAccessControlList   ==  null   ||  STR_.equals (  formAccessControlList   )    ) ", " flash.error (  MessagesUtils.get (  STR_   )    ,  null   )   ", " listAcl (  fileSystem   ,  shareName   )   ", "FileCifsShareACLUpdateParams input =  createCifsShareAclParams (  formAccessControlList   )   ", "ViPRCoreClient client =  BourneUtil.getViprClient (  )   ", " client.fileSystems (  )   . updateShareACL (  uri (  fileSystem   )    ,  shareName   ,  input   )   ", " flash.success (  MessagesUtils.get (  ADDED   )    )   ", " listAcl (  fileSystem   ,  shareName   )   "], ["String aclURL , ShareACLForm shareACL , String formAccessControlList", "String fileSystem =  null  ", "String shareName =  null  ", " if (  StringUtils.isNotBlank (  aclURL   )    ) ", " if (  formAccessControlList   ==  null   ||  STR_.equals (  formAccessControlList   )    ) ", "FileCifsShareACLUpdateParams input =  createCifsShareAclParams (  formAccessControlList   )   ", "ViPRCoreClient client =  BourneUtil.getViprClient (  )   ", " client.fileSystems (  )   . updateShareACL (  uri (  fileSystem   )    ,  shareName   ,  input   )   ", " flash.success (  MessagesUtils.get (  ADDED   )    )   ", " listAcl (  fileSystem   ,  shareName   )   "], ["String aclURL , ShareACLForm shareACL , String formAccessControlList", "String fileSystem =  null  ", "String shareName =  null  ", " if (  StringUtils.isNotBlank (  aclURL   )    ) ", " if (  formAccessControlList   ==  null   ||  STR_.equals (  formAccessControlList   )    ) ", " flash.error (  MessagesUtils.get (  STR_   )    ,  null   )   ", " listAcl (  fileSystem   ,  shareName   )   ", "FileCifsShareACLUpdateParams input =  createCifsShareAclParams (  formAccessControlList   )   ", "ViPRCoreClient client =  BourneUtil.getViprClient (  )   ", " client.fileSystems (  )   . updateShareACL (  uri (  fileSystem   )    ,  shareName   ,  input   )   ", " flash.success (  MessagesUtils.get (  ADDED   )    )   ", " listAcl (  fileSystem   ,  shareName   )   "]]
[["BluetoothDevice device", " if (  DBG   ) ", " log (  STR_   )   ", " if (  mService   !=  null   &&  isEnabled (  )    &&  isValidDevice (  device   )    ) ", " Log.w (  TAG   ,  STR_   )   ", " if (  DBG   ) ", " Log.d (  TAG   ,  Log.getStackTraceString (  new Throwable (  )    )    )   ", " return  BOOL_  "], ["BluetoothDevice device", " if (  DBG   ) ", " log (  STR_   )   ", " if (  mService   !=  null   &&  isEnabled (  )    &&  isValidDevice (  device   )    ) ", " Log.w (  TAG   ,  STR_   )   ", " if (  DBG   ) ", " return  BOOL_  "], ["BluetoothDevice device", " if (  DBG   ) ", " log (  STR_   )   ", " if (  mService   !=  null   &&  isEnabled (  )    &&  isValidDevice (  device   )    ) ", " return  mService.startScoUsingVirtualVoiceCall (  device   )   "], ["BluetoothDevice device", " if (  DBG   ) ", " if (  mService   !=  null   &&  isEnabled (  )    &&  isValidDevice (  device   )    ) ", " Log.w (  TAG   ,  STR_   )   ", " if (  DBG   ) ", " Log.d (  TAG   ,  Log.getStackTraceString (  new Throwable (  )    )    )   ", " return  BOOL_  "], ["BluetoothDevice device", " if (  DBG   ) ", " if (  mService   !=  null   &&  isEnabled (  )    &&  isValidDevice (  device   )    ) ", " Log.w (  TAG   ,  STR_   )   ", " if (  DBG   ) ", " return  BOOL_  "], ["BluetoothDevice device", " if (  DBG   ) ", " if (  mService   !=  null   &&  isEnabled (  )    &&  isValidDevice (  device   )    ) ", " return  mService.startScoUsingVirtualVoiceCall (  device   )   "]]
[["String authority", "FileSystem fs =  fileSystem (  authority   ,  tcp   )   "]]
[["List certs", "   ", "for ( Object obj :  certs   )", " if (  obj   instanceof X509Certificate ==  BOOL_   ) ", "  certs    . certs   =  Collections.unmodifiableList (  new ArrayList (  )    )   "], ["List certs", "   ", "for ( Object obj :  certs   )", " if (  obj   instanceof X509Certificate ==  BOOL_   ) "], ["List certs", "   ", "for ( Object obj :  certs   )", " if (  obj   instanceof X509Certificate ==  BOOL_   ) ", " new CertificateException (  STR_   +  obj.getClass (  )   . getName (  )    )   "], ["List certs", "   ", "for ( Object obj :  certs   )", " if (  obj   instanceof X509Certificate ==  BOOL_   ) ", " new CertificateException (  STR_   +  obj.getClass (  )   . getName (  )    )   ", "  certs    . certs   =  Collections.unmodifiableList (  new ArrayList (  )    )   "]]
[["double southernLat , double westernLon , double northernLat , double easternLon", " builder.append (  String.format (  Locale.US   ,  STR_   ,  southernLat   ,  westernLon   ,  northernLat   ,  easternLon   )    )   ", " return    "]]
[[" new CloneNotSupportedException (  )   "]]
[["String files", " if (  files   ==  null   ) ", "String currentJar =  null  ", "for (  ;  i   <  files.length   ;  i ++  ) ", " currentJar   =  files   [  i   ]", "ZipFile zrf =  new ZipFile (  currentJar.replace (  STR_   ,  File.separatorChar   )    )   ", "Enumeration entries =  zrf.entries (  )   ", "while (  entries.hasMoreElements (  )    )", "ZipEntry entry =  entries.nextElement (  )   ", "String fileName =  entry.getName (  )   ", " if (  fileName.equals (  STR_   )    ||  fileName.equals (  INDEX_NAME   )    ||  fileName.equals (  JarFile.MANIFEST_NAME   )    ) ", " if ( ! metaInfFilenames   || ! fileName.startsWith (  STR_   )    ) ", " add (  fileName   ,  currentJar   )   ", " zrf.close (  )   "], ["String files", " if (  files   ==  null   ) ", "String currentJar =  null  ", "for (  ;  i   <  files.length   ;  i ++  ) ", " currentJar   =  files   [  i   ]", "ZipFile zrf =  new ZipFile (  currentJar.replace (  STR_   ,  File.separatorChar   )    )   ", "Enumeration entries =  zrf.entries (  )   ", "while (  entries.hasMoreElements (  )    )", "ZipEntry entry =  entries.nextElement (  )   ", "String fileName =  entry.getName (  )   ", " if (  fileName.equals (  STR_   )    ||  fileName.equals (  INDEX_NAME   )    ||  fileName.equals (  JarFile.MANIFEST_NAME   )    ) ", " if ( ! metaInfFilenames   || ! fileName.startsWith (  STR_   )    ) ", " add (  fileName   ,  currentJar   )   "], ["String files", " if (  files   ==  null   ) ", "String currentJar =  null  ", "for (  ;  i   <  files.length   ;  i ++  ) ", " currentJar   =  files   [  i   ]", "ZipFile zrf =  new ZipFile (  currentJar.replace (  STR_   ,  File.separatorChar   )    )   ", "Enumeration entries =  zrf.entries (  )   ", "while (  entries.hasMoreElements (  )    )", "ZipEntry entry =  entries.nextElement (  )   ", "String fileName =  entry.getName (  )   ", " if (  fileName.equals (  STR_   )    ||  fileName.equals (  INDEX_NAME   )    ||  fileName.equals (  JarFile.MANIFEST_NAME   )    ) ", " if ( ! metaInfFilenames   || ! fileName.startsWith (  STR_   )    ) ", " if ( ! entry.isDirectory (  )    ) ", " zrf.close (  )   "], ["String files", " if (  files   ==  null   ) ", "String currentJar =  null  ", "for (  ;  i   <  files.length   ;  i ++  ) ", " currentJar   =  files   [  i   ]", "ZipFile zrf =  new ZipFile (  currentJar.replace (  STR_   ,  File.separatorChar   )    )   ", "Enumeration entries =  zrf.entries (  )   ", "while (  entries.hasMoreElements (  )    )", "ZipEntry entry =  entries.nextElement (  )   ", "String fileName =  entry.getName (  )   ", " if (  fileName.equals (  STR_   )    ||  fileName.equals (  INDEX_NAME   )    ||  fileName.equals (  JarFile.MANIFEST_NAME   )    ) ", " if ( ! metaInfFilenames   || ! fileName.startsWith (  STR_   )    ) ", " if ( ! entry.isDirectory (  )    ) "], ["String files", " if (  files   ==  null   ) ", "String currentJar =  null  ", "for (  ;  i   <  files.length   ;  i ++  ) ", " currentJar   =  files   [  i   ]", "ZipFile zrf =  new ZipFile (  currentJar.replace (  STR_   ,  File.separatorChar   )    )   ", "Enumeration entries =  zrf.entries (  )   ", "while (  entries.hasMoreElements (  )    )", "ZipEntry entry =  entries.nextElement (  )   ", "String fileName =  entry.getName (  )   ", " if (  fileName.equals (  STR_   )    ||  fileName.equals (  INDEX_NAME   )    ||  fileName.equals (  JarFile.MANIFEST_NAME   )    ) ", " if ( ! metaInfFilenames   || ! fileName.startsWith (  STR_   )    ) ", " if ( ! entry.isDirectory (  )    ) ", " addMapping (  fileName   ,  currentJar   )   ", " zrf.close (  )   "], ["String files", " if (  files   ==  null   ) ", "String currentJar =  null  ", "for (  ;  i   <  files.length   ;  i ++  ) ", " currentJar   =  files   [  i   ]", "ZipFile zrf =  new ZipFile (  currentJar.replace (  STR_   ,  File.separatorChar   )    )   ", "Enumeration entries =  zrf.entries (  )   ", "while (  entries.hasMoreElements (  )    )", "ZipEntry entry =  entries.nextElement (  )   ", "String fileName =  entry.getName (  )   ", " if (  fileName.equals (  STR_   )    ||  fileName.equals (  INDEX_NAME   )    ||  fileName.equals (  JarFile.MANIFEST_NAME   )    ) ", " if ( ! metaInfFilenames   || ! fileName.startsWith (  STR_   )    ) ", " if ( ! entry.isDirectory (  )    ) ", " addMapping (  fileName   ,  currentJar   )   "], ["String files", " if (  files   ==  null   ) ", " return "]]
[["Assignment c =  new Assignment (     )   ", " c.cachedHash   =  cachedHash  ", " return  c  "]]
[["RectF rect , float x , float y , RectF bounds , int viewWidth , int viewHeight , float snapMargin , boolean fixedAspectRatio , float aspectRatio", "float adjX =  x   +  mTouchOffset.x  ", "float adjY =  y   +  mTouchOffset.y  ", " if (  mType   ==  Type.CENTER   ) ", " moveCenter (  rect   ,  adjX   ,  adjY   ,  bounds   ,  viewWidth   ,  viewHeight   ,  snapMargin   )   "], ["RectF rect , float x , float y , RectF bounds , int viewWidth , int viewHeight , float snapMargin , boolean fixedAspectRatio , float aspectRatio", "float adjX =  x   +  mTouchOffset.x  ", "float adjY =  y   +  mTouchOffset.y  ", " if (  mType   ==  Type.CENTER   ) ", " if (  fixedAspectRatio   ) ", " moveSizeWithFixedAspectRatio (  rect   ,  adjX   ,  adjY   ,  bounds   ,  viewWidth   ,  viewHeight   ,  snapMargin   ,  aspectRatio   )   "], ["RectF rect , float x , float y , RectF bounds , int viewWidth , int viewHeight , float snapMargin , boolean fixedAspectRatio , float aspectRatio", "float adjX =  x   +  mTouchOffset.x  ", "float adjY =  y   +  mTouchOffset.y  ", " if (  mType   ==  Type.CENTER   ) ", " if (  fixedAspectRatio   ) ", " moveSizeWithFreeAspectRatio (  rect   ,  adjX   ,  adjY   ,  bounds   ,  viewWidth   ,  viewHeight   ,  snapMargin   )   "]]
[["SQLiteDatabase db , boolean ifExists", "String sql =  STR_   +  ifExists  ? STR_  : STR_   +  STR_  ", " db.execSQL (  sql   )   "]]
[["String namespaceURI", "   "]]
[["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " if (  m_NewBatch   ) ", " resetQueue (  )   ", " m_NewBatch   =  BOOL_  ", " if (  outputFormatPeek (  )    !=  null   ) ", " convertInstance (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " if (  m_NewBatch   ) ", " resetQueue (  )   ", " m_NewBatch   =  BOOL_  ", " if (  outputFormatPeek (  )    !=  null   ) ", " bufferInput (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " if (  m_NewBatch   ) ", " if (  outputFormatPeek (  )    !=  null   ) ", " convertInstance (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " if (  m_NewBatch   ) ", " if (  outputFormatPeek (  )    !=  null   ) ", " bufferInput (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " new IllegalStateException (  STR_   )   ", " if (  m_NewBatch   ) ", " resetQueue (  )   ", " m_NewBatch   =  BOOL_  ", " if (  outputFormatPeek (  )    !=  null   ) ", " convertInstance (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " new IllegalStateException (  STR_   )   ", " if (  m_NewBatch   ) ", " resetQueue (  )   ", " m_NewBatch   =  BOOL_  ", " if (  outputFormatPeek (  )    !=  null   ) ", " bufferInput (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " new IllegalStateException (  STR_   )   ", " if (  m_NewBatch   ) ", " if (  outputFormatPeek (  )    !=  null   ) ", " convertInstance (  instance   )   ", " return  BOOL_  "], ["Instance instance", " if (  getInputFormat (  )    ==  null   ) ", " new IllegalStateException (  STR_   )   ", " if (  m_NewBatch   ) ", " if (  outputFormatPeek (  )    !=  null   ) ", " bufferInput (  instance   )   ", " return  BOOL_  "]]
[["String args", "boolean enableOutput =  BOOL_  ", "boolean outputToFile =  BOOL_  ", "String inputFolder =  STR_  ", "String outputFolder =  STR_  ", "String workload =  STR_  ", "String vmAllocationPolicy =  STR_  ", "String vmSelectionPolicy =  STR_  ", "String parameter =  STR_  ", " new RandomRunner (  enableOutput   ,  outputToFile   ,  inputFolder   ,  outputFolder   ,  workload   ,  vmAllocationPolicy   ,  vmSelectionPolicy   ,  parameter   )   "]]
[["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " if (  ProtocolDetector.isHttpProtocol (  packet   )    ) ", " if (  ProtocolDetector.isTlsProtocol (  packet   )    ) ", " return  Protocol.OTHER  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " if (  ProtocolDetector.isHttpProtocol (  packet   )    ) ", " if (  ProtocolDetector.isTlsProtocol (  packet   )    ) ", " return  Protocol.TLS  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " if (  ProtocolDetector.isHttpProtocol (  packet   )    ) ", " return  Protocol.HTTP  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " return  Protocol.TOO_SMALL  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", " new IllegalArgumentException (  STR_   )   ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " if (  ProtocolDetector.isHttpProtocol (  packet   )    ) ", " if (  ProtocolDetector.isTlsProtocol (  packet   )    ) ", " return  Protocol.OTHER  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", " new IllegalArgumentException (  STR_   )   ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " if (  ProtocolDetector.isHttpProtocol (  packet   )    ) ", " if (  ProtocolDetector.isTlsProtocol (  packet   )    ) ", " return  Protocol.TLS  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", " new IllegalArgumentException (  STR_   )   ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " if (  ProtocolDetector.isHttpProtocol (  packet   )    ) ", " return  Protocol.HTTP  "], ["InputStream inputStream", " if ( ! inputStream.markSupported (  )    ) ", " new IllegalArgumentException (  STR_   )   ", "byte packet =  new byte [  NUM_   ]   ", " inputStream.mark (  packet.length   )   ", "int read =  inputStream.read (  packet   )   ", " inputStream.reset (  )   ", " if (  read   <  packet.length   ) ", " return  Protocol.TOO_SMALL  "]]
[["int statusCode , Header headers , JSONArray response"]]
[["int length", " larray   =  new AtomicLongArray (  length   )   ", "long ZERO =  Double.doubleToRawLongBits (  NUM_   )   ", "for (  ;  i   <  length   ;  i ++  ) ", " larray.set (  i   ,  ZERO   )   "]]
[["String filePathToSave , String fileContent", "File file =  new File (  filePathToSave   )   ", " Files.createParentDirs (  file   )   ", " Files.write (  fileContent   ,  file   ,  Charset.defaultCharset (  )    )   ", " return  filePathToSave  "]]
[["DataTypeMappingModel object", " return  null  "]]
[["long least , long bound", " if (  least   >=  bound   ) ", " new IllegalArgumentException (  )   ", " return  nextLong (  bound   -  least   )    +  least  "], ["long least , long bound", " if (  least   >=  bound   ) ", " return  nextLong (  bound   -  least   )    +  least  "]]
[["InputStream policyDataStream", " if (  policyDataStream   !=  null   ) ", " if (  defaultPolicyConstraintsLocation   !=  null   && ! defaultPolicyConstraintsLocation.isEmpty (  )    ) ", " return  null  "], ["InputStream policyDataStream", " if (  policyDataStream   !=  null   ) ", " if (  defaultPolicyConstraintsLocation   !=  null   && ! defaultPolicyConstraintsLocation.isEmpty (  )    ) ", " return  load (  defaultPolicyConstraintsLocation   )   "], ["InputStream policyDataStream", " if (  policyDataStream   !=  null   ) ", " return  load (  policyDataStream   )   "]]
[["BitMatrix bitMatrix", "int numRows =  bitMatrix.getHeight (  )   ", "int numColumns =  bitMatrix.getWidth (  )   ", " return  Version.getVersionForDimensions (  numRows   ,  numColumns   )   "]]
[["XPathContext xctxt", " return  m_left.bool (  xctxt   )    ||  m_right.bool (  xctxt   )   "]]
[["Context mContext , Bitmap bitmap", " return  new BitmapDrawable (  bitmap   )   "]]
[["InputStream stream", "byte lengthBytes =  new byte [  Integer.SIZE   /  Byte.SIZE   ]   ", " stream.read (  lengthBytes   )   ", "ByteBuffer buffer =  ByteBuffer.wrap (  lengthBytes   )   ", " buffer.order (  ByteOrder.BIG_ENDIAN   )   ", " return  buffer.getInt (  )   "]]
[["double x , int lag", "double laggedMatrix =  new double [  x.length   -  lag   +  NUM_   ,  lag   ]   ", "for (  ;  j   <  lag   ;  j ++  ) ", "for (  ;  i   <  laggedMatrix.length   ;  i ++  ) ", " laggedMatrix   [  i   ] [  j   ] =  x   [  lag   -  j   -  NUM_   +  i   ]", " return  laggedMatrix  "], ["double x , int lag", "double laggedMatrix =  new double [  x.length   -  lag   +  NUM_   ,  lag   ]   ", "for (  ;  j   <  lag   ;  j ++  ) ", "for (  ;  i   <  laggedMatrix.length   ;  i ++  ) ", " laggedMatrix   [  i   ] [  j   ] =  x   [  lag   -  j   -  NUM_   +  i   ]"]]
[["byte bitarray", "byte temp =  new byte [  bitarray   [  NUM_   ]. length   ,  bitarray.length   ]   ", "for (  ;  ii   <  bitarray.length   ;  ii ++  ) ", "int inverseii =  bitarray.length   -  ii   -  NUM_  ", "for (  ;  jj   <  bitarray   [  NUM_   ]. length   ;  jj ++  ) ", " temp   [  jj   ] [  inverseii   ] =  bitarray   [  ii   ] [  jj   ]", " return  temp  "], ["byte bitarray", "byte temp =  new byte [  bitarray   [  NUM_   ]. length   ,  bitarray.length   ]   ", "for (  ;  ii   <  bitarray.length   ;  ii ++  ) ", "int inverseii =  bitarray.length   -  ii   -  NUM_  ", "for (  ;  jj   <  bitarray   [  NUM_   ]. length   ;  jj ++  ) ", " temp   [  jj   ] [  inverseii   ] =  bitarray   [  ii   ] [  jj   ]"]]
[["String message , Throwable cause", "   "]]
[["char c", "int i =  c  ", "int A =  STR_  ", "int Z =  STR_  ", "int a =  STR_  ", "int z =  STR_  ", "int SHIFT =  a   -  A  ", " if (  i   <  A   ) ", " return  c  "], ["char c", "int i =  c  ", "int A =  STR_  ", "int Z =  STR_  ", "int a =  STR_  ", "int z =  STR_  ", "int SHIFT =  a   -  A  ", " if (  i   <  A   ) ", " if (  i   <=  Z   ) ", " if (  i   <  a   ) ", " if (  i   <=  z   ) ", " return "], ["char c", "int i =  c  ", "int A =  STR_  ", "int Z =  STR_  ", "int a =  STR_  ", "int z =  STR_  ", "int SHIFT =  a   -  A  ", " if (  i   <  A   ) ", " if (  i   <=  Z   ) ", " if (  i   <  a   ) ", " if (  i   <=  z   ) ", " return  c  "], ["char c", "int i =  c  ", "int A =  STR_  ", "int Z =  STR_  ", "int a =  STR_  ", "int z =  STR_  ", "int SHIFT =  a   -  A  ", " if (  i   <  A   ) ", " if (  i   <=  Z   ) ", " if (  i   <  a   ) ", " return  c  "], ["char c", "int i =  c  ", "int A =  STR_  ", "int Z =  STR_  ", "int a =  STR_  ", "int z =  STR_  ", "int SHIFT =  a   -  A  ", " if (  i   <  A   ) ", " if (  i   <=  Z   ) ", " return "]]
[["Map dataModel", " switch (  Latkes.getRuntimeMode (  )    ) ", " case ", " new AssertionError (  )   "], ["Map dataModel", " switch (  Latkes.getRuntimeMode (  )    ) ", " case DEVELOPMENT", " dataModel.put (  Common.MINI_POSTFIX   ,  STR_   )   "], ["Map dataModel", " switch (  Latkes.getRuntimeMode (  )    ) ", " case PRODUCTION", " dataModel.put (  Common.MINI_POSTFIX   ,  Common.MINI_POSTFIX_VALUE   )   "]]
[["MutationEvent evt", " if (  laidoutText   ==  null   ) ", " computeLaidoutText (  ctx   ,  e   ,  getTextNode (  )    )   "]]
[["javax.xml.namespace.QName qname , org.apache.axis.encoding.SerializationContext context", " context.serialize (  qname   ,  null   ,     )   "]]
[["String urlString", " return  reverseUrl (  new URL (  urlString   )    )   "]]
[["GridTab mTab", "int AD_Table_ID =  Env.getContextAsInt (  Env.getCtx (  )    ,  mTab.getWindowNo (  )    ,  STR_   )   ", "ICreateFrom retValue =  null  ", "Class cl =  s_registeredClasses.get (  AD_Table_ID   )   ", " if (  cl   !=  null   ) ", "java.lang.reflect.Constructor ctor =  cl.getConstructor (  GridTab    )   ", " retValue   =  ctor.newInstance (  mTab   )   ", " if (  retValue   ==  null   ) ", " s_log.info (  STR_   +  AD_Table_ID   )   ", " return  null  "], ["GridTab mTab", "int AD_Table_ID =  Env.getContextAsInt (  Env.getCtx (  )    ,  mTab.getWindowNo (  )    ,  STR_   )   ", "ICreateFrom retValue =  null  ", "Class cl =  s_registeredClasses.get (  AD_Table_ID   )   ", " if (  cl   !=  null   ) ", "java.lang.reflect.Constructor ctor =  cl.getConstructor (  GridTab    )   ", " retValue   =  ctor.newInstance (  mTab   )   ", " if (  retValue   ==  null   ) ", " return  retValue  "], ["GridTab mTab", "int AD_Table_ID =  Env.getContextAsInt (  Env.getCtx (  )    ,  mTab.getWindowNo (  )    ,  STR_   )   ", "ICreateFrom retValue =  null  ", "Class cl =  s_registeredClasses.get (  AD_Table_ID   )   ", " if (  cl   !=  null   ) ", " if (  retValue   ==  null   ) ", " s_log.info (  STR_   +  AD_Table_ID   )   ", " return  null  "], ["GridTab mTab", "int AD_Table_ID =  Env.getContextAsInt (  Env.getCtx (  )    ,  mTab.getWindowNo (  )    ,  STR_   )   ", "ICreateFrom retValue =  null  ", "Class cl =  s_registeredClasses.get (  AD_Table_ID   )   ", " if (  cl   !=  null   ) ", " if (  retValue   ==  null   ) ", " return  retValue  "]]
[["MultiMap headers", "String serverTimestamp =  headers.get (  SERVER_TIMESTAMP_HEADER   )   ", " if (  serverTimestamp   ==  null   ) ", "String nowAsISO =  dfISO8601.print (  Instant.now (  )    )   ", " log.debug (  STR_   +  SERVER_TIMESTAMP_HEADER   +  STR_   +  nowAsISO   +  STR_   +  SERVER_TIMESTAMP_HEADER   +  STR_   )   ", " headers.set (  SERVER_TIMESTAMP_HEADER   ,  nowAsISO   )   "], ["MultiMap headers", "String serverTimestamp =  headers.get (  SERVER_TIMESTAMP_HEADER   )   ", " if (  serverTimestamp   ==  null   ) ", "String updatedTimestamp =  localizeTimestamp (  serverTimestamp   )   ", " if ( ! updatedTimestamp.equals (  serverTimestamp   )    ) ", " log.debug (  STR_   +  SERVER_TIMESTAMP_HEADER   +  STR_   +  serverTimestamp   +  STR_   +  updatedTimestamp   )   ", " headers.remove (  SERVER_TIMESTAMP_HEADER   )   ", " headers.set (  SERVER_TIMESTAMP_HEADER   ,  updatedTimestamp   )   "]]
[["double x1 , double y1 , double x2 , double y2", " return  Math.sqrt (  y2   -  y1   *  y2   -  y1   +  x2   -  x1   *  x2   -  x1   )   "]]
[["  wait (  )     . wait (  )   "]]
[["Object value", " return "]]
[["Node n", " if (  pag.getTypeManager (  )   . castNeverFails (  n.getType (  )    ,  type   )    ) ", " return  fastAdd (  n   )   "], ["Node n", " if (  pag.getTypeManager (  )   . castNeverFails (  n.getType (  )    ,  type   )    ) ", " return  BOOL_  "]]
[["String name , Class c", "  name    . name   =  name  ", "  c    . c   =  c  ", "  optional    . optional   =  BOOL_  "]]
[["CoordinatorClient coordinatorClient", "   "]]
[["String jndiName =  STR_  ", "String propertyString =  DatasourcePropertySet.JNDI_LOCATION   +  STR_   +  jndiName  ", "DataSource ds =  dataSourceConverter.fromPropertyString (  propertyString   )   ", " assertEquals (  jndiName   ,  ds.getId (  )    )   "]]
[["String errorMessage", "String error =  errorMessage   !=  null  ? errorMessage  : null  ", " if (  error   ==  null   ) ", " return  NUM_  "], ["String errorMessage", "String error =  errorMessage   !=  null  ? errorMessage  : null  ", " if (  error   ==  null   ) ", " if (  error.equals (  DAILY_TRANSACTION_LIMIT_EXCEEDED   )    ) ", " return  NUM_  "], ["String errorMessage", "String error =  errorMessage   !=  null  ? errorMessage  : null  ", " if (  error   ==  null   ) ", " if (  error.equals (  DAILY_TRANSACTION_LIMIT_EXCEEDED   )    ) ", " if (  error.equals (  INVALID_API_KEY   )    ) ", " return  NUM_  "], ["String errorMessage", "String error =  errorMessage   !=  null  ? errorMessage  : null  ", " if (  error   ==  null   ) ", " if (  error.equals (  DAILY_TRANSACTION_LIMIT_EXCEEDED   )    ) ", " if (  error.equals (  INVALID_API_KEY   )    ) ", " return  NUM_  "]]
[[" return    "]]
[["int nQueryHandle", " if ( ! m_prologTable.containsKey (  new Integer (  nQueryHandle   )    )    ) ", "AsyncWAMManager container", " if (  container.isRunning (  )    ) ", " notifyMore (  nQueryHandle   )   ", " container.next (  )   "], ["int nQueryHandle", " if ( ! m_prologTable.containsKey (  new Integer (  nQueryHandle   )    )    ) ", "AsyncWAMManager container", " if (  container.isRunning (  )    ) ", " new JIPIsRunningException (  )   ", " notifyMore (  nQueryHandle   )   ", " container.next (  )   "], ["int nQueryHandle", " if ( ! m_prologTable.containsKey (  new Integer (  nQueryHandle   )    )    ) ", " new JIPInvalidHandleException (  )   ", "AsyncWAMManager container", " if (  container.isRunning (  )    ) ", " notifyMore (  nQueryHandle   )   ", " container.next (  )   "], ["int nQueryHandle", " if ( ! m_prologTable.containsKey (  new Integer (  nQueryHandle   )    )    ) ", " new JIPInvalidHandleException (  )   ", "AsyncWAMManager container", " if (  container.isRunning (  )    ) ", " new JIPIsRunningException (  )   ", " notifyMore (  nQueryHandle   )   ", " container.next (  )   "]]
[["int types", "for (  ;  i   <  rsmd.getColumnCount (  )    ;  i ++  ) ", "int type =  rsmd.getColumnType (  i   +  NUM_   )   ", " assertEquals (  types   [  i   ] ,  type   )   "], ["int types", "for (  ;  i   <  rsmd.getColumnCount (  )    ;  i ++  ) ", "int type =  rsmd.getColumnType (  i   +  NUM_   )   ", " assertEquals (  types   [  i   ] ,  type   )   ", " rsmd.getColumnType (  NUM_   )   ", " fail (  STR_   )   ", " rsmd.getColumnType (  NUM_   )   ", " fail (  STR_   )   "]]
[["String name , byte value", "   "]]
[["ProtectionSystem protectionSystem", "ProtectionController controller =  getProtectionController (  protectionSystem.getSystemType (  )    )   ", " controller.disconnect (  protectionSystem.getId (  )    )   "]]
[[" return  consolidationNeeded  "]]
[["fr.gael.dhus.database.object.Product product", "   "]]
[["Object o", "ReentrantLock lock =   lock    . lock  ", " lock.lock (  )   ", " return  q.remove (  o   )   "]]
[["Collection linearRings", "LinearRing linearRingArray =  new LinearRing [  linearRings.size (  )    ]   ", " return "]]
[["int c", " c   =  readCodePoint (  )   ", " c   =  skipWhitespace (  c   )   ", " if (  c   ==  STR_   ) ", " if (  c   != - NUM_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", " return  c  "], ["int c", " c   =  readCodePoint (  )   ", " c   =  skipWhitespace (  c   )   ", " if (  c   ==  STR_   ) ", " if (  c   != - NUM_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", " reportFatalError (  STR_   )   ", " return  c  "], ["int c", " c   =  readCodePoint (  )   ", " c   =  skipWhitespace (  c   )   ", " if (  c   ==  STR_   ) ", " return  c  "]]
[["   "]]
[[" configuration.configure (  container   )   ", "String config =  configuration.getFileHandler (  )   . readTextFile (  configuration.getHome (  )    +  STR_   ,  STR_   )   ", " XMLAssert.assertXpathEvaluatesTo (  configuration.getPropertyValue (  ServletPropertySet.PORT   )    ,  STR_   ,  config   )   "]]
[["BinaryNode node", " if (  node   ==  null   ) ", "BinaryNode newNode =  new BinaryNode (  node.value   ,  node.left   ,  null   )   ", " node.left   =  newNode  ", " doubleTree (  newNode.left   )   ", " doubleTree (  node.right   )   "], ["BinaryNode node", " if (  node   ==  null   ) ", " return "]]
[["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", " convergenceIterations ++ ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", " convergenceIterations ++ ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " if (  hasConverged.apply (  A   )    ) "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", " convergenceIterations ++ ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " if (  hasConverged.apply (  A   )    ) ", " return  i  "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", " convergenceIterations ++ ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " if (  hasConverged.apply (  A   )    ) ", " return  i  "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", " convergenceIterations ++ ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " return  i  "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " if (  hasConverged.apply (  A   )    ) "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " if (  hasConverged.apply (  A   )    ) ", " return  i  "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " if (  hasConverged.apply (  A   )    ) ", " return  i  "], ["DoubleMatrix2D A , cern.colt.function.Double9Function function , int maxIterations , DoubleMatrix2DProcedure hasConverged , int convergenceIterations", "DoubleMatrix2D B =  A.copy (  )   ", " if (  convergenceIterations   <=  NUM_   ) ", " if (  convergenceIterations   %  NUM_   !=  NUM_   ) ", "int i =  NUM_  ", "while (  i   <  maxIterations   )", " A.zAssign8Neighbors (  B   ,  function   )   ", " B.zAssign8Neighbors (  A   ,  function   )   ", " i   =  i   +  NUM_  ", " if (  i   %  convergenceIterations   ==  NUM_   &&  hasConverged   !=  null   ) ", " return  i  "]]
[["String facet", "Map f =  queryFacetCollectors.get (  facet   )   ", "for ( StatsCollector arr :  f.values (  )    )", "for ( StatsCollector b :  arr   )", " b.compute (  )   "]]
[["boolean local", "  local    . local   =  local  ", " return    "]]
[["int progress", " if (  myHost   !=  null   ) ", " myHost.updateProgress (  progress   )   "], ["int progress", " if (  myHost   !=  null   ) ", " System.out.println (  STR_   +  progress   +  STR_   )   "]]
[["Technique technique", " mTechnique   =  technique  ", " return    "]]
[["StringBuilder sb =  new StringBuilder (  )   ", " sb.append (  getClass (  )   . getSimpleName (  )    )   . append (  STR_   )   . append (  id   )   . append (  STR_   )   . append (  sizeRecords (  )    )   . append (  STR_   )   . append (  sizeBytes (  )    )   . append (  STR_   )   ", " return  sb.toString (  )   "]]
[["Context context , int blockSourceIds", "   ", " if (  blockSourceIds   !=  null   ) ", "for (  ;  i   <  blockSourceIds.length   ;  i ++  ) ", " addBlocks (  blockSourceIds   [  i   ] )   "]]
[["int initialCapacity , String label", "   "]]
[["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  null  ", " pred   =  last  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " first   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " last   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  null  ", " pred   =  last  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " first   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " pred.next   =  succ  ", " succ.prev   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  null  ", " pred   =  last  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " first   =  newNode  ", " pred   =  newNode  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  null  ", " pred   =  last  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " pred.next   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " last   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  null  ", " pred   =  last  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " pred.next   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " pred.next   =  succ  ", " succ.prev   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  null  ", " pred   =  last  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " pred.next   =  newNode  ", " pred   =  newNode  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  node (  index   )   ", " pred   =  succ.prev  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " first   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " last   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  node (  index   )   ", " pred   =  succ.prev  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " first   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " pred.next   =  succ  ", " succ.prev   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  node (  index   )   ", " pred   =  succ.prev  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " first   =  newNode  ", " pred   =  newNode  "], ["int index , Collection c", " checkPositionIndex (  index   )   ", "Object a =  c.toArray (  )   ", "int numNew =  a.length  ", " if (  numNew   ==  NUM_   ) ", "Node pred , succ", " if (  index   ==  size   ) ", " succ   =  node (  index   )   ", " pred   =  succ.prev  ", "for ( Object o :  a   )", "E e", "Node newNode =  new Node (  pred   ,  e   ,  null   )   ", " if (  pred   ==  null   ) ", " pred.next   =  newNode  ", " pred   =  newNode  ", " if (  succ   ==  null   ) ", " last   =  pred  ", " size   +=  numNew  ", " modCount ++ ", " return  BOOL_  "]]
[["String query", "Statement stmt =  null  ", " stmt   =  conn.createStatement (  )   ", " stmt.execute (  query   )   "]]
[[" header   =  new Node (  )   "]]
[["String skillcaster , String skillname", " return  new SM_SYSTEM_MESSAGE (  NUM_   ,  skillcaster   ,  skillname   )   "]]
[[" return    "]]
[["String name , int parentId , boolean isFixed", "FolderTokenDivider div", "int id", " id   =    ", " div   =  new FolderTokenDivider (  id   ,  name   ,  parentId   ,  isFixed   ,  FolderEditFlag.NEW   )   ", "   ", " return  id  "]]
[["Region rgn", " return  rgn.getTaintInt (  )    +  getTaintInt (  )    ==  NUM_  "]]
[["DataEditor editor", "   ", " if (  editor   ==  null   ) ", " new NullPointerException (  )   ", "  dataEditor    . dataEditor   =  editor  "], ["DataEditor editor", "   ", " if (  editor   ==  null   ) ", "  dataEditor    . dataEditor   =  editor  "]]
[["String args", " DOMTestCase.doMain (  hc_elementgetelementsbytagnamenomatch    ,  args   )   "]]
[["Connection c =  Connections.getInstance (  context   )   . getConnection (  clientHandle   )   ", "String actionTaken =  context.getString (  R.string.toast_sub_success   ,  )   ", " c.addAction (  actionTaken   )   ", " Notify.toast (  context   ,  actionTaken   ,  Toast.LENGTH_SHORT   )   "]]
[["String text", " if (  text   ==  null   ) ", " return  null  "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   ", " return  result.toString (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   ", " return  result.toString (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   ", " return  result.toString (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  STR_   )   ", " character   =  iterator.next (  )   ", " return  result.toString (  )   "], ["String text", " if (  text   ==  null   ) ", "StringBuilder result =  new StringBuilder (  )   ", "StringCharacterIterator iterator =  new StringCharacterIterator (  text   )   ", "char character =  iterator.current (  )   ", "while (  character   !=  CharacterIterator.DONE   )", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " if (  character   ==  STR_   ) ", " result.append (  character   )   ", " character   =  iterator.next (  )   "]]
[["String x", " if (  x.length (  )    ==  NUM_   ) ", " return  Long.parseLong (  x   ,  NUM_   )   "], ["String x", " if (  x.length (  )    ==  NUM_   ) ", " return  Long.parseLong (  x.substring (  NUM_   ,  NUM_   )    ,  NUM_   )    <<  NUM_   |  Long.parseLong (  x.substring (  NUM_   ,  NUM_   )    ,  NUM_   )   "]]
[["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " _logger.severe (  msg   )   ", " _logger.showGlobalTrace (  )   ", " if (  _disableDuplicateLoadProtection   ) ", " new IllegalArgumentException (  msg   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " _logger.severe (  msg   )   ", " _logger.showGlobalTrace (  )   ", " if (  _disableDuplicateLoadProtection   ) ", " new IllegalArgumentException (  msg   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _logger.finest (  STR_   +  className   +  STR_   +     )   ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " _logger.severe (  msg   )   ", " _logger.showGlobalTrace (  )   ", " if (  _disableDuplicateLoadProtection   ) ", " _logger.warning (  toString (  )    +  STR_   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " _logger.severe (  msg   )   ", " _logger.showGlobalTrace (  )   ", " if (  _disableDuplicateLoadProtection   ) ", " _logger.warning (  toString (  )    +  STR_   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _logger.finest (  STR_   +  className   +  STR_   +     )   ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " if (  _disableDuplicateLoadProtection   ) ", " new IllegalArgumentException (  msg   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " if (  _disableDuplicateLoadProtection   ) ", " new IllegalArgumentException (  msg   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _logger.finest (  STR_   +  className   +  STR_   +     )   ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " if (  _disableDuplicateLoadProtection   ) ", " _logger.warning (  toString (  )    +  STR_   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", "String msg =  toString (  )    +  STR_   +  className   +  STR_  ", " if (  _logger.isLoggable (  Level.SEVERE   )    ) ", " if (  _disableDuplicateLoadProtection   ) ", " _logger.warning (  toString (  )    +  STR_   )   ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _logger.finest (  STR_   +  className   +  STR_   +     )   ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _classBytesByName.put (  className   ,  definition   )   "], ["String className , byte definition", " if (  _classBytesByName.containsKey (  className   )    ) ", " if (  _logger.isLoggable (  Level.FINEST   )    ) ", " _logger.finest (  STR_   +  className   +  STR_   +     )   ", " _classBytesByName.put (  className   ,  definition   )   "]]
[["double keys , int vals , int start , int end", "for (  ;  i   <  end   ;  i ++  ) ", "for (  ;  j   >  start   ;  j --  ) ", " if (  keys   [  j   ] <=  keys   [  j   -  NUM_   ] ) ", " swap (  keys   ,  vals   ,  j   ,  j   -  NUM_   )   "]]
[["Path path", " if (   historyPointer    . historyPointer   ==   pathLists   ,  size (  )     . pathLists  . size (  )    ) ", "  pathLists   ,  set (   historyPointer    . historyPointer   ,  path   )     . pathLists  . set (   historyPointer    . historyPointer   ,  path   )   ", "  paintLists   ,  set (   historyPointer    . historyPointer   ,   createPaint (  )     . createPaint (  )    )     . paintLists  . set (   historyPointer    . historyPointer   ,   createPaint (  )     . createPaint (  )    )   ", "  historyPointer   ++ . historyPointer  ", "for (  ;  i   <  size   ;  i ++  ) ", "  pathLists   ,  remove (   historyPointer    . historyPointer   )     . pathLists  . remove (   historyPointer    . historyPointer   )   ", "  paintLists   ,  remove (   historyPointer    . historyPointer   )     . paintLists  . remove (   historyPointer    . historyPointer   )   "], ["Path path", " if (   historyPointer    . historyPointer   ==   pathLists   ,  size (  )     . pathLists  . size (  )    ) ", "  pathLists   ,  add (  path   )     . pathLists  . add (  path   )   ", "  paintLists   ,  add (   createPaint (  )     . createPaint (  )    )     . paintLists  . add (   createPaint (  )     . createPaint (  )    )   ", "  historyPointer   ++ . historyPointer  "]]
[["String s , Object params", " if (  isEnabled (  TraceSystem.DEBUG   )    ) ", " s   =  MessageFormat.format (  s   ,  params   )   ", " traceWriter.write (  TraceSystem.DEBUG   ,  s   ,  null   )   "]]
[["ElementKey entryKey", "E entry", " entry   =  Element.createElement (  entryKey   )   ", " if (  feedState.service   !=  null   ) ", " return  entry  "], ["ElementKey entryKey", "E entry", " entry   =  Element.createElement (  entryKey   )   ", " if (  feedState.service   !=  null   ) ", " entry.setService (  feedState.service   )   ", " return  entry  "]]
[["HeadTransform headTransform", " headTransform.getEulerAngles (  mEulerAngles   ,  NUM_   )   ", " if (  i   %  NUM_   ==  NUM_   ) ", " Log.i (  TAG   ,  mEulerAngles   [  NUM_   ] +  STR_   +  mEulerAngles   [  NUM_   ] +  STR_   +  mEulerAngles   [  NUM_   ] )   ", " i ++ ", " if (  tracking   ) ", " shift (  )   ", " mQueue.addRequest (  mEulerAngles   [  NUM_   ] ,  mEulerAngles   [  NUM_   ] )   "], ["HeadTransform headTransform", " headTransform.getEulerAngles (  mEulerAngles   ,  NUM_   )   ", " if (  i   %  NUM_   ==  NUM_   ) ", " i ++ ", " if (  tracking   ) ", " shift (  )   ", " mQueue.addRequest (  mEulerAngles   [  NUM_   ] ,  mEulerAngles   [  NUM_   ] )   "]]
[["Lesson lesson , Long lessonStepId", "LessonStep lessonStep =   lessonStepRepository   ,  findByLessonAndId (  lesson   ,  lessonStepId   )    ,  orElseThrow (  null   )     . lessonStepRepository  . findByLessonAndId (  lesson   ,  lessonStepId   )   . orElseThrow (  null   )   ", " return  lessonStep  "]]
[["float rotationY", " return  property (  STR_   ,  rotationY   )   "]]
[["ApiClient actor , InputStream is , MapsService maps , boolean preview , PrintWriter pw", "BaseEntry entry", " entry   =  actor.parseAtom (  is   )   ", " if (  draft   ) ", " entry.setDraft (  BOOL_   )   ", " if (  preview   ) ", " pp (  maps   ,  entry   ,  pw   )   ", " return  entry  "], ["ApiClient actor , InputStream is , MapsService maps , boolean preview , PrintWriter pw", "BaseEntry entry", " entry   =  actor.parseAtom (  is   )   ", " if (  draft   ) ", " entry.setDraft (  BOOL_   )   ", " if (  preview   ) ", " return  entry  "], ["ApiClient actor , InputStream is , MapsService maps , boolean preview , PrintWriter pw", "BaseEntry entry", " entry   =  actor.parseAtom (  is   )   ", " if (  draft   ) ", " if (  preview   ) ", " pp (  maps   ,  entry   ,  pw   )   ", " return  entry  "], ["ApiClient actor , InputStream is , MapsService maps , boolean preview , PrintWriter pw", "BaseEntry entry", " entry   =  actor.parseAtom (  is   )   ", " if (  draft   ) ", " if (  preview   ) ", " return  entry  "]]
[["Context context", " return  context.getResources (  )   . getConfiguration (  )   . screenLayout   &  Configuration.SCREENLAYOUT_SIZE_MASK   >=  Configuration.SCREENLAYOUT_SIZE_XLARGE  "]]
[["Collection intervalSets", " return  intervalSets.stream (  )   . flatMap (  null   )   . map (  null   )   . reduce (  null   )   "]]
[[" return  BOOL_  "]]
[[" if (  openReaderCount.decrementAndGet (  )    ==  NUM_   ) ", " notifyAll (  )   "]]
[["int size , int seed", " if (  size   >  NUM_   ) ", " return  null  "], ["int size , int seed", " if (  size   >  NUM_   ) ", " seed   =  random (  seed   )   ", "int next_val =  seed   %  RANGE  ", "BiSortVal retval =  new BiSortVal (  next_val   )   ", " retval.left   =  createTree (  size   /  NUM_   ,  seed   )   ", " retval.right   =  createTree (  size   /  NUM_   ,  skiprand (  seed   ,  size   +  NUM_   )    )   ", " return  retval  "]]
[["int from , int to", " if (  size   ==  NUM_   ) ", " return  BOOL_  "], ["int from , int to", " if (  size   ==  NUM_   ) ", " checkRangeFromTo (  from   ,  to   ,  size   )   ", "Object theElements =  elements  ", "for (  ;  i   <=  to   ;  i ++  ) ", " if (  <  NUM_   ) ", " return  BOOL_  "], ["int from , int to", " if (  size   ==  NUM_   ) ", " checkRangeFromTo (  from   ,  to   ,  size   )   ", "Object theElements =  elements  ", "for (  ;  i   <=  to   ;  i ++  ) ", " if (  <  NUM_   ) "], ["int from , int to", " if (  size   ==  NUM_   ) ", " checkRangeFromTo (  from   ,  to   ,  size   )   ", "Object theElements =  elements  ", "for (  ;  i   <=  to   ;  i ++  ) ", " if (  <  NUM_   ) ", " return  BOOL_  "]]
[["SimEvent ev , boolean ack", "Vm vm", " getVmAllocationPolicy (  )   . deallocateHostForVm (  vm   )   ", " if (  ack   ) ", " getVmList (  )   . remove (  vm   )   "], ["SimEvent ev , boolean ack", "Vm vm", " getVmAllocationPolicy (  )   . deallocateHostForVm (  vm   )   ", " if (  ack   ) ", "int data =  new int [  NUM_   ]   ", " data   [  NUM_   ] =  getId (  )   ", " data   [  NUM_   ] =  vm.getId (  )   ", " data   [  NUM_   ] =  CloudSimTags.TRUE  ", " sendNow (  vm.getUserId (  )    ,  CloudSimTags.VM_DESTROY_ACK   ,  data   )   ", " getVmList (  )   . remove (  vm   )   "]]
[["EventBean eventsPerStream , boolean isNewData", "EventBean theEvent =  eventsPerStream   [  streamNum   ]", " if (  theEvent   ==  null   ) ", " return  BOOL_  "], ["EventBean eventsPerStream , boolean isNewData", "EventBean theEvent =  eventsPerStream   [  streamNum   ]", " if (  theEvent   ==  null   ) ", " return  propertyGetter.isExistsProperty (  theEvent   )   "]]
[["ChanceNode cn =  new ChanceNode (  nodeId   ,  distrib.copy (  )    )   ", " if (  cachedValues   !=  null   ) ", " return  cn  "], ["ChanceNode cn =  new ChanceNode (  nodeId   ,  distrib.copy (  )    )   ", " if (  cachedValues   !=  null   ) ", " cn.cachedValues   =  new HashSet (  cachedValues   )   ", " return  cn  "]]
[["PassThroughOrGenerateRuleCondition condition", " generateConditions.add (  condition   )   "]]
[["JavacTreeMaker maker , JavacNode variable , JavacNode source", "NullCheckExceptionType exceptionType =  source.getAst (  )   . readConfiguration (  ConfigurationKeys.NON_NULL_EXCEPTION_TYPE   )   ", " if (  exceptionType   ==  null   ) ", "JCVariableDecl varDecl", " if (  isPrimitive (  varDecl.vartype   )    ) ", "Name fieldName =  varDecl.name  ", "JCExpression exType =  genTypeRef (  variable   ,  exceptionType.getExceptionType (  )    )   ", "JCExpression exception =  maker.NewClass (  null   ,  List (  )    ,  exType   ,  List (  maker.Literal (  exceptionType.toExceptionMessage (  fieldName.toString (  )    )    )    )    ,  null   )   ", "JCStatement throwStatement =  maker.Throw (  exception   )   ", "JCBlock throwBlock =  maker.Block (  NUM_   ,  List.of (  throwStatement   )    )   ", " return  maker.If (  maker.Binary (  CTC_EQUAL   ,  maker.Ident (  fieldName   )    ,  maker.Literal (  CTC_BOT   ,  null   )    )    ,  throwBlock   ,  null   )   "], ["JavacTreeMaker maker , JavacNode variable , JavacNode source", "NullCheckExceptionType exceptionType =  source.getAst (  )   . readConfiguration (  ConfigurationKeys.NON_NULL_EXCEPTION_TYPE   )   ", " if (  exceptionType   ==  null   ) ", "JCVariableDecl varDecl", " if (  isPrimitive (  varDecl.vartype   )    ) ", " return  null  "], ["JavacTreeMaker maker , JavacNode variable , JavacNode source", "NullCheckExceptionType exceptionType =  source.getAst (  )   . readConfiguration (  ConfigurationKeys.NON_NULL_EXCEPTION_TYPE   )   ", " if (  exceptionType   ==  null   ) ", " exceptionType   =  NullCheckExceptionType.NULL_POINTER_EXCEPTION  ", "JCVariableDecl varDecl", " if (  isPrimitive (  varDecl.vartype   )    ) ", "Name fieldName =  varDecl.name  ", "JCExpression exType =  genTypeRef (  variable   ,  exceptionType.getExceptionType (  )    )   ", "JCExpression exception =  maker.NewClass (  null   ,  List (  )    ,  exType   ,  List (  maker.Literal (  exceptionType.toExceptionMessage (  fieldName.toString (  )    )    )    )    ,  null   )   ", "JCStatement throwStatement =  maker.Throw (  exception   )   ", "JCBlock throwBlock =  maker.Block (  NUM_   ,  List.of (  throwStatement   )    )   ", " return  maker.If (  maker.Binary (  CTC_EQUAL   ,  maker.Ident (  fieldName   )    ,  maker.Literal (  CTC_BOT   ,  null   )    )    ,  throwBlock   ,  null   )   "], ["JavacTreeMaker maker , JavacNode variable , JavacNode source", "NullCheckExceptionType exceptionType =  source.getAst (  )   . readConfiguration (  ConfigurationKeys.NON_NULL_EXCEPTION_TYPE   )   ", " if (  exceptionType   ==  null   ) ", " exceptionType   =  NullCheckExceptionType.NULL_POINTER_EXCEPTION  ", "JCVariableDecl varDecl", " if (  isPrimitive (  varDecl.vartype   )    ) ", " return  null  "]]
[["StateHolder state , Guard guard", " Assert.notNull (  state   ,  STR_   )   ", "  state    . state   =  state  ", "  guard    . guard   =  guard  "]]
[["double array , int offset", " if (  array   ==  null   ) ", "String msg =  Logging.getMessage (  STR_   )   ", " Logging.logger (  )   . severe (  msg   )   ", " new IllegalArgumentException (  msg   )   ", " return  fromDoubleArray (  array   ,  offset   ,  NUM_   )   "], ["double array , int offset", " if (  array   ==  null   ) ", " return  fromDoubleArray (  array   ,  offset   ,  NUM_   )   "]]
[["int size", "  size    . size   =  size  ", " cache   =  new LRUCache (  )   "]]
[["InputStream input , File file", "byte buffer =  new byte [  NUM_   ]   ", "while (  BOOL_   )", "int n =  input.read (  buffer   )   ", " if (  n   <=  NUM_   ) ", " output.write (  buffer   ,  NUM_   ,  n   )   "]]
[["Object id", "String str =  STR_   +  id  ", " if (  str.matches (  STR_   )    ) ", " return  str   +  STR_  "], ["Object id", "String str =  STR_   +  id  ", " if (  str.matches (  STR_   )    ) ", " return "]]
[]
[["String lastUsedPath =  getDialogSetting (  LAST_PATH_SETTING   )   ", " if (  lastUsedPath   ==  null   ) ", " lastUsedPath   =  STR_  ", "FileDialog dialog =  new FileDialog (  getShell (  )    ,  SWT.MULTI   )   ", " dialog.setText (  STR_   )   ", " dialog.setFilterPath (  lastUsedPath   )   ", "String res =  dialog.open (  )   ", " if (  res   ==  null   ) ", "IPath filterPath =  new Path (  dialog.getFilterPath (  )    )   ", "IRuntimeClasspathEntry elems =  new IRuntimeClasspathEntry [  NUM_   ]   ", "IPath path =  new Path (  res   )   . makeAbsolute (  )   ", " elems   [  NUM_   ] =  JavaRuntime.newArchiveRuntimeClasspathEntry (  path   )   ", " setDialogSetting (  LAST_PATH_SETTING   ,  filterPath.toOSString (  )    )   ", " getViewer (  )   . addEntries (  elems   )   "], ["String lastUsedPath =  getDialogSetting (  LAST_PATH_SETTING   )   ", " if (  lastUsedPath   ==  null   ) ", " lastUsedPath   =  STR_  ", "FileDialog dialog =  new FileDialog (  getShell (  )    ,  SWT.MULTI   )   ", " dialog.setText (  STR_   )   ", " dialog.setFilterPath (  lastUsedPath   )   ", "String res =  dialog.open (  )   ", " if (  res   ==  null   ) ", " return "], ["String lastUsedPath =  getDialogSetting (  LAST_PATH_SETTING   )   ", " if (  lastUsedPath   ==  null   ) ", "FileDialog dialog =  new FileDialog (  getShell (  )    ,  SWT.MULTI   )   ", " dialog.setText (  STR_   )   ", " dialog.setFilterPath (  lastUsedPath   )   ", "String res =  dialog.open (  )   ", " if (  res   ==  null   ) ", "IPath filterPath =  new Path (  dialog.getFilterPath (  )    )   ", "IRuntimeClasspathEntry elems =  new IRuntimeClasspathEntry [  NUM_   ]   ", "IPath path =  new Path (  res   )   . makeAbsolute (  )   ", " elems   [  NUM_   ] =  JavaRuntime.newArchiveRuntimeClasspathEntry (  path   )   ", " setDialogSetting (  LAST_PATH_SETTING   ,  filterPath.toOSString (  )    )   ", " getViewer (  )   . addEntries (  elems   )   "], ["String lastUsedPath =  getDialogSetting (  LAST_PATH_SETTING   )   ", " if (  lastUsedPath   ==  null   ) ", "FileDialog dialog =  new FileDialog (  getShell (  )    ,  SWT.MULTI   )   ", " dialog.setText (  STR_   )   ", " dialog.setFilterPath (  lastUsedPath   )   ", "String res =  dialog.open (  )   ", " if (  res   ==  null   ) ", " return "]]
[["int interruptMode", " if (  interruptMode   ==  THROW_IE   ) ", " if (  interruptMode   ==  REINTERRUPT   ) ", " selfInterrupt (  )   "], ["int interruptMode", " if (  interruptMode   ==  THROW_IE   ) ", " new InterruptedException (  )   "]]
[]
[["ByteBuffer bytes , boolean sync , IOCallback callback", " checkOpened (  )   ", "int bytesToWrite =  factory.calculateBlockSize (  bytes.limit (  )    )   ", "long positionToWrite =  position.getAndAdd (  bytesToWrite   )   ", "AIOSequentialFileFactory.AIOSequentialCallback runnableCallback =  getCallback (  callback   ,  bytes   )   ", " runnableCallback.initWrite (  positionToWrite   ,  bytesToWrite   )   ", " if (  writerExecutor   !=  null   ) ", " writerExecutor.execute (  runnableCallback   )   "], ["ByteBuffer bytes , boolean sync , IOCallback callback", " checkOpened (  )   ", "int bytesToWrite =  factory.calculateBlockSize (  bytes.limit (  )    )   ", "long positionToWrite =  position.getAndAdd (  bytesToWrite   )   ", "AIOSequentialFileFactory.AIOSequentialCallback runnableCallback =  getCallback (  callback   ,  bytes   )   ", " runnableCallback.initWrite (  positionToWrite   ,  bytesToWrite   )   ", " if (  writerExecutor   !=  null   ) ", " runnableCallback.run (  )   "]]
[["ByteBuffer src", "int pos =  src.position (  )   ", "int len =  src.remaining (  )   ", " if (  src.isDirect (  )    ) ", "ByteBuffer buf =  ByteBuffer.allocateDirect (  len   )   ", "long addr =  memoryAddress (  buf   )   ", " buf.put (  src   )   ", "int netWrote =  SSL.writeToBIO (  networkBIO   ,  addr   ,  len   )   ", " if (  netWrote   >=  NUM_   ) ", " src.position (  pos   )   ", " return - NUM_  "], ["ByteBuffer src", "int pos =  src.position (  )   ", "int len =  src.remaining (  )   ", " if (  src.isDirect (  )    ) ", "ByteBuffer buf =  ByteBuffer.allocateDirect (  len   )   ", "long addr =  memoryAddress (  buf   )   ", " buf.put (  src   )   ", "int netWrote =  SSL.writeToBIO (  networkBIO   ,  addr   ,  len   )   ", " if (  netWrote   >=  NUM_   ) ", " src.position (  pos   +  netWrote   )   ", " return  netWrote  "], ["ByteBuffer src", "int pos =  src.position (  )   ", "int len =  src.remaining (  )   ", " if (  src.isDirect (  )    ) ", "long addr =  Buffer.address (  src   )    +  pos  ", "int netWrote =  SSL.writeToBIO (  networkBIO   ,  addr   ,  len   )   ", " if (  netWrote   >=  NUM_   ) ", " return - NUM_  "], ["ByteBuffer src", "int pos =  src.position (  )   ", "int len =  src.remaining (  )   ", " if (  src.isDirect (  )    ) ", "long addr =  Buffer.address (  src   )    +  pos  ", "int netWrote =  SSL.writeToBIO (  networkBIO   ,  addr   ,  len   )   ", " if (  netWrote   >=  NUM_   ) ", " src.position (  pos   +  netWrote   )   ", " return  netWrote  "]]
[["StackMap sm", " info   =  sm.get (  )   "]]
[["Particle that", "double dx =  that.rx   -   rx    . rx  ", "double dy =  that.ry   -   ry    . ry  ", "double dvx =  that.vx   -   vx    . vx  ", "double dvy =  that.vy   -   vy    . vy  ", "double dvdr =  dx   *  dvx   +  dy   *  dvy  ", "double dist =   radius    . radius   +  that.radius  ", "double magnitude =  NUM_   *   mass    . mass   *  that.mass   *  dvdr   /   mass    . mass   +  that.mass   *  dist  ", "double fx =  magnitude   *  dx   /  dist  ", "double fy =  magnitude   *  dy   /  dist  ", "  vx    . vx   +=  fx   /   mass    . mass  ", "  vy    . vy   +=  fy   /   mass    . mass  ", " that.vx   -=  fx   /  that.mass  ", " that.vy   -=  fy   /  that.mass  ", "  count   ++ . count  ", " that.count ++ "]]
[["String value , String substring", " return  value   !=  null   &&  substring   !=  null  ? value.indexOf (  substring   )   :- NUM_  "]]
[[" if (  suspendHelper (  )    ) ", " Thread.currentThread (  )   . suspend (  )   "]]
[["float data , int inds", "float mean =  NUM_  ", "for (  ;  i   <  inds.length   ;  i ++  ) ", " if (  Float.isNaN (  data   [  inds   [  i   ] ] )    ) ", " new IllegalArgumentException (  STR_   )   ", " mean   +=  data   [  inds   [  i   ] ]"], ["float data , int inds", "float mean =  NUM_  ", "for (  ;  i   <  inds.length   ;  i ++  ) ", " if (  Float.isNaN (  data   [  inds   [  i   ] ] )    ) ", " new IllegalArgumentException (  STR_   )   ", " mean   +=  data   [  inds   [  i   ] ]", " mean   /=  inds.length  ", " return  mean  "], ["float data , int inds", "float mean =  NUM_  ", "for (  ;  i   <  inds.length   ;  i ++  ) ", " if (  Float.isNaN (  data   [  inds   [  i   ] ] )    ) ", " mean   +=  data   [  inds   [  i   ] ]"], ["float data , int inds", "float mean =  NUM_  ", "for (  ;  i   <  inds.length   ;  i ++  ) ", " if (  Float.isNaN (  data   [  inds   [  i   ] ] )    ) ", " mean   +=  data   [  inds   [  i   ] ]", " mean   /=  inds.length  ", " return  mean  "]]
[["String name", "   "]]
[["TermNode t , Set producedBindings", " if (  t   instanceof VarNode ) ", " if (  t   instanceof ConstantNode ) ", "ConstantNode cNode", "Constant c", "IVariable var =  c.getVar (  )   ", " if (  var   !=  null   ) ", " producedBindings.add (  var   )   "], ["TermNode t , Set producedBindings", " if (  t   instanceof VarNode ) ", " producedBindings.add (  )   "]]
[["java.io.Reader reader", " yy_reader   =  reader  ", " yy_atBOL   =  BOOL_  ", " yy_atEOF   =  BOOL_  ", " yy_endRead   =  yy_startRead   =  NUM_  ", " yy_currentPos   =  yy_markedPos   =  yy_pushbackPos   =  NUM_  ", " yyline   =  yychar   =  yycolumn   =  NUM_  ", " yy_lexical_state   =  YYINITIAL  "]]
[["Integer value", " return  unsafeParam (  STR_   ,  value   )   "]]
[["int headIdx , List daughterTrees", " return  headIdx  "]]
[["RajawaliRenderer renderer , boolean createVBOs", " mGeometry   =  new Geometry3D (  )   ", " mRenderer   =  renderer  ", " init (  createVBOs   )   "]]
[["ServiceID id", " if (  id   ==  null   ) ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) "], ["ServiceID id", " if (  id   ==  null   ) ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) ", " rStat   =  rt  ", " discoveryTimes.remove (  rt   )   ", " return  rStat  "], ["ServiceID id", " if (  id   ==  null   ) ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) ", " rStat   =  rt  ", " discoveryTimes.remove (  rt   )   "], ["ServiceID id", " if (  id   ==  null   ) ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) ", " return  rStat  "], ["ServiceID id", " if (  id   ==  null   ) ", " new NullPointerException (  STR_   )   ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) "], ["ServiceID id", " if (  id   ==  null   ) ", " new NullPointerException (  STR_   )   ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) ", " rStat   =  rt  ", " discoveryTimes.remove (  rt   )   ", " return  rStat  "], ["ServiceID id", " if (  id   ==  null   ) ", " new NullPointerException (  STR_   )   ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) ", " rStat   =  rt  ", " discoveryTimes.remove (  rt   )   "], ["ServiceID id", " if (  id   ==  null   ) ", " new NullPointerException (  STR_   )   ", "ReggieStat rStat =  null  ", "for (  ;  it.hasNext (  )    ;  ) ", "ReggieStat rt", " if (  rt.serviceID.equals (  id   )    ) ", " return  rStat  "]]
[["String s , DateFormat dateFormat", " Validator.validate (  s   )   ", "JSONObject jsonObject =  new JSONObject (  s   )   ", "Map map =  toMap (  jsonObject   )   ", " return  mapToLogData (  map   ,  dateFormat   )   "]]
[["PipelineOp left , FilterNode filter , AST2BOpContext ctx", "InBOp bop", "IConstant set =  bop.getSet (  )   ", "LinkedHashSet ivs =  new LinkedHashSet (  )   ", "for ( IConstant iv :  set   )", " ivs.add (  iv.get (  )    )   "], ["PipelineOp left , FilterNode filter , AST2BOpContext ctx", "InBOp bop", "IConstant set =  bop.getSet (  )   ", "LinkedHashSet ivs =  new LinkedHashSet (  )   ", "for ( IConstant iv :  set   )", " ivs.add (  iv.get (  )    )   ", "IVariable var", " left   =  new DataSetJoin (  leftOrEmpty (  left   )    ,  NV.asMap (  new NV [  ]    )    )   ", " return  left  "]]
[["int done , int total", " if (  isFirst   ) ", " setCursorPos (  NUM_   ,  NUM_   )   ", " lineClear (  )   ", " setCursorPos (  NUM_   ,  NUM_   )   ", "char workchars", "String format =  STR_  ", "int percent = ++ done   *  NUM_   /  total  ", "int extrachars =  percent   /  NUM_   -   progress   ,  length (  )     . progress  . length (  )   ", "while (  extrachars --  >  NUM_   )", " progress.append (  STR_   )   ", " extracharsBK   =   progress   ,  length (  )     . progress  . length (  )    +  NUM_  ", " System.out.printf (  format   ,  percent   ,  progress   ,  workchars   [  done   %  workchars.length   ] )   ", " handler.flush (  )   ", " if (  done   ==  total   ) ", " System.out.flush (  )   ", " init (  )   "], ["int done , int total", " if (  isFirst   ) ", " setCursorPos (  NUM_   ,  NUM_   )   ", " lineClear (  )   ", " setCursorPos (  NUM_   ,  NUM_   )   ", "char workchars", "String format =  STR_  ", "int percent = ++ done   *  NUM_   /  total  ", "int extrachars =  percent   /  NUM_   -   progress   ,  length (  )     . progress  . length (  )   ", "while (  extrachars --  >  NUM_   )", " progress.append (  STR_   )   "], ["int done , int total", " if (  isFirst   ) ", "  clearConsole (  )     . clearConsole (  )   ", " System.out.println (  STR_   )   ", "char workchars", "String format =  STR_  ", "int percent = ++ done   *  NUM_   /  total  ", "int extrachars =  percent   /  NUM_   -   progress   ,  length (  )     . progress  . length (  )   ", "while (  extrachars --  >  NUM_   )", " progress.append (  STR_   )   ", " extracharsBK   =   progress   ,  length (  )     . progress  . length (  )    +  NUM_  ", " System.out.printf (  format   ,  percent   ,  progress   ,  workchars   [  done   %  workchars.length   ] )   ", " handler.flush (  )   ", " if (  done   ==  total   ) ", " System.out.flush (  )   ", " init (  )   "], ["int done , int total", " if (  isFirst   ) ", "  clearConsole (  )     . clearConsole (  )   ", " System.out.println (  STR_   )   ", "char workchars", "String format =  STR_  ", "int percent = ++ done   *  NUM_   /  total  ", "int extrachars =  percent   /  NUM_   -   progress   ,  length (  )     . progress  . length (  )   ", "while (  extrachars --  >  NUM_   )", " progress.append (  STR_   )   "]]
[["InputStream input", " return  readLines (  input   ,  Charset.defaultCharset (  )    )   "]]
[[" restoreState (  savedState   )   ", " savedState   =  null  ", "char term =  termAttribute.buffer (  )   ", "int length =  hyphenated.length (  )   ", " if (  length   >  termAttribute.length (  )    ) ", " term   =  termAttribute.resizeBuffer (  length   )   ", " hyphenated.getChars (  NUM_   ,  length   ,  term   ,  NUM_   )   ", " termAttribute.setLength (  length   )   ", " offsetAttribute.setOffset (  offsetAttribute.startOffset (  )    ,  lastEndOffset   )   ", " hyphenated.setLength (  NUM_   )   "], [" restoreState (  savedState   )   ", " savedState   =  null  ", "char term =  termAttribute.buffer (  )   ", "int length =  hyphenated.length (  )   ", " if (  length   >  termAttribute.length (  )    ) ", " hyphenated.getChars (  NUM_   ,  length   ,  term   ,  NUM_   )   ", " termAttribute.setLength (  length   )   ", " offsetAttribute.setOffset (  offsetAttribute.startOffset (  )    ,  lastEndOffset   )   ", " hyphenated.setLength (  NUM_   )   "]]
[["String s", "char buf =  new char [  s.length (  )    +  NUM_   ]   ", "int p =  NUM_  ", "for (  ;  ip   <  s.length (  )    ;  ip ++  ) ", "char c =  s.charAt (  ip   )   ", " if (  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", " buf   [  p ++  ] =  c  "], ["String s", "char buf =  new char [  s.length (  )    +  NUM_   ]   ", "int p =  NUM_  ", "for (  ;  ip   <  s.length (  )    ;  ip ++  ) ", "char c =  s.charAt (  ip   )   ", " if (  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", " buf   [  p ++  ] =  c  ", "while (  p   %  NUM_   !=  NUM_   )", " buf   [  p ++  ] =  STR_  "], ["String s", "char buf =  new char [  s.length (  )    +  NUM_   ]   ", "int p =  NUM_  ", "for (  ;  ip   <  s.length (  )    ;  ip ++  ) ", "char c =  s.charAt (  ip   )   ", " if (  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", " buf   [  p ++  ] =  c  ", "while (  p   %  NUM_   !=  NUM_   )", " buf   [  p ++  ] =  STR_  ", " return  decode (  buf   ,  NUM_   ,  p   )   "], ["String s", "char buf =  new char [  s.length (  )    +  NUM_   ]   ", "int p =  NUM_  ", "for (  ;  ip   <  s.length (  )    ;  ip ++  ) ", "char c =  s.charAt (  ip   )   ", " if (  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   ) "], ["String s", "char buf =  new char [  s.length (  )    +  NUM_   ]   ", "int p =  NUM_  ", "for (  ;  ip   <  s.length (  )    ;  ip ++  ) ", "char c =  s.charAt (  ip   )   ", " if (  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", "while (  p   %  NUM_   !=  NUM_   )", " buf   [  p ++  ] =  STR_  "], ["String s", "char buf =  new char [  s.length (  )    +  NUM_   ]   ", "int p =  NUM_  ", "for (  ;  ip   <  s.length (  )    ;  ip ++  ) ", "char c =  s.charAt (  ip   )   ", " if (  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   &&  c   !=  STR_   ) ", "while (  p   %  NUM_   !=  NUM_   )", " buf   [  p ++  ] =  STR_  ", " return  decode (  buf   ,  NUM_   ,  p   )   "]]
[["byte subjectKeyId", "   "]]
[["String inputString", " return  Pattern.matches (  PATTERN_LETTER   ,  inputString   )   "]]
[["ListRequest request", " request.setProjectPath (  getAbsoluteProjectPath (  request.getProjectPath (  )    )    )   ", " return  subversionApi.list (  request   )   "]]
[[" table   =  new Entry [  INITIAL_CAPACITY   ]   "]]
[["AddRequest request", "File projectPath =  new File (  request.getProjectPath (  )    )   ", "List args =  defaultArgs (  )   ", " addFlag (  args   ,  STR_   ,  request.isAddIgnored (  )    )   ", " addFlag (  args   ,  STR_   ,  request.isAddParents (  )    )   ", " if (  request.isAutoProps (  )    ) ", " args.add (  STR_   )   ", " if (  request.isNotAutoProps (  )    ) ", " addOption (  args   ,  STR_   ,  request.getDepth (  )    )   ", " args.add (  STR_   )   ", "CommandLineResult result =  runCommand (  null   ,  args   ,  projectPath   ,  request.getPaths (  )    )   ", " return  DtoFactory.getInstance (  )   . createDto (  CLIOutputResponse    )   . withCommand (  result.getCommandLine (  )   . toString (  )    )   . withOutput (  result.getStdout (  )    )   . withErrOutput (  result.getStderr (  )    )   "], ["AddRequest request", "File projectPath =  new File (  request.getProjectPath (  )    )   ", "List args =  defaultArgs (  )   ", " addFlag (  args   ,  STR_   ,  request.isAddIgnored (  )    )   ", " addFlag (  args   ,  STR_   ,  request.isAddParents (  )    )   ", " if (  request.isAutoProps (  )    ) ", " args.add (  STR_   )   ", " if (  request.isNotAutoProps (  )    ) ", " args.add (  STR_   )   ", " addOption (  args   ,  STR_   ,  request.getDepth (  )    )   ", " args.add (  STR_   )   ", "CommandLineResult result =  runCommand (  null   ,  args   ,  projectPath   ,  request.getPaths (  )    )   ", " return  DtoFactory.getInstance (  )   . createDto (  CLIOutputResponse    )   . withCommand (  result.getCommandLine (  )   . toString (  )    )   . withOutput (  result.getStdout (  )    )   . withErrOutput (  result.getStderr (  )    )   "], ["AddRequest request", "File projectPath =  new File (  request.getProjectPath (  )    )   ", "List args =  defaultArgs (  )   ", " addFlag (  args   ,  STR_   ,  request.isAddIgnored (  )    )   ", " addFlag (  args   ,  STR_   ,  request.isAddParents (  )    )   ", " if (  request.isAutoProps (  )    ) ", " if (  request.isNotAutoProps (  )    ) ", " addOption (  args   ,  STR_   ,  request.getDepth (  )    )   ", " args.add (  STR_   )   ", "CommandLineResult result =  runCommand (  null   ,  args   ,  projectPath   ,  request.getPaths (  )    )   ", " return  DtoFactory.getInstance (  )   . createDto (  CLIOutputResponse    )   . withCommand (  result.getCommandLine (  )   . toString (  )    )   . withOutput (  result.getStdout (  )    )   . withErrOutput (  result.getStderr (  )    )   "], ["AddRequest request", "File projectPath =  new File (  request.getProjectPath (  )    )   ", "List args =  defaultArgs (  )   ", " addFlag (  args   ,  STR_   ,  request.isAddIgnored (  )    )   ", " addFlag (  args   ,  STR_   ,  request.isAddParents (  )    )   ", " if (  request.isAutoProps (  )    ) ", " if (  request.isNotAutoProps (  )    ) ", " args.add (  STR_   )   ", " addOption (  args   ,  STR_   ,  request.getDepth (  )    )   ", " args.add (  STR_   )   ", "CommandLineResult result =  runCommand (  null   ,  args   ,  projectPath   ,  request.getPaths (  )    )   ", " return  DtoFactory.getInstance (  )   . createDto (  CLIOutputResponse    )   . withCommand (  result.getCommandLine (  )   . toString (  )    )   . withOutput (  result.getStdout (  )    )   . withErrOutput (  result.getStderr (  )    )   "]]
[["String content , ValidationContext context", " if ( ! context.isEntityUnparsed (  content   )    ) ", " new InvalidDatatypeValueException (  STR_   ,  new Object [  ]    )   "]]
[["Parcel dest , int flags", " dest.writeInt (  channel   )   ", " dest.writeInt (  frequency   )   ", " dest.writeInt (  ibssAllowed  ? NUM_  : NUM_   )   "]]
[["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", "int locatorId =  Env.getContextAsInt (  Env.getCtx (  )    ,  getProcessInfo (  )   . getWindowNo (  )    ,  STR_   )   ", " if (  locatorId   >  NUM_   ) ", " if (  locator   ==  null   ) ", " new AdempiereException (  STR_   )   "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", "int locatorId =  Env.getContextAsInt (  Env.getCtx (  )    ,  getProcessInfo (  )   . getWindowNo (  )    ,  STR_   )   ", " if (  locatorId   >  NUM_   ) ", " locator   =  new MLocator (  getCtx (  )    ,  locatorId   ,  get_TrxName (  )    )   ", " if (  locator   ==  null   ) ", " new AdempiereException (  STR_   )   "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", " movementDate   =  para.getParameterAsTimestamp (  )   ", " if (  movementDate   ==  null   ) "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", " movementDate   =  para.getParameterAsTimestamp (  )   ", " if (  movementDate   ==  null   ) ", " new AdempiereException (  STR_   )   "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", " movementDate   =  para.getParameterAsTimestamp (  )   ", " if (  movementDate   ==  null   ) ", " new AdempiereException (  STR_   )   ", "int locatorId =  Env.getContextAsInt (  Env.getCtx (  )    ,  getProcessInfo (  )   . getWindowNo (  )    ,  STR_   )   ", " if (  locatorId   >  NUM_   ) ", " if (  locator   ==  null   ) ", " new AdempiereException (  STR_   )   "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", " movementDate   =  para.getParameterAsTimestamp (  )   ", " if (  movementDate   ==  null   ) ", " new AdempiereException (  STR_   )   ", "int locatorId =  Env.getContextAsInt (  Env.getCtx (  )    ,  getProcessInfo (  )   . getWindowNo (  )    ,  STR_   )   ", " if (  locatorId   >  NUM_   ) ", " locator   =  new MLocator (  getCtx (  )    ,  locatorId   ,  get_TrxName (  )    )   ", " if (  locator   ==  null   ) ", " new AdempiereException (  STR_   )   "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", " movementDate   =  para.getParameterAsTimestamp (  )   ", " if (  movementDate   ==  null   ) ", "int locatorId =  Env.getContextAsInt (  Env.getCtx (  )    ,  getProcessInfo (  )   . getWindowNo (  )    ,  STR_   )   ", " if (  locatorId   >  NUM_   ) ", " if (  locator   ==  null   ) ", " new AdempiereException (  STR_   )   "], ["for ( ProcessInfoParameter para :  getParameter (  )    )", "String name =  para.getParameterName (  )   ", " if (  para.getParameter (  )    ==  null   ) ", " if (  name.equals (  I_M_Movement.COLUMNNAME_MovementDate   )    ) ", " movementDate   =  para.getParameterAsTimestamp (  )   ", " if (  movementDate   ==  null   ) ", "int locatorId =  Env.getContextAsInt (  Env.getCtx (  )    ,  getProcessInfo (  )   . getWindowNo (  )    ,  STR_   )   ", " if (  locatorId   >  NUM_   ) ", " locator   =  new MLocator (  getCtx (  )    ,  locatorId   ,  get_TrxName (  )    )   ", " if (  locator   ==  null   ) ", " new AdempiereException (  STR_   )   "]]
[["MetadataContext context", " return  schema.bind (  parent   ,  attKey   ,  context   )   "]]
[[" return  amIActive  "]]
[[" if (  wrapped   !=  null   ) ", " wrapped.events.publish (  new Stateful.LoadEvent (  )    )   ", " prevPosX   =  posX  ", " prevPosY   =  posY  ", " prevPosZ   =  posZ  ", " prevRotationYaw   =  rotationYaw  ", " prevRotationPitch   =  rotationPitch  ", " setPosition (  posX   ,  posY   ,  posZ   )   "]]
[["int hiddenLayerSizes", " setHiddenSizes (  hiddenLayerSizes   )   "]]
[["int m", " x   *=  m  ", " y   *=  m  ", " z   *=  m  ", " return    "]]
[["int key", "int i =  indexOfKey (  key   )   ", " if (  i   <  NUM_   ) ", " return  BOOL_  "], ["int key", "int i =  indexOfKey (  key   )   ", " if (  i   <  NUM_   ) ", "  state   , [  i   ]  . state   [  i   ] =  REMOVED  ", "  distinct   -- . distinct  ", " if (   distinct    . distinct   <   lowWaterMark    . lowWaterMark   ) ", "int newCapacity =  chooseShrinkCapacity (   distinct    . distinct   ,   minLoadFactor    . minLoadFactor   ,   maxLoadFactor    . maxLoadFactor   )   ", " rehash (  newCapacity   )   ", " return  BOOL_  "], ["int key", "int i =  indexOfKey (  key   )   ", " if (  i   <  NUM_   ) ", "  state   , [  i   ]  . state   [  i   ] =  REMOVED  ", "  distinct   -- . distinct  ", " if (   distinct    . distinct   <   lowWaterMark    . lowWaterMark   ) ", " return  BOOL_  "]]
[["List vars", " new UnsupportedOperationException (  )   "]]
[["PredictiveInfoCalculator piCalc , int k , int timeSteps", " piCalc.initialise (  k   )   ", "RandomGenerator rg =  new RandomGenerator (  )   ", "double data =  rg.generateNormalData (  timeSteps   ,  NUM_   ,  NUM_   )   ", " piCalc.setObservations (  data   )   ", "double pi =  piCalc.computeAverageLocalOfObservations (  )   ", " lastResult   =  pi  ", "double piLocal =  piCalc.computeLocalOfPreviousObservations (  )   ", " System.out.printf (  STR_   ,  pi   )   ", " assertEquals (  pi   ,  MatrixUtils.mean (  piLocal   )    ,  NUM_   )   "]]
[["String str", " if (  statusLabel   ==  null   ) ", " System.out.println (  str   )   ", " return "], ["String str", " if (  statusLabel   ==  null   ) ", " ArgumentChecking.notNull (  str   ,  STR_   )   ", " statusLabel.showMessage (  str   )   "]]
[]
[["Integer value", " return  unsafeParam (  STR_   ,  value   )   "]]
[["int base , int history", "   "]]
[["T elem , long timeStamp", " builder.emit (  elem   ,  timeStamp   )   ", " return    "]]
[["Properties props", "Properties result", "Enumeration keys", "String key", " result   =  new Properties (  )   ", " keys   = ", "while (  keys.hasMoreElements (  )    )", " key   =  keys.nextElement (  )   ", " result.setProperty (  key   ,  props.getProperty (  key   )    )   ", " return  result  "], ["Properties props", "Properties result", "Enumeration keys", "String key", " result   =  new Properties (  )   ", " keys   = ", "while (  keys.hasMoreElements (  )    )", " key   =  keys.nextElement (  )   ", " result.setProperty (  key   ,  props.getProperty (  key   )    )   "]]
[["Object that", " return  that   instanceof CharSet &&  Arrays.equals (  chars   ,  )   "]]
[["int start , int end", "TimePeriodValues copy", " copy.data   =  new ArrayList (  )   ", " if (   data   ,  size (  )     . data  . size (  )    >  NUM_   ) ", " return  copy  "], ["int start , int end", "TimePeriodValues copy", " copy.data   =  new ArrayList (  )   ", " if (   data   ,  size (  )     . data  . size (  )    >  NUM_   ) ", "for (  ;  index   <=  end   ;  index ++  ) ", "TimePeriodValue item", "TimePeriodValue clone", " copy.add (  clone   )   ", " return  copy  "], ["int start , int end", "TimePeriodValues copy", " copy.data   =  new ArrayList (  )   ", " if (   data   ,  size (  )     . data  . size (  )    >  NUM_   ) ", "for (  ;  index   <=  end   ;  index ++  ) ", "TimePeriodValue item", "TimePeriodValue clone", " copy.add (  clone   )   "]]
[["File archive , File outputDir", "ZipFile zipfile =  new ZipFile (  archive   ,  encoding   )   ", "for (  ;  e.hasMoreElements (  )    ;  ) ", "ZipArchiveEntry entry", " unzipEntry (  zipfile   ,  entry   ,  outputDir   )   "], ["File archive , File outputDir", "ZipFile zipfile =  new ZipFile (  archive   ,  encoding   )   ", "for (  ;  e.hasMoreElements (  )    ;  ) ", "ZipArchiveEntry entry", " unzipEntry (  zipfile   ,  entry   ,  outputDir   )   ", " zipfile.close (  )   "]]
[["int n1 , int n2 , int sum", "int b =  n1.length   -  NUM_  ", "int carry =  NUM_  ", "while (  b   >=  NUM_   )", "int s =  n1   [  b   ] +  n2   [  b   ] +  carry  ", " sum   [  b   +  NUM_   ] =  s   %  NUM_  ", " if (  s   >  NUM_   ) ", " carry   =  NUM_  ", " b -- ", " sum   [  NUM_   ] =  carry  "], ["int n1 , int n2 , int sum", "int b =  n1.length   -  NUM_  ", "int carry =  NUM_  ", "while (  b   >=  NUM_   )", "int s =  n1   [  b   ] +  n2   [  b   ] +  carry  ", " sum   [  b   +  NUM_   ] =  s   %  NUM_  ", " if (  s   >  NUM_   ) ", " carry   =  NUM_  ", " b -- "], ["int n1 , int n2 , int sum", "int b =  n1.length   -  NUM_  ", "int carry =  NUM_  ", "while (  b   >=  NUM_   )", "int s =  n1   [  b   ] +  n2   [  b   ] +  carry  ", " sum   [  b   +  NUM_   ] =  s   %  NUM_  ", " if (  s   >  NUM_   ) ", " carry   =  NUM_  ", " b -- ", " sum   [  NUM_   ] =  carry  "], ["int n1 , int n2 , int sum", "int b =  n1.length   -  NUM_  ", "int carry =  NUM_  ", "while (  b   >=  NUM_   )", "int s =  n1   [  b   ] +  n2   [  b   ] +  carry  ", " sum   [  b   +  NUM_   ] =  s   %  NUM_  ", " if (  s   >  NUM_   ) ", " carry   =  NUM_  ", " b -- "]]
[["Context context", "   "]]
[[" return   io   ,  getPointerField (     ,  NUM_   )     . io  . getPointerField (     ,  NUM_   )   "]]
[["WifiConfiguration network , int reason", "Intent intent =  new Intent (  WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION   )   ", " intent.addFlags (  Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT   )   ", " intent.putExtra (  WifiManager.EXTRA_MULTIPLE_NETWORKS_CHANGED   ,  BOOL_   )   ", " intent.putExtra (  WifiManager.EXTRA_WIFI_CONFIGURATION   ,  network   )   ", " intent.putExtra (  WifiManager.EXTRA_CHANGE_REASON   ,  reason   )   ", " mContext.sendBroadcastAsUser (  intent   ,  UserHandle.ALL   )   "]]
[["CharSequence host , int port , int userId", "int len =  ClientConnection.buildGUID (  guidWorkspace   ,  host   ,  port   ,  userId   )   ", " return  TrieParserReader.query (  hostTrieReader   ,  hostTrie   ,  guidWorkspace   ,  NUM_   ,  len   ,  Integer.MAX_VALUE   )   "]]
[["int access , String className , String methName , String methDesc", " if (  ignoreCallback   ) ", " return "], ["int access , String className , String methName , String methDesc", " if (  ignoreCallback   ) ", " ignoreCallback   =  BOOL_  ", " vm.countCallback (  )   ", "for ( IVM listener :  vm.listeners   )", " listener.HANDLER_BEGIN (  access   ,  className   ,  methName   ,  methDesc   )   ", " ignoreCallback   =  BOOL_  "], ["int access , String className , String methName , String methDesc", " if (  ignoreCallback   ) ", " ignoreCallback   =  BOOL_  ", " vm.countCallback (  )   ", "for ( IVM listener :  vm.listeners   )", " listener.HANDLER_BEGIN (  access   ,  className   ,  methName   ,  methDesc   )   "]]
[["Ice.ObjectPrx __obj , String __facet", " return  uncheckedCastImpl (  __obj   ,  __facet   ,  MyServicePrx    ,  MyServicePrxHelper    )   "]]
[["String url , Callback callback", " return  put (  url   ,  null   ,  callback   )   "]]
[["int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ) ", " previousProgress   =  progress  "], ["int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ) ", " myHost.updateProgress (  progress   )   ", " previousProgress   =  progress  "]]
[["Throwable throwable , Response response", " if (  LOGGER.isWarnEnabled (  )    ) ", " LOGGER.warn (  STR_   +  throwable   ,  throwable   )   ", "OAuth2RestletException exception =  toOAuth2RestletException (  throwable   )   ", " response.setStatus (  exception.getStatus (  )    )   ", " response.setEntity (  jacksonRepresentationFactory.create (  exception.asMap (  )    )    )   "], ["Throwable throwable , Response response", " if (  LOGGER.isWarnEnabled (  )    ) ", "OAuth2RestletException exception =  toOAuth2RestletException (  throwable   )   ", " response.setStatus (  exception.getStatus (  )    )   ", " response.setEntity (  jacksonRepresentationFactory.create (  exception.asMap (  )    )    )   "]]
[["String query , int limit , int queryResultSetLimit", "Matcher matcher =  SELECT_EXPR_PATTERN.matcher (  query   )   ", " if (  matcher.matches (  )    ) ", " return  query  "], ["String query , int limit , int queryResultSetLimit", "Matcher matcher =  SELECT_EXPR_PATTERN.matcher (  query   )   ", " if (  matcher.matches (  )    ) ", "Matcher limit_matcher =  SELECT_WITH_LIMIT_EXPR_PATTERN.matcher (  query   )   ", "boolean queryAlreadyHasLimitClause =  limit_matcher.matches (  )   ", " if ( ! queryAlreadyHasLimitClause   ) ", " return  query  "], ["String query , int limit , int queryResultSetLimit", "Matcher matcher =  SELECT_EXPR_PATTERN.matcher (  query   )   ", " if (  matcher.matches (  )    ) ", "Matcher limit_matcher =  SELECT_WITH_LIMIT_EXPR_PATTERN.matcher (  query   )   ", "boolean queryAlreadyHasLimitClause =  limit_matcher.matches (  )   ", " if ( ! queryAlreadyHasLimitClause   ) ", " if (  limit   ==  NUM_   ) ", " limit   =  queryResultSetLimit  ", "String result =  query  ", " result   +=  STR_   +  limit  ", " return  result  "], ["String query , int limit , int queryResultSetLimit", "Matcher matcher =  SELECT_EXPR_PATTERN.matcher (  query   )   ", " if (  matcher.matches (  )    ) ", "Matcher limit_matcher =  SELECT_WITH_LIMIT_EXPR_PATTERN.matcher (  query   )   ", "boolean queryAlreadyHasLimitClause =  limit_matcher.matches (  )   ", " if ( ! queryAlreadyHasLimitClause   ) ", " if (  limit   ==  NUM_   ) ", "String result =  query  ", " result   +=  STR_   +  limit  ", " return  result  "]]
[["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", "Integer n =  Ints.tryParse (  id   )   ", " if (  n   !=  null   ) ", " if ( ! id.contains (  STR_   )    ) ", " return  asChangeControls (  query.byKeyPrefix (  id   )    ,  user   )   "], ["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", "Integer n =  Ints.tryParse (  id   )   ", " if (  n   !=  null   ) ", " if ( ! id.contains (  STR_   )    ) ", "Optional triplet =  ChangeTriplet.parse (  id   )   ", " if (  triplet.isPresent (  )    ) ", " return  Collections.emptyList (  )   "], ["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", "Integer n =  Ints.tryParse (  id   )   ", " if (  n   !=  null   ) ", " if ( ! id.contains (  STR_   )    ) ", "Optional triplet =  ChangeTriplet.parse (  id   )   ", " if (  triplet.isPresent (  )    ) ", " return  asChangeControls (  query.byBranchKey (  triplet.get (  )   . branch (  )    ,  triplet.get (  )   . id (  )    )    ,  user   )   "], ["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", "Integer n =  Ints.tryParse (  id   )   ", " if (  n   !=  null   ) ", " return  asChangeControls (  query.byLegacyChangeId (  new Change.Id (  n   )    )    ,  user   )   "], ["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", " if ( ! id.contains (  STR_   )    ) ", " return  asChangeControls (  query.byKeyPrefix (  id   )    ,  user   )   "], ["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", " if ( ! id.contains (  STR_   )    ) ", "Optional triplet =  ChangeTriplet.parse (  id   )   ", " if (  triplet.isPresent (  )    ) ", " return  Collections.emptyList (  )   "], ["String id , CurrentUser user", "InternalChangeQuery query =  queryProvider.get (  )   . noFields (  )   ", " if ( ! id.isEmpty (  )    &&  id.charAt (  NUM_   )    !=  STR_   ) ", " if ( ! id.contains (  STR_   )    ) ", "Optional triplet =  ChangeTriplet.parse (  id   )   ", " if (  triplet.isPresent (  )    ) ", " return  asChangeControls (  query.byBranchKey (  triplet.get (  )   . branch (  )    ,  triplet.get (  )   . id (  )    )    ,  user   )   "]]
[["UUID uuid", " checkNotNull (  uuid   )   ", " if ( ! loaded   ) ", " if (  map.remove (  uuid   )    !=  null   ) ", " return  BOOL_  "], ["UUID uuid", " checkNotNull (  uuid   )   ", " if ( ! loaded   ) ", " if (  map.remove (  uuid   )    !=  null   ) ", " return  BOOL_  "], ["UUID uuid", " checkNotNull (  uuid   )   ", " if ( ! loaded   ) ", " load (  )   ", " if (  map.remove (  uuid   )    !=  null   ) ", " return  BOOL_  "], ["UUID uuid", " checkNotNull (  uuid   )   ", " if ( ! loaded   ) ", " load (  )   ", " if (  map.remove (  uuid   )    !=  null   ) ", " return  BOOL_  "]]
[["InputStream inputStream , Function vertexAttachMethod", " Io.Exceptions.readerFormatIsForFullGraphSerializationOnly (   getClass (  )     . getClass (  )    )   "]]
[["byte repositoryDefinition", " return  source (  repositoryDefinition   ,  NUM_   ,  repositoryDefinition.length   )   "]]
[["PackageEvent evt", "ResultsFrame frame =  ResultsFrame.getInstance (  evt.getPackage (  )   . getProject (  )    ,  BOOL_   )   ", " if (  frame   !=  null   ) ", " frame.setVisible (  BOOL_   )   "]]
[["Calendar calendar =  getCalendarInstance (  )   ", " calendar.setTimeInMillis (  currentTimeMillis (  )    )   ", " return  toUnixTime (  calendar   )   "]]
[["byte crypt", "int buffer =  new int [  crypt.length   /  NUM_   ]   ", " pack (  crypt   ,  buffer   ,  NUM_   )   ", " unbrew (  buffer   )   ", " return  unpack (  buffer   ,  NUM_   ,  buffer   [  NUM_   ] )   "]]
[["byte channel", " channelConfig   [  channel   ]. setInitializing (  BOOL_   )   ", " channelConfig   [  channel   ]. setDeinitializing (  BOOL_   )   ", " channelConfig   [  channel   ]. setChannelState (  ChannelStates.CLOSED   )   ", " antInterface.ANTCloseChannel (  channel   )   "]]
[["TIntProcedure procedure", "int set =  _set  ", "Object values =  _values  ", "for (  ;  i --  >  NUM_   ;  ) ", " if (  isFull (  values   ,  i   )    && ! procedure.execute (  set   [  i   ] )    ) ", " return  BOOL_  "], ["TIntProcedure procedure", "int set =  _set  ", "Object values =  _values  ", "for (  ;  i --  >  NUM_   ;  ) ", " if (  isFull (  values   ,  i   )    && ! procedure.execute (  set   [  i   ] )    ) "], ["TIntProcedure procedure", "int set =  _set  ", "Object values =  _values  ", "for (  ;  i --  >  NUM_   ;  ) ", " if (  isFull (  values   ,  i   )    && ! procedure.execute (  set   [  i   ] )    ) ", " return  BOOL_  "]]
[["Node x , Key key", " if (  x   ==  null   ) ", "int cmp =  key.compareTo (  x.key   )   ", " if (  cmp   ==  NUM_   ) ", " if (  cmp   <  NUM_   ) ", " return  floor (  x.left   ,  key   )   "], ["Node x , Key key", " if (  x   ==  null   ) ", "int cmp =  key.compareTo (  x.key   )   ", " if (  cmp   ==  NUM_   ) ", " if (  cmp   <  NUM_   ) ", "Node y =  floor (  x.right   ,  key   )   ", " if (  y   !=  null   ) ", " return  x  "], ["Node x , Key key", " if (  x   ==  null   ) ", "int cmp =  key.compareTo (  x.key   )   ", " if (  cmp   ==  NUM_   ) ", " if (  cmp   <  NUM_   ) ", "Node y =  floor (  x.right   ,  key   )   ", " if (  y   !=  null   ) ", " return  y  "], ["Node x , Key key", " if (  x   ==  null   ) ", "int cmp =  key.compareTo (  x.key   )   ", " if (  cmp   ==  NUM_   ) ", " return  x  "], ["Node x , Key key", " if (  x   ==  null   ) ", " return  null  "]]
[["SuggestionAnswer.ImageLine line , Paint.FontMetrics metrics , float density", "SpannableStringBuilder builder =  new SpannableStringBuilder (  )   ", "int maxTextHeightSp =  getMaxTextHeightSp (  line   )   ", "List textFields =  line.getTextFields (  )   ", "for (  ;  i   <  textFields.size (  )    ;  i ++  ) ", " appendAndStyleText (  builder   ,  textFields.get (  i   )    ,  maxTextHeightSp   ,  metrics   ,  density   )   "], ["SuggestionAnswer.ImageLine line , Paint.FontMetrics metrics , float density", "SpannableStringBuilder builder =  new SpannableStringBuilder (  )   ", "int maxTextHeightSp =  getMaxTextHeightSp (  line   )   ", "List textFields =  line.getTextFields (  )   ", "for (  ;  i   <  textFields.size (  )    ;  i ++  ) ", " appendAndStyleText (  builder   ,  textFields.get (  i   )    ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " if (  line.hasAdditionalText (  )    ) ", " if (  line.hasStatusText (  )    ) ", " return  builder  "], ["SuggestionAnswer.ImageLine line , Paint.FontMetrics metrics , float density", "SpannableStringBuilder builder =  new SpannableStringBuilder (  )   ", "int maxTextHeightSp =  getMaxTextHeightSp (  line   )   ", "List textFields =  line.getTextFields (  )   ", "for (  ;  i   <  textFields.size (  )    ;  i ++  ) ", " appendAndStyleText (  builder   ,  textFields.get (  i   )    ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " if (  line.hasAdditionalText (  )    ) ", " if (  line.hasStatusText (  )    ) ", " builder.append (  STR_   )   ", "SuggestionAnswer.TextField statusText =  line.getStatusText (  )   ", " appendAndStyleText (  builder   ,  statusText   ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " return  builder  "], ["SuggestionAnswer.ImageLine line , Paint.FontMetrics metrics , float density", "SpannableStringBuilder builder =  new SpannableStringBuilder (  )   ", "int maxTextHeightSp =  getMaxTextHeightSp (  line   )   ", "List textFields =  line.getTextFields (  )   ", "for (  ;  i   <  textFields.size (  )    ;  i ++  ) ", " appendAndStyleText (  builder   ,  textFields.get (  i   )    ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " if (  line.hasAdditionalText (  )    ) ", " builder.append (  STR_   )   ", "SuggestionAnswer.TextField additionalText =  line.getAdditionalText (  )   ", " appendAndStyleText (  builder   ,  additionalText   ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " if (  line.hasStatusText (  )    ) ", " return  builder  "], ["SuggestionAnswer.ImageLine line , Paint.FontMetrics metrics , float density", "SpannableStringBuilder builder =  new SpannableStringBuilder (  )   ", "int maxTextHeightSp =  getMaxTextHeightSp (  line   )   ", "List textFields =  line.getTextFields (  )   ", "for (  ;  i   <  textFields.size (  )    ;  i ++  ) ", " appendAndStyleText (  builder   ,  textFields.get (  i   )    ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " if (  line.hasAdditionalText (  )    ) ", " builder.append (  STR_   )   ", "SuggestionAnswer.TextField additionalText =  line.getAdditionalText (  )   ", " appendAndStyleText (  builder   ,  additionalText   ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " if (  line.hasStatusText (  )    ) ", " builder.append (  STR_   )   ", "SuggestionAnswer.TextField statusText =  line.getStatusText (  )   ", " appendAndStyleText (  builder   ,  statusText   ,  maxTextHeightSp   ,  metrics   ,  density   )   ", " return  builder  "]]
[["ObjectReference objref , int expected , int newValue , Word offset , Word unused , int mode", " if (  org.jikesrvm.VM.BuildForIA32   ) ", " return  Magic.attemptInt (  objref.toObject (  )    ,  offset.toOffset (  )    ,  expected   ,  newValue   )   "], ["ObjectReference objref , int expected , int newValue , Word offset , Word unused , int mode", " if (  org.jikesrvm.VM.BuildForIA32   ) ", "int oldValue", " oldValue   =  Magic.prepareInt (  objref   ,  offset.toOffset (  )    )   ", " if (  oldValue   !=  expected   ) ", " while ( ! Magic.attemptInt (  objref   ,  offset.toOffset (  )    ,  oldValue   ,  newValue   )    ) ", " return  BOOL_  "], ["ObjectReference objref , int expected , int newValue , Word offset , Word unused , int mode", " if (  org.jikesrvm.VM.BuildForIA32   ) ", "int oldValue", " oldValue   =  Magic.prepareInt (  objref   ,  offset.toOffset (  )    )   ", " if (  oldValue   !=  expected   ) ", " while ( ! Magic.attemptInt (  objref   ,  offset.toOffset (  )    ,  oldValue   ,  newValue   )    ) "], ["ObjectReference objref , int expected , int newValue , Word offset , Word unused , int mode", " if (  org.jikesrvm.VM.BuildForIA32   ) ", "int oldValue", " oldValue   =  Magic.prepareInt (  objref   ,  offset.toOffset (  )    )   ", " if (  oldValue   !=  expected   ) ", " return  BOOL_  "]]
[]
[["NutchDocument doc , String url", "for ( Subcollection coll :  CollectionManager.getCollectionManager (  getConf (  )    )   . getSubCollections (  url   )    )", " if (  coll.getKey (  )    ==  null   ) ", " doc.add (  coll.getKey (  )    ,  coll.getName (  )    )   "], ["NutchDocument doc , String url", "for ( Subcollection coll :  CollectionManager.getCollectionManager (  getConf (  )    )   . getSubCollections (  url   )    )", " if (  coll.getKey (  )    ==  null   ) ", " doc.add (  fieldName   ,  coll.getName (  )    )   "]]
[["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " new WebApplicationException (  Response.Status.NOT_FOUND.getReasonPhrase (  )    ,  Response.Status.NOT_FOUND   )   ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " new WebApplicationException (  Response.Status.NOT_FOUND.getReasonPhrase (  )    ,  Response.Status.NOT_FOUND   )   ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " new WebApplicationException (  Response.Status.NOT_FOUND.getReasonPhrase (  )    ,  Response.Status.NOT_FOUND   )   ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "], ["HttpServletRequest req , BigInteger userId , String email", " if (  userId   ==  null   ||  userId.compareTo (  BigInteger.ZERO   )    <  NUM_   ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", " if (  email   ==  null   ||  email.isEmpty (  )    ) ", " new WebApplicationException (  STR_   ,  Status.BAD_REQUEST   )   ", "PrincipalUser remoteUser =  getRemoteUser (  req   )   ", "PrincipalUser user =  _uService.findUserByPrimaryKey (  userId   )   ", " validateResourceAuthorization (  req   ,  user   ,  remoteUser   )   ", " if (  user   ==  null   ) ", " new WebApplicationException (  Response.Status.NOT_FOUND.getReasonPhrase (  )    ,  Response.Status.NOT_FOUND   )   ", " user.setEmail (  email   )   ", " user   =  _uService.updateUser (  user   )   ", " return  PrincipalUserDto.transformToDto (  user   )   "]]
[["byte in", "ByteArrayScanner scanner =  new ByteArrayScanner (  in   )   ", " if (  scanner.nextByte (  )    !=  MSG_TYPE_RESET_GENERATION_ID   ) ", " generationId   =  scanner.nextLongUTF8 (  )   "], ["byte in", "ByteArrayScanner scanner =  new ByteArrayScanner (  in   )   ", " if (  scanner.nextByte (  )    !=  MSG_TYPE_RESET_GENERATION_ID   ) ", " new DataFormatException (  STR_   )   ", " generationId   =  scanner.nextLongUTF8 (  )   "]]
[["Throwable throwable , String msg , Object arg0 , Object arg1 , Object arg2", " innerLog (  Level.WARNING   ,  throwable   ,  msg   ,  arg0   ,  arg1   ,  arg2   ,  null   )   "]]
[[" return  zzLexicalState  "]]
[["Object object", " return  ClassUtils.isCglibProxyClass (  object.getClass (  )    )   "]]
[["long timeout", " stopGrid (  NUM_   )   ", " info (  STR_   )   ", " U.sleep (  timeout   )   "]]
[["L list , Predicate predicate", "for (  ;  iter.hasNext (  )    ;  ) ", "E obj =  iter.next (  )   ", " if (  predicate.test (  obj   )    ) "], ["L list , Predicate predicate", "for (  ;  iter.hasNext (  )    ;  ) ", "E obj =  iter.next (  )   ", " if (  predicate.test (  obj   )    ) ", " iter.remove (  )   "], ["L list , Predicate predicate", "for (  ;  iter.hasNext (  )    ;  ) ", "E obj =  iter.next (  )   ", " if (  predicate.test (  obj   )    ) ", " iter.remove (  )   ", " return  list  "], ["L list , Predicate predicate", "for (  ;  iter.hasNext (  )    ;  ) ", "E obj =  iter.next (  )   ", " if (  predicate.test (  obj   )    ) ", " return  list  "]]
[["String topic , AWSIotQos qos , String payload , long timeout", "   ", "  timeout    . timeout   =  timeout  ", "  request    . request   =  null  ", "  isAsync    . isAsync   =  BOOL_  "]]
[[" if (   joinedOnce    . joinedOnce   ) ", " new IllegalStateException (  STR_   )   ", "  joinedOnce    . joinedOnce   =  BOOL_  ", "  sendJoin (  )     . sendJoin (  )   ", " return   joinPush    . joinPush  "], [" if (   joinedOnce    . joinedOnce   ) ", "  joinedOnce    . joinedOnce   =  BOOL_  ", "  sendJoin (  )     . sendJoin (  )   ", " return   joinPush    . joinPush  "]]
[["Field field", " return  STR_  "]]
[[" if ( ! proceedForValidation   ) ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   ", " assertEquals (  STR_   ,  TOTAL_PUTS   ,  putsRecievedByClient   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   +  putsRecievedByClient   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   "], [" if ( ! proceedForValidation   ) ", " if ( ! proceedForValidation   ) ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   ", " Bug36853EventsExpiryDUnitTest  wait (  NUM_   )     . wait (  NUM_   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   ", " assertEquals (  STR_   ,  TOTAL_PUTS   ,  putsRecievedByClient   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   +  putsRecievedByClient   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   "], [" if ( ! proceedForValidation   ) ", " if ( ! proceedForValidation   ) ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   ", " assertEquals (  STR_   ,  TOTAL_PUTS   ,  putsRecievedByClient   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   +  putsRecievedByClient   )   ", " LogWriterUtils.getLogWriter (  )   . info (  STR_   )   "]]
[["  loadFactor    . loadFactor   =  DEFAULT_LOAD_FACTOR  ", " threshold   =  DEFAULT_INITIAL_CAPACITY  ", " table   =  new LongEntry [  DEFAULT_INITIAL_CAPACITY   ]   "]]
[["String template", "   "]]
[["String strMode", " strMode   =  strMode.trim (  )   . toLowerCase (  )   ", " if (  strMode.length (  )    ==  NUM_   ||  strMode.length (  )    ==  NUM_   ) ", " return  _toOctalMode (  strMode   )   "], ["String strMode", " strMode   =  strMode.trim (  )   . toLowerCase (  )   ", " if (  strMode.length (  )    ==  NUM_   ||  strMode.length (  )    ==  NUM_   ) ", " if (  strMode.length (  )    <=  NUM_   &&  strMode.length (  )    >  NUM_   ) ", " return  Integer.parseInt (  strMode   ,  NUM_   )   "], ["String strMode", " strMode   =  strMode.trim (  )   . toLowerCase (  )   ", " if (  strMode.length (  )    ==  NUM_   ||  strMode.length (  )    ==  NUM_   ) ", " if (  strMode.length (  )    <=  NUM_   &&  strMode.length (  )    >  NUM_   ) ", " new IOException (  STR_   +  strMode   +  STR_   )   "]]
[["String msg", "   "]]
[[" return ! alliance.hasMember (  invited.getObjectId (  )    )   "]]
[["ValueExp v1 , ValueExp v2", " return  new BinaryRelQueryExp (  LT   ,  v1   ,  v2   )   "]]
[[" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) ", " p_width   +=  m_colGap  ", " p_width   -=  m_colGap  ", " return  BOOL_  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) ", " p_width   +=  m_colGap  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) ", " p_width   -=  m_colGap  ", " return  BOOL_  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   +=  m_rowGap  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   +=  m_rowGap  ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) ", " p_width   +=  m_colGap  ", " p_width   -=  m_colGap  ", " return  BOOL_  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   +=  m_rowGap  ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) ", " p_width   +=  m_colGap  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   +=  m_rowGap  ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) ", " p_width   -=  m_colGap  ", " return  BOOL_  "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) ", " p_height   +=  m_rowGap  ", " p_height   -=  m_rowGap  ", " p_width   =  NUM_  ", "for (  ;  c   <  m_cols   ;  c ++  ) ", " p_width   +=  m_colWidth   [  c   ]", " if (  m_colWidth   [  c   ] >  NUM_   ) "], [" p_height   =  NUM_  ", "for (  ;  r   <  m_rows   ;  r ++  ) ", " p_height   +=  m_rowHeight   [  r   ]", " if (  m_rowHeight   [  r   ] >  NUM_   ) "]]
[["String styleKey", " return  styleKeys.remove (  styleKey   )   "]]
[[" return  SINGLETON  "]]
[["RandomAccessFile randomAccessFile", "  randomAccessFile    . randomAccessFile   =  randomAccessFile  "]]
[[" if (  journalWriter   ==  null   ) ", " return "], [" if (  journalWriter   ==  null   ) ", "for ( Entry entry :  new ArrayList (  lruEntries.values (  )    )    )", " if (  entry.currentEditor   !=  null   ) ", " trimToSize (  )   ", " journalWriter.close (  )   ", " journalWriter   =  null  "], [" if (  journalWriter   ==  null   ) ", "for ( Entry entry :  new ArrayList (  lruEntries.values (  )    )    )", " if (  entry.currentEditor   !=  null   ) ", " entry.currentEditor.abort (  )   ", " trimToSize (  )   ", " journalWriter.close (  )   ", " journalWriter   =  null  "], [" if (  journalWriter   ==  null   ) ", "for ( Entry entry :  new ArrayList (  lruEntries.values (  )    )    )", " if (  entry.currentEditor   !=  null   ) ", " entry.currentEditor.abort (  )   "], [" if (  journalWriter   ==  null   ) ", "for ( Entry entry :  new ArrayList (  lruEntries.values (  )    )    )", " if (  entry.currentEditor   !=  null   ) "]]
[["InputStream inputStream , OutputStream outputStream , int bufferSize", "byte buffer", "ByteArrayPool.ByteArray array =  null  ", " if (  bufferSize   >  BUFFER_SIZE   ) ", " array   =  BUFFER_POOL.getByteArray (  )   ", " buffer   =  array.getBytes (  )   ", " IOUtils.copyLarge (  inputStream   ,  outputStream   ,  buffer   )   ", " outputStream.flush (  )   ", " if (  array   !=  null   ) ", " array.release (  )   "], ["InputStream inputStream , OutputStream outputStream , int bufferSize", "byte buffer", "ByteArrayPool.ByteArray array =  null  ", " if (  bufferSize   >  BUFFER_SIZE   ) ", " buffer   =  new byte [  bufferSize   ]   ", " IOUtils.copyLarge (  inputStream   ,  outputStream   ,  buffer   )   ", " outputStream.flush (  )   ", " if (  array   !=  null   ) ", " array.release (  )   "]]
[[" children   =  new ASTNode [  NUM_   ]   "]]
[[" return  surfaceNormalArrow.getSceneHints (  )   . getCullHint (  )    !=  CullHint.Always  "]]
[["Path file", " return  Files.readAttributes (  file   ,  BasicFileAttributes    )   . creationTime (  )   "]]
[[" totalTime   =  NUM_  ", " drawCycles   =  NUM_  "]]
[["String message", " if (  debug   ) ", " logger.info (  message   )   "]]
[["DynamicClassLoader loader , String name , Path sourcePath , Path classPath , CodeSource codeSource", " _loader   =  loader  ", " _name   =  name  ", " _classPath   =  classPath  ", " setDependPath (  classPath   )   ", " if (  sourcePath   !=  null   && ! sourcePath.equals (  classPath   )    ) ", " _codeSource   =  codeSource  "], ["DynamicClassLoader loader , String name , Path sourcePath , Path classPath , CodeSource codeSource", " _loader   =  loader  ", " _name   =  name  ", " _classPath   =  classPath  ", " setDependPath (  classPath   )   ", " if (  sourcePath   !=  null   && ! sourcePath.equals (  classPath   )    ) ", " _sourcePath   =  sourcePath  ", " _sourceLastModified   =  sourcePath.getLastModified (  )   ", " _sourceLength   =  sourcePath.length (  )   ", " _codeSource   =  codeSource  "]]
[["String urlPath", "boolean ok =  BOOL_  ", "URL url =  new URL (  urlPath   )   ", "InputStream is =  url.openStream (  )   ", " ok   =  streamToSpeech (  is   )   ", " return  ok  "]]
[[" return  order  "]]
[["int keySize", " return  generateDerivedParameters (  keySize   )   "]]
[[" return  includeGlobalState  "]]
[[" return  STR_   +  value  "]]
[[" mSpeedTestMode   =  SpeedTestMode.NONE  ", " mForceCloseSocket   =  BOOL_  ", " if (  mFtpInputstream   !=  null   ) ", " mFtpInputstream.close (  )   ", " if (  mFtpOutputstream   !=  null   ) ", " mFtpOutputstream.close (  )   "], [" mSpeedTestMode   =  SpeedTestMode.NONE  ", " mForceCloseSocket   =  BOOL_  ", " if (  mFtpInputstream   !=  null   ) ", " if (  mFtpOutputstream   !=  null   ) ", " mFtpOutputstream.close (  )   "]]
[["Process proc", "BufferedReader stdOut =  new BufferedReader (  new InputStreamReader (  proc.getInputStream (  )    )    )   ", "String s", "while (  s   =  stdOut.readLine (  )    !=  null   )", " System.out.println (  STR_   +  s   )   "], ["Process proc", "BufferedReader stdOut =  new BufferedReader (  new InputStreamReader (  proc.getInputStream (  )    )    )   ", "String s", "while (  s   =  stdOut.readLine (  )    !=  null   )", " System.out.println (  STR_   +  s   )   ", "BufferedReader errOut =  new BufferedReader (  new InputStreamReader (  proc.getErrorStream (  )    )    )   ", "while (  s   =  errOut.readLine (  )    !=  null   )", " System.out.println (  STR_   +  s   )   "]]
[[" side1   =  side2   =  side3   =  NUM_  "]]
[["int key", "int i =  binarySearch (  mKeys   ,  NUM_   ,  mSize   ,  key   )   ", " if (  i   >=  NUM_   ) ", " if (  mValues   [  i   ] !=  DELETED   ) ", " mValues   [  i   ] =  DELETED  ", " mGarbage   =  BOOL_  "]]
[["List list", " return  cloneHelper.detachVolumeClone (  list   )   "]]
[["int index", "  callbackIndex    . callbackIndex   =  index  ", " return    "]]
[["int icon , CharSequence title , Action.OnActionListener listener", " N.addAction (  icon   ,  title   ,  listener   )   ", " return    "]]
[[" ensureValidCache (  )   ", " if (  cachedIsLafAqua   ==  null   ) ", " return  cachedIsLafAqua.booleanValue (  )   "], [" ensureValidCache (  )   ", " if (  cachedIsLafAqua   ==  null   ) ", " cachedIsLafAqua   =  Boolean.valueOf (  computeIsLafAqua (  )    )   ", " return  cachedIsLafAqua.booleanValue (  )   "]]
[["double d", " return  format (  d   ,  sigDigit   )   "]]
[["String memberStr", "SimpleDateFormat timeParser =  new SimpleDateFormat (  CarbonProperties.getInstance (  )   . getProperty (  CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT   ,  CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT   )    )   ", " timeParser.setLenient (  BOOL_   )   ", " if (  null   ==  memberStr   ||  memberStr.trim (  )   . isEmpty (  )    ||  memberStr.equals (  CarbonCommonConstants.MEMBER_DEFAULT_VAL   )    ) ", " return  NUM_  "], ["String memberStr", "SimpleDateFormat timeParser =  new SimpleDateFormat (  CarbonProperties.getInstance (  )   . getProperty (  CarbonCommonConstants.CARBON_TIMESTAMP_FORMAT   ,  CarbonCommonConstants.CARBON_TIMESTAMP_DEFAULT_FORMAT   )    )   ", " timeParser.setLenient (  BOOL_   )   ", " if (  null   ==  memberStr   ||  memberStr.trim (  )   . isEmpty (  )    ||  memberStr.equals (  CarbonCommonConstants.MEMBER_DEFAULT_VAL   )    ) ", " return  getDirectSurrogateForMember (  memberStr   ,  timeParser   )   "]]
[["String timezone", "   "]]
[["Query query", " return  new CompoundSelect (  CompoundSelectOperator.UNION   ,  query   )   "]]
[["String detailMessage , Throwable cause", "   "]]
[["DalvInsn insn", " finisher.add (  insn   )   "]]
[[" _loadBalanceAllocateCount.incrementAndGet (  )   "]]
[["String outputPath", " m_outputHome   =  new File (  outputPath   )   ", " m_modelsPath   =  new File (  m_outputHome   ,  STR_   )   ", " m_continuousOutputPath   =  new File (  m_outputHome   ,  STR_   )   ", " m_anaAdhocOutputPath   =  new File (  m_outputHome   ,  STR_   )   ", " ExtFileUtils.createDir (  m_modelsPath   )   ", " ExtFileUtils.createDir (  m_continuousOutputPath   )   ", " ExtFileUtils.createDir (  m_anaAdhocOutputPath   )   "]]
[["Object proxy , Method method , Object args", "String name =  method.getName (  )   ", " if (  method.getDeclaringClass (  )    ==  GroovyObject    ) ", " return  InvokerHelper.invokeMethod (  extension   ,  method.getName (  )    ,  args   )   "], ["Object proxy , Method method , Object args", "String name =  method.getName (  )   ", " if (  method.getDeclaringClass (  )    ==  GroovyObject    ) ", " if (  name.equals (  STR_   )    ) ", " return  getMetaClass (  )   "], ["Object proxy , Method method , Object args", "String name =  method.getName (  )   ", " if (  method.getDeclaringClass (  )    ==  GroovyObject    ) ", " if (  name.equals (  STR_   )    ) ", " if (  name.equals (  STR_   )    ) ", " return  setMetaClass (  )   "], ["Object proxy , Method method , Object args", "String name =  method.getName (  )   ", " if (  method.getDeclaringClass (  )    ==  GroovyObject    ) ", " if (  name.equals (  STR_   )    ) ", " if (  name.equals (  STR_   )    ) ", " return  InvokerHelper.invokeMethod (  extension   ,  method.getName (  )    ,  args   )   "]]
[["long a , int l , int k", "int w =  weight   [  k   ]", "long h =  init   [  k   ]", "int i =  l  ", "while (  i --  !=  NUM_   )", " h   ^=  h   <<  NUM_   +  a   [  i   ] *  w   [  i   %  NUMBER_OF_WEIGHTS   ] +  h   >>>  NUM_  "], ["long a , int l , int k", "int w =  weight   [  k   ]", "long h =  init   [  k   ]", "int i =  l  ", "while (  i --  !=  NUM_   )", " h   ^=  h   <<  NUM_   +  a   [  i   ] *  w   [  i   %  NUMBER_OF_WEIGHTS   ] +  h   >>>  NUM_  ", " return  h   &  NUM_   %  m  "]]
[["List requestPrefixList , String requestedElementName", " if (  requestPrefixList   !=  null   &&  requestedElementName   !=  null   ) ", "for ( String requestPrefix :  requestPrefixList   )", " if (  isElement (  requestPrefix   ,  requestedElementName   )    ) "], ["List requestPrefixList , String requestedElementName", " if (  requestPrefixList   !=  null   &&  requestedElementName   !=  null   ) ", "for ( String requestPrefix :  requestPrefixList   )", " if (  isElement (  requestPrefix   ,  requestedElementName   )    ) ", " return  BOOL_  "], ["List requestPrefixList , String requestedElementName", " if (  requestPrefixList   !=  null   &&  requestedElementName   !=  null   ) ", "for ( String requestPrefix :  requestPrefixList   )", " if (  isElement (  requestPrefix   ,  requestedElementName   )    ) ", " return  BOOL_  "], ["List requestPrefixList , String requestedElementName", " if (  requestPrefixList   !=  null   &&  requestedElementName   !=  null   ) ", " return  BOOL_  "]]
[[" return  INSTANCE.get (  )   "]]
[[" return  isEmpty (  )   "]]
[["List filterList", " return  null  "]]
[["String desc , int dims", " if (  mv   !=  null   ) ", " mv.visitMultiANewArrayInsn (  desc   ,  dims   )   "]]
[["String field , Type type , boolean reverse", " initFieldType (  field   ,  type   )   ", "  reverse    . reverse   =  reverse  "]]
[["ISwingWorker worker", "boolean finishUpWithWorker =  BOOL_  ", " finishUpWithWorker   = ! layerWorkerQueue  ", " setLayerWorker (  layerWorkerQueue  ? createLayerWorker (  )   : null   )   ", " layerWorkerQueue   =  BOOL_  ", " if (  finishUpWithWorker   ) ", " getProjectionChangePolicy (  )   . workerComplete (  worker.get (  )    )   "]]
[["Permission permission", "String permissionType =  permission.getPermissionType (  )   ", "String targetId =  permission.getTargetId (  )   ", "Permission current =  permissionRepository.findTopByPermissionTypeAndTargetId (  permissionType   ,  targetId   )   ", " Preconditions.checkState (  current   ==  null   ,  STR_   ,  permissionType   ,  targetId   )   ", " return  permissionRepository.save (  permission   )   "]]
[["char errorCode", " return  createConnectErrorResponse (  errorCode   ,  null   )   "]]
[["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  STR_  ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  style   +  STR_   +  extraStyle  ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  STR_  ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  style   +  STR_   +  extraStyle.substring (  NUM_   )   ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  STR_  ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  STR_   +  extraStyle.substring (  NUM_   )   ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  STR_  ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  STR_   +  extraStyle  ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  extraStyle.trim (  )   ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  style   +  STR_   +  extraStyle  ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  extraStyle.trim (  )   ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  style   +  STR_   +  extraStyle.substring (  NUM_   )   ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  extraStyle.trim (  )   ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  STR_   +  extraStyle.substring (  NUM_   )   ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  style.trim (  )   ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  extraStyle.trim (  )   ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  STR_   +  extraStyle  ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  STR_  ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  STR_  ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  style   +  STR_   +  extraStyle  ", " return  res  "], ["String style , String extraStyle", "String res", " if (  style   ==  null   ) ", " style   =  STR_  ", " if (  extraStyle   ==  null   ) ", " extraStyle   =  STR_  ", " if (  style.isEmpty (  )    ) ", " if (  extraStyle.startsWith (  STR_   )    ||  extraStyle.startsWith (  STR_   )    ) ", " res   =  style   +  STR_   +  extraStyle.substring (  NUM_   )   ", " return  res  "]]
[["int port", "CacheServer bridge =  getCache (  )   . addCacheServer (  )   ", " bridge.setPort (  port   )   ", " bridge.setMaxThreads (  getMaxThreads (  )    )   ", " bridgeServerPort   =  bridge.getPort (  )   "]]
[["PriceModelHistory pmHistory", " if (  pmHistory.getType (  )    ==  org.oscm.internal.types.enumtypes.PriceModelType.PER_UNIT   ) ", " return  PricingPeriodDateConverter.getStartTime (  billingInput.getBillingPeriodStart (  )    ,  pmHistory.getPeriod (  )    )   . getTimeInMillis (  )   "], ["PriceModelHistory pmHistory", " if (  pmHistory.getType (  )    ==  org.oscm.internal.types.enumtypes.PriceModelType.PER_UNIT   ) ", " return  billingInput.getBillingPeriodStart (  )   "]]
[]
[["Flux flux", " return  Flux.fromIterable (  null   )   "]]
[["double point1 , double point2", " return  Math.sqrt (  distance2 (  point1   ,  point2   )    )    /  point1.length  "]]
[["List sourceList , List entryList", " if (  sourceList   ==  null   ||  isEmpty (  entryList   )    ) ", " return  NUM_  "], ["List sourceList , List entryList", " if (  sourceList   ==  null   ||  isEmpty (  entryList   )    ) ", "int sourceCount =  sourceList.size (  )   ", "for ( V entry :  entryList   )", " if ( ! sourceList.contains (  entry   )    ) ", " return  sourceList.size (  )    -  sourceCount  "], ["List sourceList , List entryList", " if (  sourceList   ==  null   ||  isEmpty (  entryList   )    ) ", "int sourceCount =  sourceList.size (  )   ", "for ( V entry :  entryList   )", " if ( ! sourceList.contains (  entry   )    ) ", " sourceList.add (  entry   )   ", " return  sourceList.size (  )    -  sourceCount  "], ["List sourceList , List entryList", " if (  sourceList   ==  null   ||  isEmpty (  entryList   )    ) ", "int sourceCount =  sourceList.size (  )   ", "for ( V entry :  entryList   )", " if ( ! sourceList.contains (  entry   )    ) ", " sourceList.add (  entry   )   "], ["List sourceList , List entryList", " if (  sourceList   ==  null   ||  isEmpty (  entryList   )    ) ", "int sourceCount =  sourceList.size (  )   ", "for ( V entry :  entryList   )", " if ( ! sourceList.contains (  entry   )    ) "]]
[["int d , double val", " return  val   /  imadsigma   [  d   ] +  median   [  d   ]"]]
[["MethodParameter parameter , ModelMap model , ServerWebExchange exchange", "String name =  HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE  ", "Optional value =  exchange.getAttribute (  name   )   ", " return  value.isPresent (  )   ? Mono.just (  value.get (  )    )   : Mono.just (  Collections.emptyMap (  )    )   "]]
[["byte protoVer", " if (  GridBinaryMarshaller.PROTO_VER   !=  protoVer   ) ", " new BinaryObjectException (  STR_   +  protoVer   )   "]]
[["String url , int triesCount", " return  downloadString (  new URL (  url   )    ,  null   ,  DEFAULT_READ_TIMEOUT   ,  DEFAULT_SOCKET_TIMEOUT   ,  STR_   ,  triesCount   )   "]]
[["StatisticsFactory f", "  _stats    . _stats   =  f.createAtomicStatistics (  _type   ,  STR_   )   "]]
[["MetaCharacter meta", "  meta    . meta   =  meta  "]]
[["double least , double bound", " if (  least   >=  bound   ) ", " new IllegalArgumentException (  )   ", " return  nextDouble (  )    *  bound   -  least   +  least  "], ["double least , double bound", " if (  least   >=  bound   ) ", " return  nextDouble (  )    *  bound   -  least   +  least  "]]
[["short nodeType , String nodeValue", "int contentSpecIndex =  createContentSpec (  )   ", " fContentSpec.setValues (  nodeType   ,  nodeValue   ,  null   )   ", " setContentSpec (  contentSpecIndex   ,  fContentSpec   )   ", " return  contentSpecIndex  "]]
[["SSOToken ssoToken", " ssoTokens.add (  ssoToken   )   ", " Logger.token.set (  ssoToken   )   "]]
[[" return  services.isEmpty (  )   "]]
[["DefaultMutableTreeNode node , String startsWith", " return  checkNameFromNode (  node   ,  NUM_   ,  startsWith   )   "]]
[["int opcode", " if (  mv   !=  null   ) ", " mv.visitInsn (  opcode   )   "]]
[["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " deviceConfiguration   =  TerminalEmulatorDeviceConfiguration.getDefault (  )   ", " if (  fontConfiguration   ==  null   ) ", " if (  colorConfiguration   ==  null   ) ", " colorConfiguration   =  TerminalEmulatorColorConfiguration.getDefault (  )   ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " deviceConfiguration   =  TerminalEmulatorDeviceConfiguration.getDefault (  )   ", " if (  fontConfiguration   ==  null   ) ", " if (  colorConfiguration   ==  null   ) ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " deviceConfiguration   =  TerminalEmulatorDeviceConfiguration.getDefault (  )   ", " if (  fontConfiguration   ==  null   ) ", " fontConfiguration   =  SwingTerminalFontConfiguration.getDefault (  )   ", " if (  colorConfiguration   ==  null   ) ", " colorConfiguration   =  TerminalEmulatorColorConfiguration.getDefault (  )   ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " deviceConfiguration   =  TerminalEmulatorDeviceConfiguration.getDefault (  )   ", " if (  fontConfiguration   ==  null   ) ", " fontConfiguration   =  SwingTerminalFontConfiguration.getDefault (  )   ", " if (  colorConfiguration   ==  null   ) ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " if (  fontConfiguration   ==  null   ) ", " if (  colorConfiguration   ==  null   ) ", " colorConfiguration   =  TerminalEmulatorColorConfiguration.getDefault (  )   ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " if (  fontConfiguration   ==  null   ) ", " if (  colorConfiguration   ==  null   ) ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " if (  fontConfiguration   ==  null   ) ", " fontConfiguration   =  SwingTerminalFontConfiguration.getDefault (  )   ", " if (  colorConfiguration   ==  null   ) ", " colorConfiguration   =  TerminalEmulatorColorConfiguration.getDefault (  )   ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "], ["TerminalSize initialTerminalSize , TerminalEmulatorDeviceConfiguration deviceConfiguration , AWTTerminalFontConfiguration fontConfiguration , TerminalEmulatorColorConfiguration colorConfiguration , TerminalScrollController scrollController", " if (  deviceConfiguration   ==  null   ) ", " if (  fontConfiguration   ==  null   ) ", " fontConfiguration   =  SwingTerminalFontConfiguration.getDefault (  )   ", " if (  colorConfiguration   ==  null   ) ", " terminalImplementation   =  new AWTTerminalImplementation (     ,  fontConfiguration   ,  initialTerminalSize   ,  deviceConfiguration   ,  colorConfiguration   ,  scrollController   )   "]]
[["int n", "double d =  new double [  n   ]   ", "for (  ;  i   <  n   ;  i ++  ) ", " d   [  i   ] =  R.nextGaussian (  )   "], ["int n", "double d =  new double [  n   ]   ", "for (  ;  i   <  n   ;  i ++  ) ", " d   [  i   ] =  R.nextGaussian (  )   ", " return  d  "]]
[["V initialValue", " value   =  initialValue  "]]
[["String localUsername , String remoteUsername , String command", " rcommand (  localUsername   ,  remoteUsername   ,  command   ,  BOOL_   )   "]]
[["View view", "int currentPosition =  mPager.getCurrentItem (  )   ", " if (  currentPosition   !=  mPager.getAdapter (  )   . getCount (  )    -  NUM_   ) ", " characterSelectedHelper (  currentPosition   +  NUM_   ,  BOOL_   )   "]]
[["SegmentProperties segmentProperties", "IndexKey startIndexKey", "long dictionarySurrogateKey =  new long [  segmentProperties.getDimensions (  )   . size (  )    -  segmentProperties.getNumberOfNoDictionaryDimension (  )    ]   ", "byte dictionaryStartMdkey =  segmentProperties.getDimensionKeyGenerator (  )   . generateKey (  dictionarySurrogateKey   )   ", "byte noDictionaryStartKeyArray =  getNoDictionaryDefaultStartKey (  segmentProperties   )   ", " startIndexKey   =  new IndexKey (  dictionaryStartMdkey   ,  noDictionaryStartKeyArray   )   ", " return  startIndexKey  "]]
[["Canvas c , Rect bounds", "RectF arcBounds =  mTempBounds  ", " arcBounds.set (  bounds   )   ", " arcBounds.inset (  mStrokeInset   ,  mStrokeInset   )   ", "float startAngle =  mStartTrim   +  mRotation   *  NUM_  ", "float endAngle =  mEndTrim   +  mRotation   *  NUM_  ", "float sweepAngle =  endAngle   -  startAngle  ", " mPaint.setColor (  mColors   [  mColorIndex   ] )   ", " c.drawArc (  arcBounds   ,  startAngle   ,  sweepAngle   ,  BOOL_   ,  mPaint   )   ", " drawTriangle (  c   ,  startAngle   ,  sweepAngle   ,  bounds   )   ", " if (  mAlpha   <  NUM_   ) ", " mCirclePaint.setColor (  mBackgroundColor   )   ", " mCirclePaint.setAlpha (  NUM_   -  mAlpha   )   ", " c.drawCircle (  bounds.exactCenterX (  )    ,  bounds.exactCenterY (  )    ,  bounds.width (  )    /  NUM_   ,  mCirclePaint   )   "]]
[["Collection col", " if (  surrogateIds   ==  null   ) ", "for (  ;  i   <  surrogateIds.length   ;  i ++  ) ", " col.add (  surrogateIds   [  i   ] )   "], ["Collection col", " if (  surrogateIds   ==  null   ) ", " surrogateIds   =  new IgniteUuid [  ids.length   ]   ", "for (  ;  i   <  surrogateIds.length   ;  i ++  ) ", " surrogateIds   [  i   ] =  IgniteUuid.randomUuid (  )   ", "for (  ;  i   <  surrogateIds.length   ;  i ++  ) ", " col.add (  surrogateIds   [  i   ] )   "], ["Collection col", " if (  surrogateIds   ==  null   ) ", " surrogateIds   =  new IgniteUuid [  ids.length   ]   ", "for (  ;  i   <  surrogateIds.length   ;  i ++  ) ", " surrogateIds   [  i   ] =  IgniteUuid.randomUuid (  )   "]]
[["LinkedList events =  new LinkedList (  )   ", "for (  ;  seqno   <  NUM_   ;  seqno ++  ) ", "for (  ;  fragNo   <  NUM_   ;  fragNo ++  ) ", "ReplDBMSEvent event =  helper.createEvent (  seqno   ,  STR_   ,  fragNo   ,  fragNo   ==  NUM_   )   ", " events.add (  event   )   ", " checkBlockCommitSemantics (  events   ,  BlockCommitPolicy.lax   ,  BOOL_   ,  null   )   ", " checkBlockCommitSemantics (  events   ,  BlockCommitPolicy.strict   ,  BOOL_   ,  null   )   ", " checkBlockCommitSemantics (  events   ,  null   ,  BOOL_   ,  null   )   "], ["LinkedList events =  new LinkedList (  )   ", "for (  ;  seqno   <  NUM_   ;  seqno ++  ) ", "for (  ;  fragNo   <  NUM_   ;  fragNo ++  ) ", "ReplDBMSEvent event =  helper.createEvent (  seqno   ,  STR_   ,  fragNo   ,  fragNo   ==  NUM_   )   ", " events.add (  event   )   "]]
[["View changedView , int visibility", "   ", " if (  changedView   !=     ) ", " if (  visibility   ==  View.VISIBLE   ) ", " resume (  )   "], ["View changedView , int visibility", "   ", " if (  changedView   !=     ) ", " if (  visibility   ==  View.VISIBLE   ) ", " pause (  )   "], ["View changedView , int visibility", "   ", " if (  changedView   !=     ) ", " return "]]
[["java.sql.Time x", " if (  x   ==  null   ) ", " return  STR_  "], ["java.sql.Time x", " if (  x   ==  null   ) ", " return  STR_   +  x.toString (  )    +  STR_  "]]
[["String command , String host , int port , String user , Path privateKeyFilePath , boolean logCommand", " return  new SimpleCommand (  command   ,  new SecureShellAgent (  host   ,  port   ,  user   ,  privateKeyFilePath   )    ,  null   ,  logCommand   )   "]]
[["int fieldId", "_Fields fields =  findByThriftId (  fieldId   )   ", " if (  fields   ==  null   ) ", " return  fields  "], ["int fieldId", "_Fields fields =  findByThriftId (  fieldId   )   ", " if (  fields   ==  null   ) ", " new IllegalArgumentException (  STR_   +  fieldId   +  STR_   )   ", " return  fields  "]]
[["Class clazz", "TimeSeries ts =  clazz.getAnnotation (  TimeSeries    )   ", " return  ts   !=  null   &&  ts.value (  )   "]]
[["CarbonFile sourceLocation , String desTinationLocation", "InputStream inputStream =  null  ", "OutputStream outputStream =  null  ", " inputStream   =  FileFactory.getDataInputStream (  sourceLocation.getAbsolutePath (  )    ,  FileFactory.getFileType (  sourceLocation.getAbsolutePath (  )    )    )   ", " outputStream   =  FileFactory.getDataOutputStream (  desTinationLocation   ,  FileFactory.getFileType (  desTinationLocation   )    ,  NUM_   ,  BOOL_   )   ", " copyFile (  inputStream   ,  outputStream   )   "]]
[[" return  new Object [  ,  ]   "]]
[["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " myHost.updateProgress (  progressLabel   ,  progress   )   ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "], ["String progressLabel , int progress", " if (  myHost   !=  null   &&  progress   !=  previousProgress   ||  progressLabel.equals (  previousProgressLabel   )    ) ", " previousProgress   =  progress  ", " previousProgressLabel   =  progressLabel  "]]
[[" a   = ", " n   =  NUM_  "]]
[["short a", " DualPivotQuicksort.sort (  a   ,  NUM_   ,  a.length   -  NUM_   ,  null   ,  NUM_   ,  NUM_   )   "]]
[["Node node , Slot slot", "int spins =  SPINS  ", "for (  ;  ;  ) ", "Object v =  node.get (  )   ", " if (  v   !=  null   ) ", " if (  spins   >  NUM_   ) ", " tryCancel (  node   ,  slot   )   "], ["Node node , Slot slot", "int spins =  SPINS  ", "for (  ;  ;  ) ", "Object v =  node.get (  )   ", " if (  v   !=  null   ) ", " if (  spins   >  NUM_   ) ", "-- spins  "], ["Node node , Slot slot", "int spins =  SPINS  ", "for (  ;  ;  ) ", "Object v =  node.get (  )   ", " if (  v   !=  null   ) ", " return  v  "]]
[["String path", " registerFont (  path   ,  null   )   "]]
[["int degrees , int minutes , int seconds", " if (  minutes   <  NUM_   ||  minutes   >=  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " if (  seconds   <  NUM_   ||  seconds   >=  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " return  Angle.fromDegrees (  Math.signum (  degrees   )    *  Math.abs (  degrees   )    +  minutes   /  NUM_   +  seconds   /  NUM_   )   "], ["int degrees , int minutes , int seconds", " if (  minutes   <  NUM_   ||  minutes   >=  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " if (  seconds   <  NUM_   ||  seconds   >=  NUM_   ) ", " return  Angle.fromDegrees (  Math.signum (  degrees   )    *  Math.abs (  degrees   )    +  minutes   /  NUM_   +  seconds   /  NUM_   )   "], ["int degrees , int minutes , int seconds", " if (  minutes   <  NUM_   ||  minutes   >=  NUM_   ) ", " if (  seconds   <  NUM_   ||  seconds   >=  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " return  Angle.fromDegrees (  Math.signum (  degrees   )    *  Math.abs (  degrees   )    +  minutes   /  NUM_   +  seconds   /  NUM_   )   "], ["int degrees , int minutes , int seconds", " if (  minutes   <  NUM_   ||  minutes   >=  NUM_   ) ", " if (  seconds   <  NUM_   ||  seconds   >=  NUM_   ) ", " return  Angle.fromDegrees (  Math.signum (  degrees   )    *  Math.abs (  degrees   )    +  minutes   /  NUM_   +  seconds   /  NUM_   )   "]]
[["String method , Object args", " startCall (  method   )   ", " if (  args   !=  null   ) ", "for (  ;  i   <  args.length   ;  i ++  ) ", " writeObject (  args   [  i   ] )   "], ["String method , Object args", " startCall (  method   )   ", " if (  args   !=  null   ) ", "for (  ;  i   <  args.length   ;  i ++  ) ", " writeObject (  args   [  i   ] )   ", " completeCall (  )   "], ["String method , Object args", " startCall (  method   )   ", " if (  args   !=  null   ) ", " completeCall (  )   "]]
[[" return  paused  "]]
[[" return  O   !=  null   ||  U   !=  null  "]]
[["Map outputs , Draft2PortProcessorCallback portProcessor", " return  processValues (  outputs   ,  job.getApp (  )   . getOutputs (  )    ,  Draft2OutputPort    ,  portProcessor   )   "]]
[[" return  new ParameterSignatureIterator (  )   "]]
[["GSSessionImpl session", "   "]]
[[" return  genStringAsCharArray  "]]
[["int port", " t   =  new Thread (  new SSClient (  port   )    ,  STR_   )   ", " t.start (  )   ", " Thread.sleep (  NUM_   )   "]]
[["char endDelimiter", " pos ++ ", " if (  pos   >=  buffer.length   ) ", " new IllegalStateException (  STR_   )   ", " if (  buffer   [  pos   ] ==  ESCAPE_CHAR   ) ", " if (  buffer   [  pos   ] ==  endDelimiter   ) ", " pos ++ ", " return  endDelimiter  "], ["char endDelimiter", " pos ++ ", " if (  pos   >=  buffer.length   ) ", " new IllegalStateException (  STR_   )   ", " if (  buffer   [  pos   ] ==  ESCAPE_CHAR   ) ", " if (  buffer   [  pos   ] ==  endDelimiter   ) ", " return  ESCAPE_CHAR  "], ["char endDelimiter", " pos ++ ", " if (  pos   >=  buffer.length   ) ", " new IllegalStateException (  STR_   )   ", " if (  buffer   [  pos   ] ==  ESCAPE_CHAR   ) ", " pos ++ ", " return  ESCAPE_CHAR  "], ["char endDelimiter", " pos ++ ", " if (  pos   >=  buffer.length   ) ", " if (  buffer   [  pos   ] ==  ESCAPE_CHAR   ) ", " if (  buffer   [  pos   ] ==  endDelimiter   ) ", " pos ++ ", " return  endDelimiter  "], ["char endDelimiter", " pos ++ ", " if (  pos   >=  buffer.length   ) ", " if (  buffer   [  pos   ] ==  ESCAPE_CHAR   ) ", " if (  buffer   [  pos   ] ==  endDelimiter   ) ", " return  ESCAPE_CHAR  "], ["char endDelimiter", " pos ++ ", " if (  pos   >=  buffer.length   ) ", " if (  buffer   [  pos   ] ==  ESCAPE_CHAR   ) ", " pos ++ ", " return  ESCAPE_CHAR  "]]
[["String xml", "Object object =  XACMLSDKUtils.getObjectInstance (  XACMLConstants.RESULT   ,  xml   )   ", " if (  object   ==  null   ) ", " return  new ResultImpl (  xml   )   "], ["String xml", "Object object =  XACMLSDKUtils.getObjectInstance (  XACMLConstants.RESULT   ,  xml   )   ", " if (  object   ==  null   ) ", " return "]]
[[" if (  doNotCheckCapabilities (  )    ) ", " return  m_Dependencies.size (  )    >  NUM_  "], [" if (  doNotCheckCapabilities (  )    ) ", " return  BOOL_  "]]
[["int h", " h   ^=  h   >>>  NUM_   ^  h   >>>  NUM_  ", " return  h   ^  h   >>>  NUM_   ^  h   >>>  NUM_  "]]
[["Object narrowFrom , Class narrowTo", " ensureAvailable (  )   ", " return  proxy.narrow (  narrowFrom   ,  narrowTo   )   "]]
[[" logger.fine (  STR_   +  address   )   ", "Map resMap =  null  ", " resMap   =  new java.util.LinkedHashMap (  )   ", "Map res =  get (  COMMON_SYS_OIDS   )   ", " if (  res   !=  null   ) ", "for ( Map.Entry e :  res.entrySet (  )    )", " if (  STR_.equalsIgnoreCase (  e.getValue (  )    )    ) ", " resMap.put (  OID_NAME_MAP.get (  STR_   +  e.getKey (  )   . toString (  )    )    ,  e.getValue (  )    )   "], [" logger.fine (  STR_   +  address   )   ", "Map resMap =  null  ", " resMap   =  new java.util.LinkedHashMap (  )   ", "Map res =  get (  COMMON_SYS_OIDS   )   ", " if (  res   !=  null   ) ", "for ( Map.Entry e :  res.entrySet (  )    )", " if (  STR_.equalsIgnoreCase (  e.getValue (  )    )    ) ", " resMap.put (  OID_NAME_MAP.get (  STR_   +  e.getKey (  )   . toString (  )    )    ,  e.getValue (  )    )   ", " return  resMap  "], [" logger.fine (  STR_   +  address   )   ", "Map resMap =  null  ", " resMap   =  new java.util.LinkedHashMap (  )   ", "Map res =  get (  COMMON_SYS_OIDS   )   ", " if (  res   !=  null   ) ", " return  resMap  "]]
[["Context context , Account account , String authTokenType", "   "]]
[["int offset , int remove , int oldGapSize , int newGapSize , int newGapStart", "int newGapEnd =  newGapStart   +  newGapSize  ", " if (  offset   <  fGapStart   ) ", "int offsetShifted =  offset   +  oldGapSize  ", "int betweenSize =  offsetShifted   -  fGapEnd  ", " arrayCopy (  fGapEnd   ,  fContent   ,  fGapStart   ,  betweenSize   )   ", " return  newGapEnd  "], ["int offset , int remove , int oldGapSize , int newGapSize , int newGapStart", "int newGapEnd =  newGapStart   +  newGapSize  ", " if (  offset   <  fGapStart   ) ", "int afterRemove =  offset   +  remove  ", " if (  afterRemove   <  fGapStart   ) ", " return  newGapEnd  "], ["int offset , int remove , int oldGapSize , int newGapSize , int newGapStart", "int newGapEnd =  newGapStart   +  newGapSize  ", " if (  offset   <  fGapStart   ) ", "int afterRemove =  offset   +  remove  ", " if (  afterRemove   <  fGapStart   ) ", "int betweenSize =  fGapStart   -  afterRemove  ", " arrayCopy (  afterRemove   ,  fContent   ,  newGapEnd   ,  betweenSize   )   ", " return  newGapEnd  "]]
[["Object oo =  get_Value (  COLUMNNAME_IsInfoSent   )   ", " if (  oo   !=  null   ) ", " return  BOOL_  "], ["Object oo =  get_Value (  COLUMNNAME_IsInfoSent   )   ", " if (  oo   !=  null   ) ", " if (  oo   instanceof Boolean ) ", " return "], ["Object oo =  get_Value (  COLUMNNAME_IsInfoSent   )   ", " if (  oo   !=  null   ) ", " if (  oo   instanceof Boolean ) ", " return  STR_.equals (  oo   )   "]]
[["Context context , PendingIntent notificationClient , Class serviceClass", " return  DownloaderService.startDownloadServiceIfRequired (  context   ,  notificationClient   ,  serviceClass   )   "]]
[["RequestHeader RequestHeader , RegisteredServer Server", "RegisterServerRequest req =  new RegisterServerRequest (  RequestHeader   ,  Server   )   ", " return "]]
[["String aExperimentName , Class mlAdapter", " setExperimentName (  aExperimentName   )   ", " setMachineLearningAdapter (  mlAdapter   )   ", " setType (  STR_   +  experimentName   )   ", " setAttribute (  TC_TASK_TYPE   ,  TcTaskType.EVALUATION.toString (  )    )   "]]
[["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " storeAsTypeWithSignaturesImport (  objSubjectExpression.getType (  )   . toString (  )    ,  objScope   ,  objIndex   ,  objTypesSet   )   "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " if (  objType   ==  PhpTokenTypes.opINTEGER_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opARRAY_CAST   ) ", " objTypesSet.add (  Types.strArray   )   ", " return "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " if (  objType   ==  PhpTokenTypes.opINTEGER_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opARRAY_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opBOOLEAN_CAST   ) ", " objTypesSet.add (  Types.strBoolean   )   ", " return "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " if (  objType   ==  PhpTokenTypes.opINTEGER_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opARRAY_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opBOOLEAN_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opFLOAT_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opSTRING_CAST   ) ", " objTypesSet.add (  Types.strString   )   ", " return "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " if (  objType   ==  PhpTokenTypes.opINTEGER_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opARRAY_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opBOOLEAN_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opFLOAT_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opSTRING_CAST   ) ", " return "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " if (  objType   ==  PhpTokenTypes.opINTEGER_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opARRAY_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opBOOLEAN_CAST   ) ", " if (  objType   ==  PhpTokenTypes.opFLOAT_CAST   ) ", " objTypesSet.add (  Types.strFloat   )   ", " return "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", "IElementType objType =  objOperation.getNode (  )   . getElementType (  )   ", " if (  PhpTokenTypes.CAST_OPERATORS.contains (  objType   )    ) ", " if (  objType   ==  PhpTokenTypes.opINTEGER_CAST   ) ", " objTypesSet.add (  Types.strInteger   )   ", " return "], ["UnaryExpression objSubjectExpression , Function objScope , PhpIndex objIndex , HashSet objTypesSet", "PsiElement objOperation =  objSubjectExpression.getOperation (  )   ", " if (  null   ==  objOperation   ) ", " return "]]
[["byte encoding", "   "]]
[["String args", "PieChartDemo1 demo =  new PieChartDemo1 (  STR_   )   ", " demo.pack (  )   ", " RefineryUtilities.centerFrameOnScreen (  demo   )   ", " demo.setVisible (  BOOL_   )   "]]
[["Map map , K key , Callable c", " A.notNull (  map   ,  STR_   )   ", " if ( ! map.containsKey (  key   )    ) ", " return  map.get (  key   )   "], ["Map map , K key , Callable c", " A.notNull (  map   ,  STR_   )   ", " if ( ! map.containsKey (  key   )    ) ", "V v =  c   ==  null  ? null  : c.call (  )   ", " map.put (  key   ,  v   )   ", " return  v  "]]
[[" tags   =  new LinkedHashMap (  )   "]]
[[" return  new SubscriberObject (     )   "]]
[[" return  addressOutOfRange  "]]
[["DockerConnector connector", " LOG.debug (  STR_   ,  connector.getServerUrl (  )    )   ", " withCredentials (  connector.getCredentialsId (  )    )   ", " withConnectorType (  connector.getConnectorType (  )    )   ", " withConnectTimeout (  connector.getConnectTimeout (  )    )   ", " return  forServer (  connector.getServerUrl (  )    ,  connector.getApiVersion (  )    )   "]]
[["String name", "  name    . name   =  name  ", " return    "]]
[["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  Arrays.clone (  precalc   )   ", " if (  preMessageParameters   !=  null   ) ", "for (  ;  i   <  preMessageParameters.length   ;  i ++  ) ", "Parameter param =  preMessageParameters   [  i   ]", " ubiComplete (  param.getType (  )    ,  param.getValue (  )    )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  Arrays.clone (  precalc   )   ", " if (  preMessageParameters   !=  null   ) ", "for (  ;  i   <  preMessageParameters.length   ;  i ++  ) ", "Parameter param =  preMessageParameters   [  i   ]", " ubiComplete (  param.getType (  )    ,  param.getValue (  )    )   ", " initialState   =  Arrays.clone (  chain   )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  Arrays.clone (  precalc   )   ", " if (  preMessageParameters   !=  null   ) ", " initialState   =  Arrays.clone (  chain   )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  new long [  getBlockSize (  )    /  NUM_   ]   ", " if (  key   !=  null   ) ", " ubiComplete (  PARAM_TYPE_CONFIG   ,  new Configuration (  outputSizeBytes   *  NUM_   )   . getBytes (  )    )   ", " if (  preMessageParameters   !=  null   ) ", "for (  ;  i   <  preMessageParameters.length   ;  i ++  ) ", "Parameter param =  preMessageParameters   [  i   ]", " ubiComplete (  param.getType (  )    ,  param.getValue (  )    )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  new long [  getBlockSize (  )    /  NUM_   ]   ", " if (  key   !=  null   ) ", " ubiComplete (  PARAM_TYPE_CONFIG   ,  new Configuration (  outputSizeBytes   *  NUM_   )   . getBytes (  )    )   ", " if (  preMessageParameters   !=  null   ) ", "for (  ;  i   <  preMessageParameters.length   ;  i ++  ) ", "Parameter param =  preMessageParameters   [  i   ]", " ubiComplete (  param.getType (  )    ,  param.getValue (  )    )   ", " initialState   =  Arrays.clone (  chain   )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  new long [  getBlockSize (  )    /  NUM_   ]   ", " if (  key   !=  null   ) ", " ubiComplete (  PARAM_TYPE_CONFIG   ,  new Configuration (  outputSizeBytes   *  NUM_   )   . getBytes (  )    )   ", " if (  preMessageParameters   !=  null   ) ", " initialState   =  Arrays.clone (  chain   )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  new long [  getBlockSize (  )    /  NUM_   ]   ", " if (  key   !=  null   ) ", " ubiComplete (  SkeinParameters.PARAM_TYPE_KEY   ,  key   )   ", " ubiComplete (  PARAM_TYPE_CONFIG   ,  new Configuration (  outputSizeBytes   *  NUM_   )   . getBytes (  )    )   ", " if (  preMessageParameters   !=  null   ) ", "for (  ;  i   <  preMessageParameters.length   ;  i ++  ) ", "Parameter param =  preMessageParameters   [  i   ]", " ubiComplete (  param.getType (  )    ,  param.getValue (  )    )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  new long [  getBlockSize (  )    /  NUM_   ]   ", " if (  key   !=  null   ) ", " ubiComplete (  SkeinParameters.PARAM_TYPE_KEY   ,  key   )   ", " ubiComplete (  PARAM_TYPE_CONFIG   ,  new Configuration (  outputSizeBytes   *  NUM_   )   . getBytes (  )    )   ", " if (  preMessageParameters   !=  null   ) ", "for (  ;  i   <  preMessageParameters.length   ;  i ++  ) ", "Parameter param =  preMessageParameters   [  i   ]", " ubiComplete (  param.getType (  )    ,  param.getValue (  )    )   ", " initialState   =  Arrays.clone (  chain   )   "], ["long precalc", " if (  key   ==  null   &&  precalc   !=  null   ) ", " chain   =  new long [  getBlockSize (  )    /  NUM_   ]   ", " if (  key   !=  null   ) ", " ubiComplete (  SkeinParameters.PARAM_TYPE_KEY   ,  key   )   ", " ubiComplete (  PARAM_TYPE_CONFIG   ,  new Configuration (  outputSizeBytes   *  NUM_   )   . getBytes (  )    )   ", " if (  preMessageParameters   !=  null   ) ", " initialState   =  Arrays.clone (  chain   )   "]]
[["Location loc", " if (  loc.equals (  signLocation   )    ) ", " signLocation   =  null  ", " return  BOOL_  "], ["Location loc", " if (  loc.equals (  signLocation   )    ) ", " return  BOOL_  "]]
[["String id , String virtualArrayId", "NetworkRestRep network =  getNetwork (  id   )   ", "NetworkForm form =  new NetworkForm (  )   ", " form.load (  network   )   ", " edit (  form   )   "]]
[[" m_docElement   =  NULL  ", " initDocument (  NUM_   )   "]]
[["CompoundButton buttonView , boolean isChecked", " if (  buttonView   ==  mShowAllDisplaysCheckbox   ) ", " mDisplayListAdapter.updateContents (  )   "], ["CompoundButton buttonView , boolean isChecked", " if (  buttonView   ==  mShowAllDisplaysCheckbox   ) ", "Display display", " if (  isChecked   ) ", " hidePresentation (  display   )   "], ["CompoundButton buttonView , boolean isChecked", " if (  buttonView   ==  mShowAllDisplaysCheckbox   ) ", "Display display", " if (  isChecked   ) ", "PresentationContents contents =  new PresentationContents (  getNextPhoto (  )    )   ", " showPresentation (  display   ,  contents   )   "]]
[["Logger logger , int logFrequency , String message", "   "]]
[["DHPrivateKeyParameters privkey", " return  privkey.getX (  )   . toByteArray (  )   "]]
[["String name , Set outputNames , LocalVariableMap symbolTable", "StringBuilder sb =  new StringBuilder (  )   ", " sb.append (  name   )   ", " sb.append (  STR_   )   ", " sb.append (  displayOutputs (  outputNames   ,  symbolTable   )    )   ", " return  sb.toString (  )   "]]
[["JoinStatus joinStatus", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_UNKNOWN   ) ", " return  ADJoinStatus.UNKNOWN.name (  )   "], ["JoinStatus joinStatus", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_UNKNOWN   ) ", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_WORKGROUP   ) ", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_DOMAIN   ) ", " return  ADJoinStatus.DOMAIN.name (  )   "], ["JoinStatus joinStatus", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_UNKNOWN   ) ", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_WORKGROUP   ) ", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_DOMAIN   ) ", " new DTOMapperException (  STR_   +  joinStatus.name (  )    )   "], ["JoinStatus joinStatus", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_UNKNOWN   ) ", " if (  joinStatus   ==  JoinStatus.ACTIVE_DIRECTORY_JOIN_STATUS_WORKGROUP   ) ", " return  ADJoinStatus.WORKGROUP.name (  )   "]]
[["long freeMemory , long allocatedMemory , long objects , int fragmentation", "ManagementService service =  ManagementService.getExistingManagementService (  getCache (  )    )   ", " assertNotNull (  service   )   ", " assertTrue (  service.isManager (  )    )   ", "MemberMXBean memberBean =  service.getMemberMXBean (  )   ", " assertNotNull (  memberBean   )   ", " assertEquals (  freeMemory   ,  memberBean.getOffHeapFreeMemory (  )    )   ", " assertEquals (  allocatedMemory   ,  memberBean.getOffHeapUsedMemory (  )    )   ", " assertEquals (  objects   ,  memberBean.getOffHeapObjects (  )    )   ", " assertEquals (  fragmentation   ,  memberBean.getOffHeapFragmentation (  )    )   "]]
[["String parentFieldName , String nestedFieldName , String nestedFieldValue , Occurance occurance", " return  addFieldClause (  QuerySpecification.buildCompositeFieldName (  parentFieldName   ,  nestedFieldName   )    ,  nestedFieldValue   ,  occurance   )   "]]
[["boolean result =  BOOL_  ", " if ( ! hasTotalCount (  )    ) ", " if (  skipResults   +  pageSize   <=  totalCount   ) ", " return  result  "], ["boolean result =  BOOL_  ", " if ( ! hasTotalCount (  )    ) ", " if (  skipResults   +  pageSize   <=  totalCount   ) ", " result   =  BOOL_  ", " return  result  "], ["boolean result =  BOOL_  ", " if ( ! hasTotalCount (  )    ) ", " result   =  BOOL_  ", " return  result  "]]
[["PipelinedMsgParser p =  new PipelinedMsgParser (  )   ", " p.rawInputStream   =   rawInputStream    . rawInputStream  ", " p.sipMessageListener   =   sipMessageListener    . sipMessageListener  ", "Thread mythread =  new Thread (  p   )   ", " mythread.setName (  STR_   )   ", " return  p  "]]
[["boolean enablePositionIncrements", "  enablePositionIncrements    . enablePositionIncrements   =  enablePositionIncrements  ", " return    "]]
[["String volumeName , long capacity , String volumeTypeId , String sourceVolId", " return  createVolume (  volumeName   ,  capacity   ,  volumeTypeId   ,  sourceVolId   ,  null   )   "]]
[["String scheme", " if (  scheme   ==  null   ) ", " new NullPointerException (  STR_   )   ", "WWWAuthenticate www =  new WWWAuthenticate (  )   ", " www.setScheme (  scheme   )   ", " return  www  "], ["String scheme", " if (  scheme   ==  null   ) ", "WWWAuthenticate www =  new WWWAuthenticate (  )   ", " www.setScheme (  scheme   )   ", " return  www  "]]
[["VirtualFile virtualFile =  myFixture.copyFileToProject (  STR_   ,  STR_   )   ", " myFixture.copyFileToProject (  STR_   ,  STR_   )   ", " myFixture.copyFileToProject (  STR_   ,  STR_   )   ", " myFixture.copyFileToProject (  STR_   ,  STR_   )   ", "ConfigurationManager configurationManager =  myFacet.getConfigurationManager (  )   ", "Configuration configuration =  configurationManager.getConfiguration (  virtualFile   )   ", "ThemeResolver themeResolver =  new ThemeResolver (  configuration   )   ", "ConfiguredThemeEditorStyle theme =  themeResolver.getTheme (  STR_   )   ", " assertNotNull (  theme   )   ", " theme.setValue (  STR_   ,  STR_   )   ", " theme.setValue (  STR_   ,  STR_   )   ", " theme.setParent (  STR_   )   ", " myFixture.checkResultByFile (  STR_   ,  STR_   ,  BOOL_   )   ", " myFixture.checkResultByFile (  STR_   ,  STR_   ,  BOOL_   )   ", " myFixture.checkResultByFile (  STR_   ,  STR_   ,  BOOL_   )   ", " myFixture.checkResultByFile (  STR_   ,  STR_   ,  BOOL_   )   "]]
[["View child , int index", " if (  child   ==  null   ||  getRealView (  )    ==  null   ) ", " return "], ["View child , int index", " if (  child   ==  null   ||  getRealView (  )    ==  null   ) ", " if (  child   instanceof WXBaseRefreshLayout ) ", " return "], ["View child , int index", " if (  child   ==  null   ||  getRealView (  )    ==  null   ) ", " if (  child   instanceof WXBaseRefreshLayout ) ", "int count =  getRealView (  )   . getChildCount (  )   ", " index   =  index   >=  count  ?- NUM_  : index  ", " if (  index   == - NUM_   ) ", " getRealView (  )   . addView (  child   ,  index   )   "], ["View child , int index", " if (  child   ==  null   ||  getRealView (  )    ==  null   ) ", " if (  child   instanceof WXBaseRefreshLayout ) ", "int count =  getRealView (  )   . getChildCount (  )   ", " index   =  index   >=  count  ?- NUM_  : index  ", " if (  index   == - NUM_   ) ", " getRealView (  )   . addView (  child   )   "]]
[["String msg", "for ( String s :  msg   )", " System.out.println (  s   )   "]]
[["double dInit", " Simil   =  Double.valueOf (  dInit   )   "]]
[["InetAddress host , int port", " __sendPacket.setAddress (  host   )   ", " __sendPacket.setPort (  port   )   ", " _socket_.send (  __sendPacket   )   "]]
[["String args", " DOMTestCase.doMain (  nodeentitynodetype    ,  args   )   "]]
[["int highOrder , int lowOrder", " return  <<  NUM_   |  &  NUM_  "]]
[["Throwable cause", "   "]]
[[" mIsRunning.set (  BOOL_   )   "]]
[["String args", " DOMTestCase.doMain (  hc_nodedocumentnodeattribute    ,  args   )   "]]
[["  runtimeService   ,  startProcessInstanceByKey (  STR_   )     . runtimeService  . startProcessInstanceByKey (  STR_   )   ", " assertEquals (  STR_   ,  NUM_   ,  listener.filterEvents (  ActivitiEventType.PROCESS_COMPLETED   )   . size (  )    )   "]]
[["int id , int revisionNumber", "JobNotification result =  null  ", " begin (  )   ", "AuditReader reader =  AuditReaderFactory.get (  getEntityManager (  )    )   ", " result   =  reader.find (  JobNotification    ,  id   ,  revisionNumber   )   ", " Hibernate.initialize (  result.getLifecycleEvents (  )    )   ", " result.getLifecycleEvents (  )   . contains (  JobLifecycleEvent.QUEUE_ADD   )   ", " commit (  )   ", " return  result  "]]
[[" return  parts.size (  )    >  NUM_  "]]
[[" return  Boolean.parseBoolean (  WtWindowManager.getInstance (  )   . getProperty (  STR_   ,  STR_   )    )   "]]
[["V vector", "for ( CLIQUEInterval interval :  intervals   )", "double value =  vector.doubleValue (  interval.getDimension (  )    )   ", " if (  interval.getMin (  )    >  value   ||  value   >=  interval.getMax (  )    ) "], ["V vector", "for ( CLIQUEInterval interval :  intervals   )", "double value =  vector.doubleValue (  interval.getDimension (  )    )   ", " if (  interval.getMin (  )    >  value   ||  value   >=  interval.getMax (  )    ) ", " return  BOOL_  "], ["V vector", "for ( CLIQUEInterval interval :  intervals   )", "double value =  vector.doubleValue (  interval.getDimension (  )    )   ", " if (  interval.getMin (  )    >  value   ||  value   >=  interval.getMax (  )    ) ", " return  BOOL_  "]]
[["String flags =  new String [  userFlags.size (  )    ]   ", "for (  ;  i   <  userFlags.size (  )    ;  i ++  ) ", " flags   [  i   ] =  userFlags.get (  i   )   ", " return  flags  "], ["String flags =  new String [  userFlags.size (  )    ]   ", "for (  ;  i   <  userFlags.size (  )    ;  i ++  ) ", " flags   [  i   ] =  userFlags.get (  i   )   "]]
[["SQLiteDatabase paramSQLiteDatabase", "int numSchemas =  sSchemas.length  ", "for (  ;  i   <  numSchemas   ;  i ++  ) ", "String schema", " paramSQLiteDatabase.execSQL (  createTableQueryFromArray (  sTables   [  i   ] ,  schema   )    )   "]]
[["BigDecimal purchaseAmount , Currency currency", " logPurchase (  purchaseAmount   ,  currency   ,  null   )   "]]
[["double c1xy , double xy", " append (  SVGConstants.PATH_QUAD_TO   ,  c1xy   [  NUM_   ] ,  c1xy   [  NUM_   ] ,  xy   [  NUM_   ] ,  xy   [  NUM_   ] )   ", " return    "]]
[["Element element", " parseElement (  element   )   "]]
[["String label , PendingIntent pendingIntent", " if (  mMenuItems   ==  null   ) ", " mMenuItems   =  new ArrayList (  )   ", "Bundle bundle =  new Bundle (  )   ", " bundle.putString (  KEY_MENU_ITEM_TITLE   ,  label   )   ", " bundle.putParcelable (  KEY_PENDING_INTENT   ,  pendingIntent   )   ", " mMenuItems.add (  bundle   )   ", " return    "], ["String label , PendingIntent pendingIntent", " if (  mMenuItems   ==  null   ) ", "Bundle bundle =  new Bundle (  )   ", " bundle.putString (  KEY_MENU_ITEM_TITLE   ,  label   )   ", " bundle.putParcelable (  KEY_PENDING_INTENT   ,  pendingIntent   )   ", " mMenuItems.add (  bundle   )   ", " return    "]]
[["ContextEncodedNgramLanguageModel lm", " return  wrapWithCacheNotThreadSafe (  lm   ,  NUM_   )   "]]
[["Configuration dertConfig", "File file =  new File (  dertConfig.getLandscapePath (  )    ,  STR_   )   ", " file   =  new File (  file   ,  STR_   )   ", " if ( ! file.exists (  )    ) ", "HashMap savedState =  dertConfig.save (  )   ", " file   =  new File (  file   ,  dertConfig.label   )   ", "ObjectOutputStream oos =  new ObjectOutputStream (  new FileOutputStream (  file   )    )   ", " oos.writeObject (  savedState   )   ", " oos.flush (  )   ", " oos.close (  )   ", " addRecent (  file.getAbsolutePath (  )    )   ", " Console.getInstance (  )   . println (  STR_   +  dertConfig.label   )   "], ["Configuration dertConfig", "File file =  new File (  dertConfig.getLandscapePath (  )    ,  STR_   )   ", " file   =  new File (  file   ,  STR_   )   ", " if ( ! file.exists (  )    ) ", " file.mkdirs (  )   ", "HashMap savedState =  dertConfig.save (  )   ", " file   =  new File (  file   ,  dertConfig.label   )   ", "ObjectOutputStream oos =  new ObjectOutputStream (  new FileOutputStream (  file   )    )   ", " oos.writeObject (  savedState   )   ", " oos.flush (  )   ", " oos.close (  )   ", " addRecent (  file.getAbsolutePath (  )    )   ", " Console.getInstance (  )   . println (  STR_   +  dertConfig.label   )   "]]
[]
[["Object oo =  get_Value (  COLUMNNAME_OverwriteCampaign   )   ", " if (  oo   !=  null   ) ", " if (  oo   instanceof Boolean ) ", " return "], ["Object oo =  get_Value (  COLUMNNAME_OverwriteCampaign   )   ", " if (  oo   !=  null   ) ", " if (  oo   instanceof Boolean ) ", " return  STR_.equals (  oo   )   "], ["Object oo =  get_Value (  COLUMNNAME_OverwriteCampaign   )   ", " if (  oo   !=  null   ) ", " return  BOOL_  "]]
[[" return   pathCondition   ,  size (  )     . pathCondition  . size (  )   "]]
[[" if (  Log.isLoggable (  TAG   ,  Log.DEBUG   )    ) ", " mLock.acquire (  )   ", " if (  Log.isLoggable (  TAG   ,  Log.DEBUG   )    ) ", " Log.d (  TAG   ,  STR_   )   "], [" if (  Log.isLoggable (  TAG   ,  Log.DEBUG   )    ) ", " Log.d (  TAG   ,  STR_   ,  new Throwable (  )    )   ", " mLock.acquire (  )   ", " if (  Log.isLoggable (  TAG   ,  Log.DEBUG   )    ) ", " Log.d (  TAG   ,  STR_   )   "]]
[[" return  value   ==    "]]
[["String objectPath , int nativeData", "String address =  checkPairingRequestAndGetAddress (  objectPath   ,  nativeData   )   ", " if (  address   ==  null   ) ", " mWakeLock.acquire (  )   ", "Intent intent =  new Intent (  BluetoothDevice.ACTION_PAIRING_REQUEST   )   ", " intent.putExtra (  BluetoothDevice.EXTRA_DEVICE   ,  mAdapter.getRemoteDevice (  address   )    )   ", " intent.putExtra (  BluetoothDevice.EXTRA_PAIRING_VARIANT   ,  BluetoothDevice.PAIRING_VARIANT_PASSKEY   )   ", " mContext.sendBroadcast (  intent   ,  BLUETOOTH_ADMIN_PERM   )   ", " mWakeLock.release (  )   ", " return "], ["String objectPath , int nativeData", "String address =  checkPairingRequestAndGetAddress (  objectPath   ,  nativeData   )   ", " if (  address   ==  null   ) ", " return "]]
[[" hierarchicalContainer   =  new HierarchicalContainer (  )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_ACTIVE_HIDDEN   ,  String    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_FORCED   ,  Action    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_ACTION_ID_HIDDEN   ,  Long    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_ACTION_ID   ,  String    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_DIST   ,  String    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_DATETIME   ,  String    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_STATUS_HIDDEN   ,  Action.Status    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_MSGS_HIDDEN   ,  List    ,  null   )   ", " hierarchicalContainer.addContainerProperty (  SPUIDefinitions.ACTION_HIS_TBL_ROLLOUT_NAME   ,  String    ,  null   )   "]]
[["SSOToken ssoToken , String realm , String agentName , String agentType , Map attrValues , String serverURL , String agentURL", " if (  serverURL   ==  null   ||  serverURL.trim (  )   . length (  )    ==  NUM_   ) ", " if (  agentURL   ==  null   ||  agentURL.trim (  )   . length (  )    ==  NUM_   ) ", "FQDNUrl serverFQDNURL =  null  ", "FQDNUrl agentFQDNURL =  null  ", " serverFQDNURL   =  new FQDNUrl (  serverURL   )   ", " agentFQDNURL   =  new FQDNUrl (  agentURL   )   ", " createAgentEx (  ssoToken   ,  realm   ,  agentName   ,  agentType   ,  attrValues   ,  serverFQDNURL   ,  agentFQDNURL   )   "], ["SSOToken ssoToken , String realm , String agentName , String agentType , Map attrValues , String serverURL , String agentURL", " if (  serverURL   ==  null   ||  serverURL.trim (  )   . length (  )    ==  NUM_   ) ", " if (  agentURL   ==  null   ||  agentURL.trim (  )   . length (  )    ==  NUM_   ) ", " new ConfigurationException (  STR_   ,  null   )   ", "FQDNUrl serverFQDNURL =  null  ", "FQDNUrl agentFQDNURL =  null  ", " serverFQDNURL   =  new FQDNUrl (  serverURL   )   ", " agentFQDNURL   =  new FQDNUrl (  agentURL   )   ", " createAgentEx (  ssoToken   ,  realm   ,  agentName   ,  agentType   ,  attrValues   ,  serverFQDNURL   ,  agentFQDNURL   )   "], ["SSOToken ssoToken , String realm , String agentName , String agentType , Map attrValues , String serverURL , String agentURL", " if (  serverURL   ==  null   ||  serverURL.trim (  )   . length (  )    ==  NUM_   ) ", " new ConfigurationException (  STR_   ,  null   )   ", " if (  agentURL   ==  null   ||  agentURL.trim (  )   . length (  )    ==  NUM_   ) ", "FQDNUrl serverFQDNURL =  null  ", "FQDNUrl agentFQDNURL =  null  ", " serverFQDNURL   =  new FQDNUrl (  serverURL   )   ", " agentFQDNURL   =  new FQDNUrl (  agentURL   )   ", " createAgentEx (  ssoToken   ,  realm   ,  agentName   ,  agentType   ,  attrValues   ,  serverFQDNURL   ,  agentFQDNURL   )   "], ["SSOToken ssoToken , String realm , String agentName , String agentType , Map attrValues , String serverURL , String agentURL", " if (  serverURL   ==  null   ||  serverURL.trim (  )   . length (  )    ==  NUM_   ) ", " new ConfigurationException (  STR_   ,  null   )   ", " if (  agentURL   ==  null   ||  agentURL.trim (  )   . length (  )    ==  NUM_   ) ", " new ConfigurationException (  STR_   ,  null   )   ", "FQDNUrl serverFQDNURL =  null  ", "FQDNUrl agentFQDNURL =  null  ", " serverFQDNURL   =  new FQDNUrl (  serverURL   )   ", " agentFQDNURL   =  new FQDNUrl (  agentURL   )   ", " createAgentEx (  ssoToken   ,  realm   ,  agentName   ,  agentType   ,  attrValues   ,  serverFQDNURL   ,  agentFQDNURL   )   "]]
[["int ndims , int type , Type arrayType", " emitop (  multianewarray   )   ", " if ( ! alive   ) ", " return "], ["int ndims , int type , Type arrayType", " emitop (  multianewarray   )   ", " if ( ! alive   ) ", " emit2 (  type   )   ", " emit1 (  ndims   )   ", " state.pop (  ndims   )   ", " state.push (  arrayType   )   "]]
[["Quaternion input", "  dirty    . dirty   =  BOOL_  ", " addQuat (  input   ,     )   "]]
[["String rawValue", "int value = - NUM_  ", " if (  rawValue.equals (  STR_   )    ) ", " value   =  SUM  ", " return  value  "], ["String rawValue", "int value = - NUM_  ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " value   =  AVG  ", " return  value  "], ["String rawValue", "int value = - NUM_  ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " value   =  PRD  ", " return  value  "], ["String rawValue", "int value = - NUM_  ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " value   =  MIN  ", " return  value  "], ["String rawValue", "int value = - NUM_  ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " return  value  "], ["String rawValue", "int value = - NUM_  ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " if (  rawValue.equals (  STR_   )    ) ", " value   =  MAX  ", " return  value  "]]
[["String name , String pubID , String sysID , String notationName", " DTDprolog (  )   ", " m_writer.write (  STR_   )   ", " m_writer.write (  name   )   ", " if (  pubID   !=  null   ) ", " m_writer.write (  STR_   )   ", " m_writer.write (  sysID   )   ", " m_writer.write (  STR_   )   ", " m_writer.write (  notationName   )   ", " m_writer.write (  STR_   )   ", " m_writer.write (  m_lineSep   ,  NUM_   ,  m_lineSepLen   )   "], ["String name , String pubID , String sysID , String notationName", " DTDprolog (  )   ", " m_writer.write (  STR_   )   ", " m_writer.write (  name   )   ", " if (  pubID   !=  null   ) ", " m_writer.write (  STR_   )   ", " m_writer.write (  pubID   )   ", " m_writer.write (  STR_   )   ", " m_writer.write (  notationName   )   ", " m_writer.write (  STR_   )   ", " m_writer.write (  m_lineSep   ,  NUM_   ,  m_lineSepLen   )   "]]
[["double a , int start , int len , Random r", "for (  ;  i   >  NUM_   ; -- i   ) ", "double t =  a   [  i   ]", "int j =  r.nextInt (  i   )   ", " a   [  i   ] =  a   [  j   ]", " a   [  j   ] =  t  "]]
[["String spaceName , int parts , long init , long max , GridOffHeapEvictListener lsnr", " spaceName   =  maskNull (  spaceName   )   ", "GridOffHeapPartitionedMap m =  GridOffHeapMapFactory.unsafePartitionedMap (  parts   ,  NUM_   ,  NUM_   ,  init   ,  max   ,  ,  lsnr   )   ", "GridOffHeapPartitionedMap old =  offheap.put (  spaceName   ,  m   )   ", " if (  old   !=  null   ) ", " old.destruct (  )   "]]
[["ReadOnlyVector3 p , ReadOnlyVector3 vertex", " return  windingNumber (  p   ,  vertex   )    !=  NUM_  "]]
[["InputStream in , int length", "byte bytes =  new byte [  length   ]   ", "int count", "int pos =  NUM_  ", "while (  pos   <  length   &&  count   =  in.read (  bytes   ,  pos   ,  length   -  pos   )    != - NUM_   )", " pos   +=  count  "], ["InputStream in , int length", "byte bytes =  new byte [  length   ]   ", "int count", "int pos =  NUM_  ", "while (  pos   <  length   &&  count   =  in.read (  bytes   ,  pos   ,  length   -  pos   )    != - NUM_   )", " pos   +=  count  ", " if (  pos   !=  length   ) ", " new IOException (  STR_   +  length   +  STR_   +  pos   +  STR_   )   ", " return  bytes  "], ["InputStream in , int length", "byte bytes =  new byte [  length   ]   ", "int count", "int pos =  NUM_  ", "while (  pos   <  length   &&  count   =  in.read (  bytes   ,  pos   ,  length   -  pos   )    != - NUM_   )", " pos   +=  count  ", " if (  pos   !=  length   ) ", " return  bytes  "]]
[["int index", "Operand r =  getLocal (  index   )   ", " if (  VM.VerifyAssertions   ) ", " opt_assert (  r.isFloat (  )    )   ", " if (  LOCALS_ON_STACK   ) ", " push (  r   )   ", " return  null  "], ["int index", "Operand r =  getLocal (  index   )   ", " if (  VM.VerifyAssertions   ) ", " opt_assert (  r.isFloat (  )    )   ", " if (  LOCALS_ON_STACK   ) ", " return  _moveHelper (  FLOAT_MOVE   ,  r   ,  TypeReference.Float   )   "], ["int index", "Operand r =  getLocal (  index   )   ", " if (  VM.VerifyAssertions   ) ", " if (  LOCALS_ON_STACK   ) ", " push (  r   )   ", " return  null  "], ["int index", "Operand r =  getLocal (  index   )   ", " if (  VM.VerifyAssertions   ) ", " if (  LOCALS_ON_STACK   ) ", " return  _moveHelper (  FLOAT_MOVE   ,  r   ,  TypeReference.Float   )   "]]
[[" EasyMock.expect (  myView.getSelectedParent (  )    )   . andReturn (  getClassByName (  STR_   )    )   . anyTimes (  )   "]]
[["String scriptType , ParsedURL scriptPURL", " userAgent.checkLoadScript (  scriptType   ,  scriptPURL   ,  docPURL   )   "]]
[[" return  String.format (  STR_   ,  x (  )    ,  y (  )    )   "]]
[["   "]]
[["   "]]
[["String propertyValue =  _configReader.getSpaceProperty (  Engine.ENGINE_SERIALIZATION_TYPE_PROP   ,  Engine.ENGINE_SERIALIZATION_TYPE_DEFAULT   )   . trim (  )   ", "int result =  Integer.parseInt (  propertyValue   )   ", "StorageType storageType =  StorageType.fromCode (  result   )   ", " if (  storageType   !=  StorageType.OBJECT   &&  _logger.isLoggable (  Level.WARNING   )    ) ", " return  result  "], ["String propertyValue =  _configReader.getSpaceProperty (  Engine.ENGINE_SERIALIZATION_TYPE_PROP   ,  Engine.ENGINE_SERIALIZATION_TYPE_DEFAULT   )   . trim (  )   ", "int result =  Integer.parseInt (  propertyValue   )   ", "StorageType storageType =  StorageType.fromCode (  result   )   ", " if (  storageType   !=  StorageType.OBJECT   &&  _logger.isLoggable (  Level.WARNING   )    ) ", " _logger.log (  Level.WARNING   ,  Engine.FULL_ENGINE_SERIALIZATION_TYPE_PROP   +  STR_   +  propertyValue   +  STR_   )   ", " return  result  "]]
[["byte dataToEncode , String filename", " if (  dataToEncode   ==  null   ) ", "Base64.OutputStream bos =  null  ", " bos   =  new Base64.OutputStream (  new java.io.FileOutputStream (  filename   )    ,  Base64.ENCODE   )   ", " bos.write (  dataToEncode   )   "], ["byte dataToEncode , String filename", " if (  dataToEncode   ==  null   ) ", " new NullPointerException (  STR_   )   ", "Base64.OutputStream bos =  null  ", " bos   =  new Base64.OutputStream (  new java.io.FileOutputStream (  filename   )    ,  Base64.ENCODE   )   ", " bos.write (  dataToEncode   )   "]]
[["AttackAction ea", " pendingTeleMissileAttacks.addElement (  ea   )   ", " processGameEvent (  new GameNewActionEvent (     ,  ea   )    )   "]]
[[" createLogWindow (  STR_   ,  m_warningLog   ,  Color.BLUE   )   "]]
[[" return "]]
[["String name , boolean resolve", "Class c =   findLoadedClass (  name   )     . findLoadedClass (  name   )   ", " if (  c   !=  null   ) ", " return  c  "], ["String name , boolean resolve", "Class c =   findLoadedClass (  name   )     . findLoadedClass (  name   )   ", " if (  c   !=  null   ) ", " c   = ", " if (  c   !=  null   ) ", " c   =  oldFindClass (  name   )   ", " if (  c   ==  null   ) ", " c   =    ", " if (  resolve   ) ", " resolveClass (  c   )   ", " return  c  "], ["String name , boolean resolve", "Class c =   findLoadedClass (  name   )     . findLoadedClass (  name   )   ", " if (  c   !=  null   ) ", " c   = ", " if (  c   !=  null   ) ", " c   =  oldFindClass (  name   )   ", " if (  c   ==  null   ) ", " c   =    ", " if (  resolve   ) ", " return  c  "], ["String name , boolean resolve", "Class c =   findLoadedClass (  name   )     . findLoadedClass (  name   )   ", " if (  c   !=  null   ) ", " c   = ", " if (  c   !=  null   ) ", " c   =  oldFindClass (  name   )   ", " if (  c   ==  null   ) ", " if (  resolve   ) ", " resolveClass (  c   )   ", " return  c  "], ["String name , boolean resolve", "Class c =   findLoadedClass (  name   )     . findLoadedClass (  name   )   ", " if (  c   !=  null   ) ", " c   = ", " if (  c   !=  null   ) ", " c   =  oldFindClass (  name   )   ", " if (  c   ==  null   ) ", " if (  resolve   ) ", " return  c  "], ["String name , boolean resolve", "Class c =   findLoadedClass (  name   )     . findLoadedClass (  name   )   ", " if (  c   !=  null   ) ", " c   = ", " if (  c   !=  null   ) ", " return  c  "]]
[["int initialCapacity , float loadFactor", "   ", " if (  initialCapacity   <  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " if (  loadFactor   <=  NUM_   ||  Float.isNaN (  loadFactor   )    ) ", "  loadFactor    . loadFactor   =  loadFactor  ", "  threshold    . threshold   =  calculateThreshold (  initialCapacity   ,  loadFactor   )   ", " initialCapacity   =  calculateNewCapacity (  initialCapacity   )   ", "  data    . data   =  new HashEntry [  initialCapacity   ]   ", " init (  )   "], ["int initialCapacity , float loadFactor", "   ", " if (  initialCapacity   <  NUM_   ) ", " new IllegalArgumentException (  STR_   )   ", " if (  loadFactor   <=  NUM_   ||  Float.isNaN (  loadFactor   )    ) ", " new IllegalArgumentException (  STR_   )   ", "  loadFactor    . loadFactor   =  loadFactor  ", "  threshold    . threshold   =  calculateThreshold (  initialCapacity   ,  loadFactor   )   ", " initialCapacity   =  calculateNewCapacity (  initialCapacity   )   ", "  data    . data   =  new HashEntry [  initialCapacity   ]   ", " init (  )   "], ["int initialCapacity , float loadFactor", "   ", " if (  initialCapacity   <  NUM_   ) ", " if (  loadFactor   <=  NUM_   ||  Float.isNaN (  loadFactor   )    ) ", "  loadFactor    . loadFactor   =  loadFactor  ", "  threshold    . threshold   =  calculateThreshold (  initialCapacity   ,  loadFactor   )   ", " initialCapacity   =  calculateNewCapacity (  initialCapacity   )   ", "  data    . data   =  new HashEntry [  initialCapacity   ]   ", " init (  )   "], ["int initialCapacity , float loadFactor", "   ", " if (  initialCapacity   <  NUM_   ) ", " if (  loadFactor   <=  NUM_   ||  Float.isNaN (  loadFactor   )    ) ", " new IllegalArgumentException (  STR_   )   ", "  loadFactor    . loadFactor   =  loadFactor  ", "  threshold    . threshold   =  calculateThreshold (  initialCapacity   ,  loadFactor   )   ", " initialCapacity   =  calculateNewCapacity (  initialCapacity   )   ", "  data    . data   =  new HashEntry [  initialCapacity   ]   ", " init (  )   "]]
[["String s =  soot.PhaseOptions.getString (  options   ,  STR_   )   ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " return  double_set_new_bit  "], ["String s =  soot.PhaseOptions.getString (  options   ,  STR_   )   ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " return  double_set_new_hybrid  "], ["String s =  soot.PhaseOptions.getString (  options   ,  STR_   )   ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " return  double_set_new_array  "], ["String s =  soot.PhaseOptions.getString (  options   ,  STR_   )   ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " new RuntimeException (  STR_   +  s   +  STR_   )   "], ["String s =  soot.PhaseOptions.getString (  options   ,  STR_   )   ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " return  double_set_new_heintze  "], ["String s =  soot.PhaseOptions.getString (  options   ,  STR_   )   ", " if (  s.equalsIgnoreCase (  STR_   )    ) ", " return  double_set_new_hash  "]]
[["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", " return "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", " return "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getFirstMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   =  month   -  mCurrentMonthDisplayed  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " julianDay   +=  DAYS_PER_WEEK  ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getFirstMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   =  month   -  mCurrentMonthDisplayed  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getFirstMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   = - NUM_  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " julianDay   +=  DAYS_PER_WEEK  ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getFirstMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   = - NUM_  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getFirstMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   =  NUM_  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " julianDay   +=  DAYS_PER_WEEK  ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getFirstMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   =  NUM_  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getLastMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   =  month   -  mCurrentMonthDisplayed  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " julianDay   +=  DAYS_PER_WEEK  ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "], ["AbsListView view", "SimpleWeekView child", " if (  child   ==  null   ) ", "int offset =  child.getBottom (  )    <  WEEK_MIN_VISIBLE_HEIGHT  ? NUM_  : NUM_  ", " child   = ", " if (  child   ==  null   ) ", "int month", " if (  mIsScrollingUp   ) ", " month   =  child.getLastMonth (  )   ", "int monthDiff", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " if (  mCurrentMonthDisplayed   ==  NUM_   &&  month   ==  NUM_   ) ", " monthDiff   =  month   -  mCurrentMonthDisplayed  ", " if (  monthDiff   !=  NUM_   ) ", "int julianDay =  child.getFirstJulianDay (  )   ", " if (  mIsScrollingUp   ) ", " mTempTime.setJulianDay (  julianDay   )   ", " setMonthDisplayed (  mTempTime   ,  BOOL_   )   "]]
[["BigInteger number", "for (  ;  i   >=  NUM_   ; -- i   ) ", " byteData.add (  Byte.valueOf (  )    )   "]]
[["SearchContext parent , By by , int waitInSeconds", " Preconditions.checkNotNull (  parent   )   ", " Preconditions.checkNotNull (  by   )   ", " findElementClickableAfter (  parent   ,  by   ,  waitInSeconds   )   ", " return  parent.findElements (  by   )   . stream (  )   . filter (  null   )   . collect (  Collectors.toList (  )    )   "]]
[["DataSetEvent e", " m_Saver   =  makeCopy (  )   ", " passEnvOnToSaver (  )   ", " m_fileName   =  sanitizeFilename (  e.getDataSet (  )   . relationName (  )    )   ", " m_dataSet   =  e.getDataSet (  )   ", " if (  e.isStructureOnly (  )    &&  m_isDBSaver   &&  ) ", " if ( ! e.isStructureOnly (  )    ) ", " if ( ! m_isDBSaver   ) ", " saveBatch (  )   ", " System.out.println (  STR_   +  m_fileName   +  STR_   )   "], ["DataSetEvent e", " m_Saver   =  makeCopy (  )   ", " passEnvOnToSaver (  )   ", " m_fileName   =  sanitizeFilename (  e.getDataSet (  )   . relationName (  )    )   ", " m_dataSet   =  e.getDataSet (  )   ", " if (  e.isStructureOnly (  )    &&  m_isDBSaver   &&  ) ", " if ( ! e.isStructureOnly (  )    ) ", " if ( ! m_isDBSaver   ) ", " m_Saver.setDirAndPrefix (  m_fileName   ,  STR_   )   ", " saveBatch (  )   ", " System.out.println (  STR_   +  m_fileName   +  STR_   )   "]]
[["Throwable cause", "   "]]
[[" current   =  stack.pop (  )   ", " return    "]]
[[" click (  InputEvent.BUTTON1_MASK   )   "]]
[["ProjectRef lastOpenedProject =  registry.getLastOpenedProject (  )   ", " if (  lastOpenedProject   !=  null   ) ", " return  loadProject (  lastOpenedProject   )   "], ["ProjectRef lastOpenedProject =  registry.getLastOpenedProject (  )   ", " if (  lastOpenedProject   !=  null   ) ", " return  null  "]]
[["byte b , int off , int len", " return  NUM_  "]]
[["OnlineStatus newStatus", " if (  onlineStatus.canChangeTo (  newStatus   )    ) ", "OnlineStatus oldStatus =  onlineStatus  ", " onlineStatus   =  newStatus  ", "for ( CmrRepositoryChangeListener changeListener :  cmrRepositoryChangeListeners   )", " changeListener.repositoryOnlineStatusUpdated (     ,  oldStatus   ,  newStatus   )   ", " return  BOOL_  "], ["OnlineStatus newStatus", " if (  onlineStatus.canChangeTo (  newStatus   )    ) ", "OnlineStatus oldStatus =  onlineStatus  ", " onlineStatus   =  newStatus  ", "for ( CmrRepositoryChangeListener changeListener :  cmrRepositoryChangeListeners   )", " changeListener.repositoryOnlineStatusUpdated (     ,  oldStatus   ,  newStatus   )   "], ["OnlineStatus newStatus", " if (  onlineStatus.canChangeTo (  newStatus   )    ) ", " return  BOOL_  "]]
[]
[["String fieldNames , Object fieldValues", "   "]]
[[" return  mPrivateDnsRouteSet.get (  )   "]]
[["long t , TimeUnit unit , boolean roundMillis", "long days =  unit.toDays (  t   )   ", "long hours =  unit.toHours (  t   )    %  NUM_  ", "long minutes =  unit.toMinutes (  t   )    %  NUM_  ", "long seconds =  unit.toSeconds (  t   )    %  NUM_  ", "long msecs =  unit.toMillis (  t   )    %  NUM_  ", " if (  roundMillis   ) ", " if (  msecs   >=  NUM_   ) ", " seconds ++ ", " msecs   =  NUM_  ", " if (  seconds   ==  NUM_   ) ", " minutes ++ ", " seconds   =  NUM_  ", " if (  minutes   ==  NUM_   ) ", " hours ++ ", " minutes   =  NUM_  ", " if (  hours   ==  NUM_   ) ", " days ++ ", " hours   =  NUM_  ", " return  new long [  ]   "], ["long t , TimeUnit unit , boolean roundMillis", "long days =  unit.toDays (  t   )   ", "long hours =  unit.toHours (  t   )    %  NUM_  ", "long minutes =  unit.toMinutes (  t   )    %  NUM_  ", "long seconds =  unit.toSeconds (  t   )    %  NUM_  ", "long msecs =  unit.toMillis (  t   )    %  NUM_  ", " if (  roundMillis   ) ", " if (  msecs   >=  NUM_   ) ", " seconds ++ ", " msecs   =  NUM_  ", " if (  seconds   ==  NUM_   ) ", " minutes ++ ", " seconds   =  NUM_  ", " if (  minutes   ==  NUM_   ) ", " hours ++ ", " minutes   =  NUM_  ", " if (  hours   ==  NUM_   ) ", " return  new long [  ]   "], ["long t , TimeUnit unit , boolean roundMillis", "long days =  unit.toDays (  t   )   ", "long hours =  unit.toHours (  t   )    %  NUM_  ", "long minutes =  unit.toMinutes (  t   )    %  NUM_  ", "long seconds =  unit.toSeconds (  t   )    %  NUM_  ", "long msecs =  unit.toMillis (  t   )    %  NUM_  ", " if (  roundMillis   ) ", " if (  msecs   >=  NUM_   ) ", " seconds ++ ", " msecs   =  NUM_  ", " if (  seconds   ==  NUM_   ) ", " minutes ++ ", " seconds   =  NUM_  ", " if (  minutes   ==  NUM_   ) ", " return  new long [  ]   "], ["long t , TimeUnit unit , boolean roundMillis", "long days =  unit.toDays (  t   )   ", "long hours =  unit.toHours (  t   )    %  NUM_  ", "long minutes =  unit.toMinutes (  t   )    %  NUM_  ", "long seconds =  unit.toSeconds (  t   )    %  NUM_  ", "long msecs =  unit.toMillis (  t   )    %  NUM_  ", " if (  roundMillis   ) ", " if (  msecs   >=  NUM_   ) ", " seconds ++ ", " msecs   =  NUM_  ", " if (  seconds   ==  NUM_   ) ", " return  new long [  ]   "], ["long t , TimeUnit unit , boolean roundMillis", "long days =  unit.toDays (  t   )   ", "long hours =  unit.toHours (  t   )    %  NUM_  ", "long minutes =  unit.toMinutes (  t   )    %  NUM_  ", "long seconds =  unit.toSeconds (  t   )    %  NUM_  ", "long msecs =  unit.toMillis (  t   )    %  NUM_  ", " if (  roundMillis   ) ", " if (  msecs   >=  NUM_   ) ", " return  new long [  ]   "], ["long t , TimeUnit unit , boolean roundMillis", "long days =  unit.toDays (  t   )   ", "long hours =  unit.toHours (  t   )    %  NUM_  ", "long minutes =  unit.toMinutes (  t   )    %  NUM_  ", "long seconds =  unit.toSeconds (  t   )    %  NUM_  ", "long msecs =  unit.toMillis (  t   )    %  NUM_  ", " if (  roundMillis   ) ", " return  new long [  ]   "]]
[["   "]]
[["Compiler compiler , int opPos , int analysis", "   "]]
[["JComponent c", "   "]]
[["UnaryOperator operator", " return  new Zipper (  front   ,  back.tail (  )   . plus (  operator.apply (  back.head (  )    )    )    ,  position   )   "]]
[["Geometry geom , GeomInfo2D info , boolean fill", "Coordinate coords =  geom.getCoordinates (  )   ", "GeneralPath path =  new GeneralPath (  GeneralPath.WIND_NON_ZERO   ,  coords.length   )   ", " path.moveTo (  ,  )   ", "for (  ;  i   <  coords.length   ;  i ++  ) ", " path.lineTo (  ,  )   "], ["Geometry geom , GeomInfo2D info , boolean fill", "Coordinate coords =  geom.getCoordinates (  )   ", "GeneralPath path =  new GeneralPath (  GeneralPath.WIND_NON_ZERO   ,  coords.length   )   ", " path.moveTo (  ,  )   ", "for (  ;  i   <  coords.length   ;  i ++  ) ", " path.lineTo (  ,  )   ", " path.transform (  info.transform   )   ", " return  path  "]]
[["ExecutionWindow window", " lock.lock (  )   ", " if ( ! activeWindows.containsKey (  window.getId (  )    )    ) ", " LOG.info (  STR_   +  window.getLabel (  )    )   ", " activeWindows.put (  window.getId (  )    ,  window   )   ", " hasActiveWindows.signalAll (  )   "]]
[["int x , int y , int width , int height", " if (  width   ==  m_extent.width   &&  height   ==  m_extent.height   ) ", " clearRect (  x   ,  y   ,  width   ,  height   )   "], ["int x , int y , int width , int height", " if (  width   ==  m_extent.width   &&  height   ==  m_extent.height   ) ", " if (  DEBUG   ) ", " m_printstream.println (  STR_   )   ", " setStateToLocal (  )   ", " m_printstream.println (  xTransform (  xScale (  x   )    )    +  STR_   +  yTransform (  yScale (  y   )    )    +  STR_   +  xScale (  width   )    +  STR_   +  yScale (  height   )    +  STR_   )   "], ["int x , int y , int width , int height", " if (  width   ==  m_extent.width   &&  height   ==  m_extent.height   ) ", " if (  DEBUG   ) ", " setStateToLocal (  )   ", " m_printstream.println (  xTransform (  xScale (  x   )    )    +  STR_   +  yTransform (  yScale (  y   )    )    +  STR_   +  xScale (  width   )    +  STR_   +  yScale (  height   )    +  STR_   )   "]]
[["String serviceRoot , String entitySetName , String propertyName", "ValuePath$ valuePath =  ValuePath$.MODULE$  ", "scala.Option valuePathOption =  scala.Option.apply (  valuePath   )   ", "PropertyPath propertyPath =  PropertyPath$.MODULE$.apply (  propertyName   ,  valuePathOption   )   ", "scala.Option propertyPathOption =  scala.Option.apply (  propertyPath   )   ", "scala.Option noString =  scala.Option.apply (  null   )   ", "EntityCollectionPath entityCollectionPath =  new EntityCollectionPath (  noString   ,  propertyPathOption   )   ", "scala.Option entityCollectionPathOption =  scala.Option.apply (  entityCollectionPath   )   ", "EntitySetPath entitySetPath =  new EntitySetPath (  entitySetName   ,  entityCollectionPathOption   )   ", "List queryOptions =  new ArrayList (  )   ", "ResourcePathUri resourcePathUri =  new ResourcePathUri (  entitySetPath   ,  asScalaList (  queryOptions   )    )   ", " return  new ODataUri (  serviceRoot   ,  resourcePathUri   )   "]]
[["byte data , int crc", "int tmp =  data   ^  crc   &  NUM_  ", " tmp   ^=  tmp   <<  NUM_   &  NUM_  ", " return  crc   >>  NUM_   ^  tmp   <<  NUM_   ^  tmp   <<  NUM_   ^  tmp   >>  NUM_   &  NUM_  "]]
[["WorldEntity entity", " logger.debug (  STR_   ,  entity.getName (  )    ,  name   )   ", " entities.add (  entity   )   ", " entity.btRigidBody.setUserValue (  entities.size (  )    )   ", " bulletWorld.addRigidBody (  entity.btRigidBody   )   "]]
[["File directory", " checkDirectory (  directory   )   ", "File files =  directory.listFiles (  )   ", " if (  files   ==  null   ) ", "BigInteger size =  BigInteger.ZERO  ", "for ( File file :  files   )", " if ( ! isSymlink (  file   )    ) ", " return  size  "], ["File directory", " checkDirectory (  directory   )   ", "File files =  directory.listFiles (  )   ", " if (  files   ==  null   ) ", "BigInteger size =  BigInteger.ZERO  ", "for ( File file :  files   )", " if ( ! isSymlink (  file   )    ) ", " size   =  size.add (  BigInteger.valueOf (  sizeOf (  file   )    )    )   ", " return  size  "], ["File directory", " checkDirectory (  directory   )   ", "File files =  directory.listFiles (  )   ", " if (  files   ==  null   ) ", "BigInteger size =  BigInteger.ZERO  ", "for ( File file :  files   )", " if ( ! isSymlink (  file   )    ) ", " size   =  size.add (  BigInteger.valueOf (  sizeOf (  file   )    )    )   "], ["File directory", " checkDirectory (  directory   )   ", "File files =  directory.listFiles (  )   ", " if (  files   ==  null   ) ", "BigInteger size =  BigInteger.ZERO  ", "for ( File file :  files   )", " if ( ! isSymlink (  file   )    ) "], ["File directory", " checkDirectory (  directory   )   ", "File files =  directory.listFiles (  )   ", " if (  files   ==  null   ) ", " return  BigInteger.ZERO  "]]
[["   "]]
[["String location", " impl.openNativeNavigationApp (  location   )   "]]
[[" new UnsupportedOperationException (  STR_   )   "]]
[[" CustomLogger.log (  STR_   +  args.length   +  STR_   )   ", "for (  ;  i   <  args.length   ;  i ++  ) ", " CustomLogger.log (  STR_   +  args   [  i   ] )   "], [" CustomLogger.log (  STR_   +  args.length   +  STR_   )   ", "for (  ;  i   <  args.length   ;  i ++  ) ", " CustomLogger.log (  STR_   +  args   [  i   ] )   ", " printer.jumpLine (  )   ", " CustomLogger.log (  STR_   )   ", " if (  args.length   ==  NUM_   ) ", " if (  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_VERSION   )    ||  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_VERSION2   )    ) ", " if (  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_HELP   )    ||  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_HELP2   )    ) ", " return  BOOL_  "], [" CustomLogger.log (  STR_   +  args.length   +  STR_   )   ", "for (  ;  i   <  args.length   ;  i ++  ) ", " CustomLogger.log (  STR_   +  args   [  i   ] )   ", " printer.jumpLine (  )   ", " CustomLogger.log (  STR_   )   ", " if (  args.length   ==  NUM_   ) ", " if (  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_VERSION   )    ||  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_VERSION2   )    ) ", " if (  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_HELP   )    ||  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_HELP2   )    ) ", " CustomLogger.log (  STR_   )   ", " printer.printHelp (  )   ", " return  BOOL_  "], [" CustomLogger.log (  STR_   +  args.length   +  STR_   )   ", "for (  ;  i   <  args.length   ;  i ++  ) ", " CustomLogger.log (  STR_   +  args   [  i   ] )   ", " printer.jumpLine (  )   ", " CustomLogger.log (  STR_   )   ", " if (  args.length   ==  NUM_   ) ", " if (  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_VERSION   )    ||  args   [  NUM_   ]. equalsIgnoreCase (  OPTION_VERSION2   )    ) ", " CustomLogger.log (  STR_   )   ", " printer.printVersion (  )   ", " return  BOOL_  "], [" CustomLogger.log (  STR_   +  args.length   +  STR_   )   ", "for (  ;  i   <  args.length   ;  i ++  ) ", " CustomLogger.log (  STR_   +  args   [  i   ] )   ", " printer.jumpLine (  )   ", " CustomLogger.log (  STR_   )   ", " if (  args.length   ==  NUM_   ) ", " CustomLogger.log (  STR_   )   ", " printer.printHelp (  )   ", " return  BOOL_  "]]
[["String fqn , String method , int size", "String line =  fqn   +  STR_   +  method  ", " if (  line.length (  )    >  size   ) ", " return  line  "], ["String fqn , String method , int size", "String line =  fqn   +  STR_   +  method  ", " if (  line.length (  )    >  size   ) ", " line   =  STR_   +  line.substring (  NUM_   ,  size   )   ", " return  line  "]]
[]
[["String regionPath , GeodeConnectionConf connConf", "GeodeOuterJoinRDD rdd =  rddf.outerJoinGeodeRegion (  regionPath   ,  connConf   )   ", "ClassTag kt =  fakeClassTag (  )   ", "ClassTag vt =  fakeClassTag (  )   ", " return  new JavaPairRDD (  rdd   ,  kt   ,  vt   )   "]]
[[" return   compositeOutputStream   ,  size (  )     . compositeOutputStream  . size (  )   "]]
[["DetailsView detailsView", "DisplayArea displayArea =  getDisplayArea (  detailsView.getTab (  )    )   ", " if (  displayArea   !=  null   ) ", " displayArea.setSelectedTab (  detailsView.getTab (  )    )   "]]
[[" return  fileAccess.isPasswordSupplied (  getIO (  )    )   "]]
[[" return  new com.sun.identity.wsfederation.jaxb.wsspolicy.impl.WssX509V1Token11ElementImpl (  )   "]]
[[" if (  hasFormals   ) ", " hasFormals   =  BOOL_  ", " buf.append (  STR_   )   "]]
[["float regX , float regY", " setScaleRegistration (  regX   ,  regY   )   ", " return    "]]
[["GL10 gl , CGPoint poli , int numberOfPoints , boolean closePolygon", "FloatBuffer vertices =  getVertices (  NUM_   *  numberOfPoints   )   ", "for (  ;  i   <  numberOfPoints   ;  i ++  ) ", " vertices.put (  poli   [  i   ]. x   )   ", " vertices.put (  poli   [  i   ]. y   )   ", " vertices.position (  NUM_   )   ", " gl.glDisable (  GL_TEXTURE_2D   )   ", " gl.glDisableClientState (  GL_TEXTURE_COORD_ARRAY   )   ", " gl.glDisableClientState (  GL_COLOR_ARRAY   )   ", " gl.glVertexPointer (  NUM_   ,  GL_FLOAT   ,  NUM_   ,  vertices   )   ", " if (  closePolygon   ) ", " gl.glDrawArrays (  GL_LINE_LOOP   ,  NUM_   ,  numberOfPoints   )   ", " gl.glEnableClientState (  GL_COLOR_ARRAY   )   ", " gl.glEnableClientState (  GL_TEXTURE_COORD_ARRAY   )   ", " gl.glEnable (  GL_TEXTURE_2D   )   "], ["GL10 gl , CGPoint poli , int numberOfPoints , boolean closePolygon", "FloatBuffer vertices =  getVertices (  NUM_   *  numberOfPoints   )   ", "for (  ;  i   <  numberOfPoints   ;  i ++  ) ", " vertices.put (  poli   [  i   ]. x   )   ", " vertices.put (  poli   [  i   ]. y   )   ", " vertices.position (  NUM_   )   ", " gl.glDisable (  GL_TEXTURE_2D   )   ", " gl.glDisableClientState (  GL_TEXTURE_COORD_ARRAY   )   ", " gl.glDisableClientState (  GL_COLOR_ARRAY   )   ", " gl.glVertexPointer (  NUM_   ,  GL_FLOAT   ,  NUM_   ,  vertices   )   ", " if (  closePolygon   ) ", " gl.glDrawArrays (  GL_LINE_STRIP   ,  NUM_   ,  numberOfPoints   )   ", " gl.glEnableClientState (  GL_COLOR_ARRAY   )   ", " gl.glEnableClientState (  GL_TEXTURE_COORD_ARRAY   )   ", " gl.glEnable (  GL_TEXTURE_2D   )   "], ["GL10 gl , CGPoint poli , int numberOfPoints , boolean closePolygon", "FloatBuffer vertices =  getVertices (  NUM_   *  numberOfPoints   )   ", "for (  ;  i   <  numberOfPoints   ;  i ++  ) ", " vertices.put (  poli   [  i   ]. x   )   ", " vertices.put (  poli   [  i   ]. y   )   "]]
[["AdapterFactory adapterFactory", "   "]]
[["Bundle savedInstanceState", " ButterKnife.bind (     )   ", "File dir =   getDir (  STR_   ,  Activity.MODE_PRIVATE   )     . getDir (  STR_   ,  Activity.MODE_PRIVATE   )   ", "File distFile =  new File (  dir.getAbsolutePath (  )    +  File.separator   +  STR_   )   ", " if (  copyFileFromAssets (  getApplicationContext (  )    ,  STR_   ,  distFile.getAbsolutePath (  )    )    ) ", " System.load (  distFile.getAbsolutePath (  )    )   ", " NativeBlurProcess.isLoadLibraryOk.set (  BOOL_   )   "]]
[["Context context", " return  FontSourceProcessor.process (  R.raw.walkway_oblique   ,  context   )   "]]
[]
[[" return  BOOL_  "]]
[[" executionList.execute (  )   "]]
[["ScaleGestureDetector detector", " return  BOOL_  "]]
[["Object ret", " if (  myHost   !=  null   ) ", " myHost.returnData (  ret   )   "]]
[["Context context , CharSequence msg , DialogInterface.OnCancelListener listener", "AlertDialog dlg =  newDlg (  context   )   ", " dlg.setIcon (  android.R.drawable.ic_dialog_alert   )   ", " dlg.setTitle (  R.string.afc_title_error   )   ", " dlg.setMessage (  msg   )   ", " dlg.setOnCancelListener (  listener   )   ", " dlg.show (  )   "]]
[["Http.Request request", "String preferredType =  getPreferType (  request   ,  STR_   ,  STR_   )   ", " return  preferredType   !=  null  ? preferredType.equals (  STR_   )   : BOOL_  "]]
[["ObjectInputStream stream", " stream.defaultReadObject (  )   ", "  backgroundPaint    . backgroundPaint   =  SerialUtilities.readPaint (  stream   )   "]]
[[" internalReset (  NUM_   )   "]]
[["Boolean value", " return  unsafeParam (  STR_   ,  value   )   "]]
[["SIPDialog sourceDialog , int dialogErrorID", "   ", " errorID   =  dialogErrorID  "]]
[["Catbert.FastStack stack", "UIManager uiMgr =  stack.getUIMgr (  )   ", " if (  uiMgr   !=  null   ) ", " return  Boolean.FALSE  "], ["Catbert.FastStack stack", "UIManager uiMgr =  stack.getUIMgr (  )   ", " if (  uiMgr   !=  null   ) ", " return  uiMgr.hasRemoteFSSupport (  )    ||  uiMgr.getUIClientType (  )    ==  UIClient.LOCAL  ? Boolean.TRUE  : Boolean.FALSE  "]]
[["Mark mark , String label", "for ( Trademark trademark :  mark.getTrademarks (  )    )", " if (  trademark.getLabels (  )   . contains (  label   )    ) ", " return  BOOL_  "], ["Mark mark , String label", "for ( Trademark trademark :  mark.getTrademarks (  )    )", " if (  trademark.getLabels (  )   . contains (  label   )    ) ", "for ( ProtectedMark protectedMark :  concat (  mark.getTreatyOrStatuteMarks (  )    ,  mark.getCourtMarks (  )    )    )", " if (  protectedMark.getLabels (  )   . contains (  label   )    ) "], ["Mark mark , String label", "for ( Trademark trademark :  mark.getTrademarks (  )    )", " if (  trademark.getLabels (  )   . contains (  label   )    ) ", "for ( ProtectedMark protectedMark :  concat (  mark.getTreatyOrStatuteMarks (  )    ,  mark.getCourtMarks (  )    )    )", " if (  protectedMark.getLabels (  )   . contains (  label   )    ) ", " return  BOOL_  "], ["Mark mark , String label", "for ( Trademark trademark :  mark.getTrademarks (  )    )", " if (  trademark.getLabels (  )   . contains (  label   )    ) ", "for ( ProtectedMark protectedMark :  concat (  mark.getTreatyOrStatuteMarks (  )    ,  mark.getCourtMarks (  )    )    )", " if (  protectedMark.getLabels (  )   . contains (  label   )    ) ", " return  BOOL_  "], ["Mark mark , String label", "for ( Trademark trademark :  mark.getTrademarks (  )    )", " if (  trademark.getLabels (  )   . contains (  label   )    ) "]]
[["InetAddress addr , int port", "   "]]
[["int key", "   "]]
[[" probability   *=  / ", " if (  probability   >  randomValue   ) ", " populationCounter -- ", " probability   =  NUM_  ", " randomValue   =  NUM_   -  randomGenerator.nextDouble (  )   ", " return  BOOL_  "], [" probability   *=  / ", " if (  probability   >  randomValue   ) ", " populationCounter -- ", " notRequiredElementsCounter -- ", " return  BOOL_  "]]
[["Long runnerId", " runnersId.add (  runnerId   )   "]]
[]
[]
[["int h", "long u =  h   >>>  segmentShift   &  segmentMask   <<  SSHIFT   +  SBASE  ", " return "]]
[["RPObject object , RPObject changes", "   ", " if (  changes.has (  STR_   )    ) ", " if (  object.has (  STR_   )    ) ", " maxRipeness   =  object.getInt (  STR_   )   "], ["RPObject object , RPObject changes", "   ", " if (  changes.has (  STR_   )    ) ", " ripeness   =  changes.getInt (  STR_   )   ", " fireChange (  PROP_RIPENESS   )   ", " if (  object.has (  STR_   )    ) ", " maxRipeness   =  object.getInt (  STR_   )   "]]
[]
[["int i", " switch (  i   ) ", " case ", " new org.omg.CORBA.BAD_PARAM (  )   "], ["int i", " switch (  i   ) ", " case _ADD_OVERRIDE", " return  ADD_OVERRIDE  "], ["int i", " switch (  i   ) ", " case _SET_OVERRIDE", " return  SET_OVERRIDE  "]]
[[" return  new ContainsSymbolConstraint (  )   "]]
[["String str", " if (  str.contains (  STR_   )    ||  str.contains (  STR_   )    ) ", " return  str  "], ["String str", " if (  str.contains (  STR_   )    ||  str.contains (  STR_   )    ) ", "Locale locale =  Locale.getDefault (  )   ", " str   =  str.replace (  STR_   ,  locale.getLanguage (  )   . toLowerCase (  )    )   ", " str   =  str.replace (  STR_   ,  locale.getCountry (  )   . toLowerCase (  )    )   ", " return  str  "]]
[["BusinessObjectDataKey businessObjectDataKey", "BusinessObjectDataRestoreDto businessObjectDataRestoreDto =  businessObjectDataInitiateRestoreHelperService.prepareToInitiateRestore (  businessObjectDataKey   )   ", " notificationEventService.processStorageUnitNotificationEventAsync (  NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG   ,  businessObjectDataRestoreDto.getBusinessObjectDataKey (  )    ,  businessObjectDataRestoreDto.getOriginStorageName (  )    ,  businessObjectDataRestoreDto.getNewOriginStorageUnitStatus (  )    ,  businessObjectDataRestoreDto.getOldOriginStorageUnitStatus (  )    )   ", " businessObjectDataInitiateRestoreHelperService.executeS3SpecificSteps (  businessObjectDataRestoreDto   )   ", " if (  businessObjectDataRestoreDto.getException (  )    !=  null   ) ", " return  businessObjectDataInitiateRestoreHelperService.executeInitiateRestoreAfterStep (  businessObjectDataRestoreDto   )   "], ["BusinessObjectDataKey businessObjectDataKey", "BusinessObjectDataRestoreDto businessObjectDataRestoreDto =  businessObjectDataInitiateRestoreHelperService.prepareToInitiateRestore (  businessObjectDataKey   )   ", " notificationEventService.processStorageUnitNotificationEventAsync (  NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG   ,  businessObjectDataRestoreDto.getBusinessObjectDataKey (  )    ,  businessObjectDataRestoreDto.getOriginStorageName (  )    ,  businessObjectDataRestoreDto.getNewOriginStorageUnitStatus (  )    ,  businessObjectDataRestoreDto.getOldOriginStorageUnitStatus (  )    )   ", " businessObjectDataInitiateRestoreHelperService.executeS3SpecificSteps (  businessObjectDataRestoreDto   )   ", " if (  businessObjectDataRestoreDto.getException (  )    !=  null   ) ", " businessObjectDataInitiateRestoreHelperService.executeInitiateRestoreAfterStep (  businessObjectDataRestoreDto   )   ", " notificationEventService.processStorageUnitNotificationEventAsync (  NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG   ,  businessObjectDataRestoreDto.getBusinessObjectDataKey (  )    ,  businessObjectDataRestoreDto.getOriginStorageName (  )    ,  businessObjectDataRestoreDto.getNewOriginStorageUnitStatus (  )    ,  businessObjectDataRestoreDto.getOldOriginStorageUnitStatus (  )    )   ", " new IllegalStateException (  businessObjectDataRestoreDto.getException (  )    )   "]]
[[" return  new DefaultProjectClient (  url   ,  authenticationManager   )   "]]
[["String msg , Throwable nested", "   ", "  nested    . nested   =  nested  "]]
[["TupleManager tuples , IntIterator rows", " m_tuples   =  tuples  ", " m_rows   =  rows  "]]
[["ConnectionRecordSet.SortableProperty property , boolean descending", "  property    . property   =  property  ", "  descending    . descending   =  descending  "]]
[["String value", " if (  value   ==  null   ) ", "for (  ;  i   <  patterns.length   ;  i ++  ) ", "Matcher matcher =  patterns   [  i   ]. matcher (  value   )   ", " if (  matcher.matches (  )    ) ", "int count =  matcher.groupCount (  )   ", "String groups =  new String [  count   ]   ", "for (  ;  j   <  count   ;  j ++  ) ", " groups   [  j   ] =  matcher.group (  j   +  NUM_   )   "], ["String value", " if (  value   ==  null   ) ", "for (  ;  i   <  patterns.length   ;  i ++  ) ", "Matcher matcher =  patterns   [  i   ]. matcher (  value   )   ", " if (  matcher.matches (  )    ) ", "int count =  matcher.groupCount (  )   ", "String groups =  new String [  count   ]   ", "for (  ;  j   <  count   ;  j ++  ) ", " groups   [  j   ] =  matcher.group (  j   +  NUM_   )   ", " return  groups  "], ["String value", " if (  value   ==  null   ) ", "for (  ;  i   <  patterns.length   ;  i ++  ) ", "Matcher matcher =  patterns   [  i   ]. matcher (  value   )   ", " if (  matcher.matches (  )    ) "], ["String value", " if (  value   ==  null   ) ", "for (  ;  i   <  patterns.length   ;  i ++  ) ", "Matcher matcher =  patterns   [  i   ]. matcher (  value   )   ", " if (  matcher.matches (  )    ) ", " return  null  "], ["String value", " if (  value   ==  null   ) ", " return  null  "]]
[["Object child , BCSChild bcsc", " children.put (  child   ,  bcsc   )   "]]
[[" resource.setParameter (  STR_   ,  STR_   )   ", " resource.setParameter (  STR_   ,  STR_   )   ", " assertEquals (  STR_   ,  STR_   ,  resource.getParameter (  STR_   )    )   ", " assertEquals (  STR_   ,  STR_   ,  resource.getParameter (  STR_   )    )   "]]
[["Version other", "int minLength =  Math.min (   m_rawVersion   ,  length    . m_rawVersion  . length   ,  other.m_rawVersion.length   )   ", "for (  ;  i   <  minLength   ;  i ++  ) ", "int componentComparison =   m_rawVersion   , [  i   ] ,  compareTo (  other.m_rawVersion   [  i   ] )     . m_rawVersion   [  i   ]. compareTo (  other.m_rawVersion   [  i   ] )   ", " if (  componentComparison   !=  NUM_   ) ", "int lengthComparison =  Integer.valueOf (   m_rawVersion   ,  length    . m_rawVersion  . length   )   . compareTo (  other.m_rawVersion.length   )   ", " if (  lengthComparison   ==  NUM_   ) ", "Version longer =  lengthComparison   >  NUM_  ?   : other  ", "for (  ;  i   <  longer.m_rawVersion.length   ;  i ++  ) ", " if (  longer.m_rawVersion   [  i   ] >  NUM_   ) ", " return  lengthComparison  "], ["Version other", "int minLength =  Math.min (   m_rawVersion   ,  length    . m_rawVersion  . length   ,  other.m_rawVersion.length   )   ", "for (  ;  i   <  minLength   ;  i ++  ) ", "int componentComparison =   m_rawVersion   , [  i   ] ,  compareTo (  other.m_rawVersion   [  i   ] )     . m_rawVersion   [  i   ]. compareTo (  other.m_rawVersion   [  i   ] )   ", " if (  componentComparison   !=  NUM_   ) ", "int lengthComparison =  Integer.valueOf (   m_rawVersion   ,  length    . m_rawVersion  . length   )   . compareTo (  other.m_rawVersion.length   )   ", " if (  lengthComparison   ==  NUM_   ) ", "Version longer =  lengthComparison   >  NUM_  ?   : other  ", "for (  ;  i   <  longer.m_rawVersion.length   ;  i ++  ) ", " if (  longer.m_rawVersion   [  i   ] >  NUM_   ) ", " return  NUM_  "], ["Version other", "int minLength =  Math.min (   m_rawVersion   ,  length    . m_rawVersion  . length   ,  other.m_rawVersion.length   )   ", "for (  ;  i   <  minLength   ;  i ++  ) ", "int componentComparison =   m_rawVersion   , [  i   ] ,  compareTo (  other.m_rawVersion   [  i   ] )     . m_rawVersion   [  i   ]. compareTo (  other.m_rawVersion   [  i   ] )   ", " if (  componentComparison   !=  NUM_   ) ", "int lengthComparison =  Integer.valueOf (   m_rawVersion   ,  length    . m_rawVersion  . length   )   . compareTo (  other.m_rawVersion.length   )   ", " if (  lengthComparison   ==  NUM_   ) ", "Version longer =  lengthComparison   >  NUM_  ?   : other  ", "for (  ;  i   <  longer.m_rawVersion.length   ;  i ++  ) ", " if (  longer.m_rawVersion   [  i   ] >  NUM_   ) "], ["Version other", "int minLength =  Math.min (   m_rawVersion   ,  length    . m_rawVersion  . length   ,  other.m_rawVersion.length   )   ", "for (  ;  i   <  minLength   ;  i ++  ) ", "int componentComparison =   m_rawVersion   , [  i   ] ,  compareTo (  other.m_rawVersion   [  i   ] )     . m_rawVersion   [  i   ]. compareTo (  other.m_rawVersion   [  i   ] )   ", " if (  componentComparison   !=  NUM_   ) ", "int lengthComparison =  Integer.valueOf (   m_rawVersion   ,  length    . m_rawVersion  . length   )   . compareTo (  other.m_rawVersion.length   )   ", " if (  lengthComparison   ==  NUM_   ) ", " return  NUM_  "], ["Version other", "int minLength =  Math.min (   m_rawVersion   ,  length    . m_rawVersion  . length   ,  other.m_rawVersion.length   )   ", "for (  ;  i   <  minLength   ;  i ++  ) ", "int componentComparison =   m_rawVersion   , [  i   ] ,  compareTo (  other.m_rawVersion   [  i   ] )     . m_rawVersion   [  i   ]. compareTo (  other.m_rawVersion   [  i   ] )   ", " if (  componentComparison   !=  NUM_   ) ", " return  componentComparison  "], ["Version other", "int minLength =  Math.min (   m_rawVersion   ,  length    . m_rawVersion  . length   ,  other.m_rawVersion.length   )   ", "for (  ;  i   <  minLength   ;  i ++  ) ", "int componentComparison =   m_rawVersion   , [  i   ] ,  compareTo (  other.m_rawVersion   [  i   ] )     . m_rawVersion   [  i   ]. compareTo (  other.m_rawVersion   [  i   ] )   ", " if (  componentComparison   !=  NUM_   ) "]]
[["Criteria criteria =  createCriteriaInternal (  )   ", " oredCriteria.add (  criteria   )   ", " return  criteria  "]]
[["org.apache.xpath.XPathContext support , org.w3c.dom.Element targetElement", "StylesheetRoot sroot =   getStylesheetRoot (  )     . getStylesheetRoot (  )   ", " return  null   !=  sroot  ? sroot.shouldStripWhiteSpace (  support   ,  targetElement   )   : BOOL_  "]]
[["CompilerConfiguration configuration , GroovyClassLoader classLoader , ErrorCollector er", "  phase    . phase   =  Phases.INITIALIZATION  ", "  configuration    . configuration   =  configuration  ", "  setClassLoader (  classLoader   )     . setClassLoader (  classLoader   )   ", " configure (  configuration   ==  null  ? new CompilerConfiguration (  )   : configuration   )   ", " if (  er   ==  null   ) ", " er   =  new ErrorCollector (  getConfiguration (  )    )   ", "  errorCollector    . errorCollector   =  er  "], ["CompilerConfiguration configuration , GroovyClassLoader classLoader , ErrorCollector er", "  phase    . phase   =  Phases.INITIALIZATION  ", "  configuration    . configuration   =  configuration  ", "  setClassLoader (  classLoader   )     . setClassLoader (  classLoader   )   ", " configure (  configuration   ==  null  ? new CompilerConfiguration (  )   : configuration   )   ", " if (  er   ==  null   ) ", "  errorCollector    . errorCollector   =  er  "]]
[["String specifier", " return  specifier.length (  )    >  NUM_   &&  specifier.charAt (  specifier.length (  )    -  NUM_   )    !=  IPath.SEPARATOR  "]]
